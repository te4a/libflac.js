// include: shell.js
// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(moduleArg) => Promise<Module>
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module != 'undefined' ? Module : {};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

// Attempt to auto-detect the environment
var ENVIRONMENT_IS_WEB = typeof window == 'object';
var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != 'undefined';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
var ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string' && process.type != 'renderer';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {

}

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// include: /home/tema/libflac.js/libflac_pre.js
// libflac.js - port of libflac to JavaScript using emscripten


(function (root, factory) {

	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define(['module', 'require'], factory.bind(null, root));
	} else if (typeof module === 'object' && module.exports) {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.

		// use process.env (if available) for reading Flac environment settings:
		var env = typeof process !== 'undefined' && process && process.env? process.env : root;
		factory(env, module, module.require);
	} else {
		// Browser globals
		root.Flac = factory(root);
	}

}(typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : this, function (global, expLib, require) {
'use strict';

var Module = Module || {};
var _flac_ready = false;
//in case resources are loaded asynchronously (e.g. *.mem file for minified version): setup "ready" handling
Module["onRuntimeInitialized"] = function(){
	_flac_ready = true;
	if(!_exported){
		//if _exported is not yet set (may happen, in case initialization was strictly synchronously),
		// do "pause" until sync initialization has run through
		setTimeout(function(){do_fire_event('ready', [{type: 'ready', target: _exported}], true);}, 0);
	} else {
		do_fire_event('ready', [{type: 'ready', target: _exported}], true);
	}
};

if(global && global.FLAC_SCRIPT_LOCATION){

	Module["locateFile"] = function(fileName){
		var path = global.FLAC_SCRIPT_LOCATION || '';
		if(path[fileName]){
			return path[fileName];
		}
		path += path && !/\/$/.test(path)? '/' : '';
		return path + fileName;
	};

	//NOTE will be overwritten if emscripten has env specific implementation for this
	var readBinary = function(filePath){

		//for Node: use default implementation (copied from generated code):
		if(ENVIRONMENT_IS_NODE){
			var ret = read_(filePath, true);
			if (!ret.buffer) {
				ret = new Uint8Array(ret);
			}
			assert(ret.buffer);
			return ret;
		}

		//otherwise: try "fallback" to AJAX
		return new Promise(function(resolve, reject){
			var xhr = new XMLHttpRequest();
			xhr.responseType = "arraybuffer";
			xhr.addEventListener("load", function(evt){
				resolve(xhr.response);
			});
			xhr.addEventListener("error", function(err){
				reject(err);
			});
			xhr.open("GET", filePath);
			xhr.send();
		});
	};
}

//fallback for fetch && support file://-protocol: try read as binary if fetch fails
if(global && typeof global.fetch === 'function'){
	var _fetch = global.fetch;
	global.fetch = function(url){
		return _fetch.apply(null, arguments).catch(function(err){
			try{
				var result = readBinary(url);
				if(result && result.catch){
					result.catch(function(_err){throw err});
				}
				return result;
			} catch(_err){
				throw err;
			}
		});
	};
}
// end include: /home/tema/libflac.js/libflac_pre.js


// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = Object.assign({}, Module);

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = (status, toThrow) => {
  throw toThrow;
};

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var readAsync, readBinary;

if (ENVIRONMENT_IS_NODE) {

  // These modules will usually be used on Node.js. Load them eagerly to avoid
  // the complexity of lazy-loading.
  var fs = require('fs');
  var nodePath = require('path');

  scriptDirectory = __dirname + '/';

// include: node_shell_read.js
readBinary = (filename) => {
  // We need to re-wrap `file://` strings to URLs.
  filename = isFileURI(filename) ? new URL(filename) : filename;
  var ret = fs.readFileSync(filename);
  return ret;
};

readAsync = async (filename, binary = true) => {
  // See the comment in the `readBinary` function.
  filename = isFileURI(filename) ? new URL(filename) : filename;
  var ret = fs.readFileSync(filename, binary ? undefined : 'utf8');
  return ret;
};
// end include: node_shell_read.js
  if (!Module['thisProgram'] && process.argv.length > 1) {
    thisProgram = process.argv[1].replace(/\\/g, '/');
  }

  arguments_ = process.argv.slice(2);

  if (typeof module != 'undefined') {
    module['exports'] = Module;
  }

  quit_ = (status, toThrow) => {
    process.exitCode = status;
    throw toThrow;
  };

} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document != 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),
  // they are removed because they could contain a slash.
  if (scriptDirectory.startsWith('blob:')) {
    scriptDirectory = '';
  } else {
    scriptDirectory = scriptDirectory.slice(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/')+1);
  }

  {
// include: web_or_worker_shell_read.js
if (ENVIRONMENT_IS_WORKER) {
    readBinary = (url) => {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.responseType = 'arraybuffer';
      xhr.send(null);
      return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
    };
  }

  readAsync = async (url) => {
    // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
    // See https://github.com/github/fetch/pull/92#issuecomment-140665932
    // Cordova or Electron apps are typically loaded from a file:// url.
    // So use XHR on webview if URL is a file URL.
    if (isFileURI(url)) {
      return new Promise((resolve, reject) => {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = () => {
          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
            resolve(xhr.response);
            return;
          }
          reject(xhr.status);
        };
        xhr.onerror = reject;
        xhr.send(null);
      });
    }
    var response = await fetch(url, { credentials: 'same-origin' });
    if (response.ok) {
      return response.arrayBuffer();
    }
    throw new Error(response.status + ' : ' + response.url);
  };
// end include: web_or_worker_shell_read.js
  }
} else
{
}

var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.error.bind(console);

// Merge back in the overrides
Object.assign(Module, moduleOverrides);
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];

if (Module['thisProgram']) thisProgram = Module['thisProgram'];

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// end include: shell.js

// include: preamble.js
// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary = Module['wasmBinary'];

// include: wasm2js.js
// wasm2js.js - enough of a polyfill for the WebAssembly object so that we can load
// wasm2js code that way.

// Emit "var WebAssembly" if definitely using wasm2js. Otherwise, in MAYBE_WASM2JS
// mode, we can't use a "var" since it would prevent normal wasm from working.
/** @suppress{duplicate, const} */
var
WebAssembly = {
  // Note that we do not use closure quoting (this['buffer'], etc.) on these
  // functions, as they are just meant for internal use. In other words, this is
  // not a fully general polyfill.
  /** @constructor */
  Memory: function(opts) {
    this.buffer = new ArrayBuffer(opts['initial'] * 65536);
  },

  Module: function(binary) {
    // TODO: use the binary and info somehow - right now the wasm2js output is embedded in
    // the main JS
  },

  /** @constructor */
  Instance: function(module, info) {
    // TODO: use the module somehow - right now the wasm2js output is embedded in
    // the main JS
    // This will be replaced by the actual wasm2js code.
    this.exports = (
function instantiate(info) {
function Table(ret) {
  ret.grow = function(by) {
    var old = this.length;
    this.length = this.length + by;
    return old;
  };
  ret.set = function(i, func) {
    this[i] = func;
  };
  ret.get = function(i) {
    return this[i];
  };
  return ret;
}

  var bufferView;
  var base64ReverseLookup = new Uint8Array(123/*'z'+1*/);
  for (var i = 25; i >= 0; --i) {
    base64ReverseLookup[48+i] = 52+i; // '0-9'
    base64ReverseLookup[65+i] = i; // 'A-Z'
    base64ReverseLookup[97+i] = 26+i; // 'a-z'
  }
  base64ReverseLookup[43] = 62; // '+'
  base64ReverseLookup[47] = 63; // '/'
  /** @noinline Inlining this function would mean expanding the base64 string 4x times in the source code, which Closure seems to be happy to do. */
  function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {
    var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength*3>>2) - (b64[bLength-2] == '=') - (b64[bLength-1] == '=');
    for (; i < bLength; i += 4) {
      b1 = base64ReverseLookup[b64.charCodeAt(i+1)];
      b2 = base64ReverseLookup[b64.charCodeAt(i+2)];
      uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
      if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;
      if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i+3)];
    }
    return uint8Array;
  }
function initActiveSegments(imports) {
  base64DecodeToExistingUint8Array(bufferView, 1025, "Bw4JHBsSFTg/NjEkIyotcHd+eWxrYmVIT0ZBVFNaXeDn7un8+/L12N/W0cTDys2Ql56ZjIuChaivpqG0s7q9x8DJztvc1dL/+PH24+Tt6rewub6rrKWij4iBhpOUnZonICkuOzw1Mh8YERYDBA0KV1BZXktMRUJvaGFmc3R9eomOh4CVkpucsba/uK2qo6T5/vfw5eLr7MHGz8jd2tPUaW5nYHVye3xRVl9YTUpDRBkeFxAFAgsMISYvKD06MzROSUBHUlVcW3ZxeH9qbWRjPjkwNyIlLCsGAQgPGh0UE66poKeytby7lpGYn4qNhIPe2dDXwsXMy+bh6O/6/fTzAAAFgA+ACgAbgB4AFAARgDOANgA8ADmAKAAtgCeAIgBjgGYAbABpgHgAfYB3gHIAUABVgF+AWgBLgE4ARABBgMOAxgDMAMmA2ADdgNeA0gDwAPWA/4D6AOuA7gDkAOGAoAClgK+AqgC7gL4AtACxgJOAlgCcAJmAiACNgIeAggCDgYYBjAGJgZgBnYGXgZIBsAG1gb+BugGrga4BpAGhgeAB5YHvgeoB+4H+AfQB8YHTgdYB3AHZgcgBzYHHgcIBQAFFgU+BSgFbgV4BVAFRgXOBdgF8AXmBaAFtgWeBYgEjgSYBLAEpgTgBPYE3gTIBEAEVgR+BGgELgQ4BBAEBgQODBgMMAwmDGAMdgxeDEgMwAzWDP4M6AyuDLgMkAyGDYANlg2+DagN7g34DdANxg1ODVgNcA1mDSANNg0eDQgPAA8WDz4PKA9uD3gPUA9GD84P2A/wD+YPoA+2D54PiA6ODpgOsA6mDuAO9g7eDsgOQA5WDn4OaA4uDjgOEA4GDgAKFgo+CigKbgp4ClAKRgrOCtgK8ArmCqAKtgqeCogLjguYC7ALpgvgC/YL3gvIC0ALVgt+C2gLLgs4CxALBgkOCRgJMAkmCWAJdgleCUgJwAnWCf4J6AmuCbgJkAmGCIAIlgi+CKgI7gj4CNAIxghOCFgIcAhmCCAINggeCAgIAAAOGA4wACgOYAB4AFAOSA7AANgA8A7oAKAOuA6QAIgPgAGYAbAPqAHgD/gP0AHIAUAPWA9wAWgPIAE4ARAPCA0AAxgDMA0oA2ANeA1QA0gDwA3YDfAD6A2gA7gDkA2IAoAMmAywAqgM4AL4AtAMyAxAAlgCcAxoAiAMOAwQAggaABQYFDAaKBRgGngaUBRIFMAa2BrwFOgaoBS4FJAaiBWAG5gbsBWoG+AV+BXQG8gbQBVYFXAbaBUgGzgbEBUIFwAZGBkwFygZYBd4F1AZSBnAF9gX8BnoF6AZuBmQF4gYgBaYFrAYqBbgGPgY0BbIFkAYWBhwFmgYIBY4FhAYCCYAKBgoMCYoKGAmeCZQKEgowCbYJvAo6CagKLgokCaIKYAnmCewKagn4Cn4KdAnyCdAKVgpcCdoKSAnOCcQKQgrACUYJTArKCVgK3grUCVIJcAr2CvwJegroCW4JZAriCSAKpgqsCSoKuAk+CTQKsgqQCRYJHAqaCQgKjgqECQIPAAyGDIwPCgyYDx4PFAySDLAPNg88DLoPKAyuDKQPIgzgD2YPbAzqD3gM/gz0D3IPUAzWDNwPWgzID04PRAzCDEAPxg/MDEoP2AxeDFQP0g/wDHYMfA/6DGgP7g/kDGIPoAwmDCwPqgw4D74PtAwyDBAPlg+cDBoPiAwODAQPggAAF4ArgDwAU4BEAHgAb4CjgLQAiACfgPAA54DbgMwAQ4FUAWgBf4EQAQeBO4EsAeAB94HLgdwBs4GkAZgBj4GDgpQCqAK/gtACx4L7guwCIAI3gguCHAJzgmQCWAJPgsAD14Prg/wDk4OEA7gDr4Njg3QDSANfgzADJ4MbgwwDA4UUBSgFP4VQBUeFe4VsBaAFt4WLhZwF84XkBdgFz4VABFeEa4R8BBOEBAQ4BC+E44T0BMgE34SwBKeEm4SMBIAHl4erh7wH04fEB/gH74cjhzQHCAcfh3AHZ4dbh0wHw4bUBugG/4aQBoeGu4asBmAGd4ZLhlwGM4YkBhgGD4YDihQKKAo/ilAKR4p7imwKoAq3iouKnArziuQK2ArPikALV4tri3wLE4sECzgLL4vji/QLyAvfi7ALp4ubi4wLgAiXiKuIvAjTiMQI+AjviCOINAgICB+IcAhniFuITAjDidQJ6An/iZAJh4m7iawJYAl3iUuJXAkziSQJGAkPiQAPF48rjzwPU49ED3gPb4+jj7QPiA+fj/AP54/bj8wPQ45UDmgOf44QDgeOO44sDuAO947LjtwOs46kDpgOj46DjZQNqA2/jdANx437jewNIA03jQuNHA1zjWQNWA1PjcAM14zrjPwMk4yEDLgMr4xjjHQMSAxfjDAMJ4wbjAwMAAADlAOoADwD0ABEAHgD7AMgALQAiAMcAPADZANYAMwGQAXUBegGfAWQBgQGOAWsBWAG9AbIBVwGsAUkBRgGjAyADxQPKAy8D1AMxAz4D2wPoAw0DAgPnAxwD+QP2AxMCsAJVAloCvwJEAqECrgJLAngCnQKSAncCjAJpAmYCgwdgB4UHigdvB5QHcQd+B5sHqAdNB0IHpwdcB7kHtgdTBvAGFQYaBv8GBAbhBu4GCwY4Bt0G0gY3BswGKQYmBsMEQASlBKoETwS0BFEEXgS7BIgEbQRiBIcEfASZBJYEcwXQBTUFOgXfBSQFwQXOBSsFGAX9BfIFFwXsBQkFBgXjD+APBQ8KD+8PFA/xD/4PGw8oD80Pwg8nD9wPOQ82D9MOcA6VDpoOfw6EDmEObg6LDrgOXQ5SDrcOTA6pDqYOQwzADCUMKgzPDDQM0QzeDDsMCAztDOIMBwz8DBkMFgzzDVANtQ26DV8NpA1BDU4Nqw2YDX0Ncg2XDWwNiQ2GDWMIgAhlCGoIjwh0CJEIngh7CEgIrQiiCEcIvAhZCFYIswkQCfUJ+gkfCeQJAQkOCesJ2Ak9CTIJ1wksCckJxgkjC6ALRQtKC68LVAuxC74LWwtoC40LggtnC5wLeQt2C5MKMArVCtoKPwrECiEKLgrLCvgKHQoSCvcKDArpCuYKAwAAHuA84CIAOOBmAEQAWuBw4O4AzADS4MgAluC04KoAoOH+AdwBwuHYAYbhpOG6AZABDuEs4TIBKOF2AVQBSuFA494D/APi4/gDpuOE45oDsAMu4wzjEgMI41YDdANq42ACPuIc4gICGOJGAmQCeuJQ4s4C7ALy4ugCtuKU4ooCgOeeB7wHoue4B+bnxOfaB/AHbudM51IHSOcWBzQHKucgBn7mXOZCBljmBgYkBjrmEOaOBqwGsuaoBvbm1ObKBsAEXuR85GIEeOQmBAQEGuQw5K4EjASS5IgE1uT05OoE4OW+BZwFguWYBcbl5OX6BdAFTuVs5XIFaOU2BRQFCuUA7x4PPA8i7zgPZu9E71oPcA/u78zv0g/I75YPtA+q76AO/u7c7sIO2O6GDqQOuu6Q7g4OLA4y7igOdu5U7koOQAze7Pzs4gz47KYMhAya7LDsLgwMDBLsCAxW7HTsagxg7T4NHA0C7RgNRu1k7XoNUA3O7ezt8g3o7bYNlA2K7YAInui86KIIuOjmCMQI2ujw6G4ITAhS6EgIFug06CoIIOl+CVwJQulYCQbpJOk6CRAJjums6bIJqOn2CdQJyunA614LfAti63gLJusE6xoLMAuu64zrkguI69YL9Avq6+AKvuqc6oIKmOrGCuQK+urQ6k4KbApy6mgKNuoU6goKAAAA/gDcACIBuAFGAWQBmgJQAq4CjAJyA+gDFgM0A8oEoAReBHwEggUYBeYFxAU6BvAGDgYsBtIHSAe2B5QHaghgCJ4IvAhCCdgJJgkECfoKMArOCuwKEguIC3YLVAuqDMAMPgwcDOINeA2GDaQNWg6QDm4OTA6yDygP1g/0DwoR4BEeETwRwhBYEKYQhBB6E7ATThNsE5ISCBL2EtQSKhVAFb4VnBViFPgUBhQkFNoXEBfuF8wXMhaoFlYWdBaKGYAZfhlcGaIYOBjGGOQYGhvQGy4bDBvyGmgalhq0GkodIB3eHfwdAhyYHGYcRBy6H3Afjh+sH1IeyB42HhQe6iLgIh4iPCLCI1gjpiOEI3ogsCBOIGwgkiEIIfYh1CEqJkAmviacJmIn+CcGJyQn2iQQJO4kzCQyJaglViV0JYoqgCp+Klwqois4K8Yr5CsaKNAoLigMKPIpaCmWKbQpSi4gLt4u/C4CL5gvZi9EL7oscCyOLKwsUi3ILTYtFC3qMwAz/jPcMyIyuDJGMmQymjFQMa4xjDFyMOgwFjA0MMo3oDdeN3w3gjYYNuY2xDY6NfA1DjUsNdI0SDS2NJQ0ajtgO547vDtCOtg6JjoEOvo5MDnOOew5EjiIOHY4VDiqP8A/Pj8cP+I+eD6GPqQ+Wj2QPW49TD2yPCg81jz0PAoAAATgSOCMANDhFAFYAZzh4OIkAmgCrOLwAzTjeOO8A8DkRAQIBMzkkAVU5Rjl3AWgBmTmKObsBrDndAc4B/zngOiECMgIDOhQCZTp2OkcCWAKpOro6iwKcOu0C/gLPOtADMTsiOxMDBDt1A2YDVztIO7kDqgObO4wD/TvuO98DwDxBBFIEYzx0BAU8FjwnBDgEyTzaPOsE/DyNBJ4ErzywBVE9Qj1zBWQ9FQUGBTc9KD3ZBcoF+z3sBZ09jj2/BaAGYT5yPkMGVD4lBjYGBz4YPukG+gbLPtwGrT6+Po8GkD9xB2IHUz9EBzU/Jj8XBwgH+T/qP9sHzD+9B64Hnz+AMIEIkgijMLQIxTDWMOcI+AgJMBowKwg8ME0IXghvMHAJkTGCMbMJpDHVCcYJ9zHoMRkJCgk7MSwJXTFOMX8JYAqhMrIygwqUMuUK9grHMtgyKQo6CgsyHAptMn4yTwpQM7ELoguTM4QL9TPmM9cLyAs5MyozGwsMM30LbgtfM0AMwTTSNOMM9DSFDJYMpzS4NEkMWgxrNHwMDTQeNC8MMDXRDcIN8zXkDZU1hjW3DagNWTVKNXsNbDUdDQ4NPzUgNuEO8g7DNtQOpTa2NocOmA5pNno2Sw5cNi0OPg4PNhAP8TfiN9MPxDe1D6YPlzeIN3kPag9bN0wPPTcuNx8PAAAAYQDCAKMBhAHlAUYBJwMIA2kDygOrAowC7QJOAi8GWAY5BpoG+wfcB70HHgd/BVAFMQWSBfME1AS1BBYEdwz4DJkMOgxbDXwNHQ2+Dd8P8A+RDzIPUw50DhUOtg7XCqAKwQpiCgMLJAtFC+YLhwmoCckJagkLCCwITQjuCI8JuBnZGXoZGxg8GF0Y/hifGrAa0RpyGhMbNBtVG/Yblx/gH4EfIh9DHmQeBR6mHscc6ByJHCocSx1sHQ0drh3PFUAVIRWCFeMUxBSlFAYUZxZIFikWihbrF8wXrRcOF28TGBN5E9oTuxKcEv0SXhI/EBAQcRDSELMRlBH1EVYRNxM4M1kz+jObMrwy3TJ+Mh8wMDBRMPIwkzG0MdUxdjEXNWA1ATWiNcM05DSFNCY0RzZoNgk2qjbLN+w3jTcuN08/wD+hPwI/Yz5EPiU+hj7nPMg8qTwKPGs9TD0tPY497zmYOfk5Wjk7OBw4fTjeOL86kDrxOlI6MzsUO3U71ju3OoAq4SpCKiMrBCtlK8YrpymIKekpSikrKAwobSjOKK8s2Cy5LBosey1cLT0tni3/L9AvsS8SL3MuVC41LpYu9yZ4JhkmuibbJ/wnnSc+J18lcCURJbIl0yT0JJUkNiRXICAgQSDiIIMhpCHFIWYhByMoI0kj6iOLIqwizSJuIg8mluZmluaXR5AGJhcnRsZXR0AGN1ZSBzaGVldCB0cmFjayBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGluZGV4IHBvaW50AGNvbm5lcwBDRC1EQSBjdWUgc2hlZXQgdHJhY2sgaW5kZXggb2Zmc2V0IG11c3QgYmUgZXZlbmx5IGRpdmlzaWJsZSBieSA1ODggc2FtcGxlcwBDRC1EQSBjdWUgc2hlZXQgbGVhZC1vdXQgb2Zmc2V0IG11c3QgYmUgZXZlbmx5IGRpdmlzaWJsZSBieSA1ODggc2FtcGxlcwBDRC1EQSBjdWUgc2hlZXQgdHJhY2sgb2Zmc2V0IG11c3QgYmUgZXZlbmx5IGRpdmlzaWJsZSBieSA1ODggc2FtcGxlcwBDRC1EQSBjdWUgc2hlZXQgbGVhZC1pbiBsZW5ndGggbXVzdCBiZSBldmVubHkgZGl2aXNpYmxlIGJ5IDU4OCBzYW1wbGVzAENELURBIGN1ZSBzaGVldCBtdXN0IGhhdmUgYSBsZWFkLWluIGxlbmd0aCBvZiBhdCBsZWFzdCAyIHNlY29uZHMAZmxhdHRvcABiYXJ0bGV0dF9oYW5uAG5hbgBibGFja21hbgBudXR0YWxsAGthaXNlcl9iZXNzZWwAd2VsY2gAaW1hZ2UvcG5nAGhhbW1pbmcAcmVjdGFuZ2xlAHRyaWFuZ2xlAGJsYWNrbWFuX2hhcnJpc180dGVybV85MmRiAEZMQUMALS0+AGRlc2NyaXB0aW9uIHN0cmluZyBtdXN0IGJlIHZhbGlkIFVURi04AHJlZmVyZW5jZSBsaWJGTEFDIDEuMy4zIDIwMTkwODA0AGN1ZSBzaGVldCB0cmFjayBpbmRleCBudW1iZXJzIG11c3QgaW5jcmVhc2UgYnkgMQBjdWUgc2hlZXQgdHJhY2sncyBmaXJzdCBpbmRleCBudW1iZXIgbXVzdCBiZSAwIG9yIDEAQ0QtREEgY3VlIHNoZWV0IHRyYWNrIG51bWJlciBtdXN0IGJlIDEtOTkgb3IgMTcwAGN1ZSBzaGVldCBtYXkgbm90IGhhdmUgYSB0cmFjayBudW1iZXIgMABjdWUgc2hlZXQgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSB0cmFjayAodGhlIGxlYWQtb3V0KQBNSU1FIHR5cGUgc3RyaW5nIG11c3QgY29udGFpbiBvbmx5IHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXJzICgweDIwLTB4N2UpAENELURBIGN1ZSBzaGVldCBtdXN0IGhhdmUgYSBsZWFkLW91dCB0cmFjayBudW1iZXIgMTcwICgweEFBKQB0dWtleSg1ZS0xKTtwYXJ0aWFsX3R1a2V5KDIpO3B1bmNob3V0X3R1a2V5KDMpAHR1a2V5KDVlLTEpO3BhcnRpYWxfdHVrZXkoMikAdHVrZXkoNWUtMSkAcHVuY2hvdXRfdHVrZXkoAHBhcnRpYWxfdHVrZXkoAGdhdXNzKABmTGFDAAAAQ2FMZiAAAAAQAAAAEAAAABgAAAAYAAAAFAAAAAMAAAAFAAAAJAAAACAAAABAAAAAQAAAABAAAABAAAAACAAAABgAAABAAAAACAAAAGAAAAABAAAAAQAAAG4AAAAIAAAAAAQAAEAAAAABAAAAFwgAAAgAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAAAEAAAAHAAAAGAAAAP4/AAAOAAAAAQAAAAEAAAAEAAAABAAAAAQAAAADAAAAAQAAAAgAAAAQAAAAAgAAAAQAAAAEAAAABQAAAAUAAAAPAAAAHwAAAAQAAAAFAAAAAQAAAAYAAAABAAAAAAAAAAIAAAAQAAAAQA==");
  base64DecodeToExistingUint8Array(bufferView, 6804, "tx3BBG47ggnZJkMN3HYEE2trxReyTYYaBVBHHrjtCCYP8Mki1taKL2HLSytkmww104bNMQqgjjy9vU84cNsRTMfG0Ege4JNFqf1SQaytFV8bsNRbwpaXVnWLVlLINhlqfyvYbqYNm2MREFpnFEAdeaNd3H16e59wzWZedOC2I5hXq+Kcjo2hkTmQYJU8wCeLi93mj1L7pYLl5mSGWFsrvu9G6ro2YKm3gX1os4QtL60zMO6p6hatpF0LbKCQbTLUJ3Dz0P5WsN1JS3HZTBs2x/sG98MiILTOlT11yiiAOvKfnfv2Rru4+/Gmef/09j7hQ+v/5ZrNvOgt0H3sd3CGNMBtRzAZSwQ9rlbFOasGgiccG0MjxT0ALnIgwSrPnY4SeIBPFqGmDBsWu80fE+uKAaT2SwV90AgIys3JDAerl3iwtlZ8aZAVcd6N1HXb3ZNrbMBSb7XmEWIC+9Bmv0afXghbXlrRfR1XZmDcU2Mwm03ULVpJDQsZRLoW2ECXxqWsINtkqPn9J6VO4OahS7Chv/ytYLsliyO2kpbisi8rrYqYNmyOQRAvg/YN7ofzXamZREBonZ1mK5Aqe+qU5x204FAAdeSJJjbpPjv37TtrsPOMdnH3VVAy+uJN8/5f8LzG6O19wjHLPs+G1v/Lg4a41TSbedHtvTrcWqD72O7gDGlZ/c1tgNuOYDfGT2Qylgh6hYvJflytinPrsEt3Vg0ET+EQxUs4NoZGjytHQop7AFw9ZsFY5ECCVVNdQ1GeOx0lKSbcIfAAnyxHHV4oQk0ZNvVQ2DIsdps/m2taOybWFQORy9QHSO2XCv/wVg76oBEQTb3QFJSbkxkjhlIdDlYv8blL7vVgba3413Bs/NIgK+JlPermvBup6wsGaO+2uyfXAabm09iApd5vnWTaas0jxN3Q4sAE9qHNs+tgyX6NPr3JkP+5ELa8tKerfbCi+zquFeb7qszAuKd73XmjxmA2m3F995+oW7SSH0Z1lhoWMoitC/OMdC2wgcMwcYWZkIpdLo1LWferCFRAtslQReaOTvL7T0or3QxHnMDNQyF9gnuWYEN/T0YAcvhbwXb9C4ZoShZHbJMwBGEkLcVl6UubEV5WWhWHcBkYMG3YHDU9nwKCIF4GWwYdC+wb3A9RppM35rtSMz+dET6IgNA6jdCXJDrNViDj6xUtVPbUKXkmqcXOO2jBFx0rzKAA6silUK3WEk1s0strL998du7bwcuh43bWYOev8CPqGO3i7h29pfCqoGT0c4Yn+cSb5v0J/biJvuB5jWfGOoDQ2/uE1Yu8mmKWfZ67sD6TDK3/l7EQsK8GDXGr3ysypmg286JtZrS82nt1uANdNrW0QPexfwAAABAAAABQQwAAAAAAAAA4+v5CLuY/MGfHk1fzLj0BAAAAAADgv1swUVVVVdU/kEXr////z78RAfEks5nJP5/IBuV1VcW/AAAAAAAA4L93VVVVVVXVP8v9/////8+/DN2VmZmZyT+nRWdVVVXFvzDeRKMkScI/ZT1CpP//v7/K1ioohHG8P/9osEPrmbm/hdCv94KBtz/NRdF1E1K1v5/e4MPwNPc/AJDmeX/M178f6SxqeBP3PwAADcLub9e/oLX6CGDy9j8A4FET4xPXv32MEx+m0fY/AHgoOFu41r/RtMULSbH2PwB4gJBVXda/ugwvM0eR9j8AABh20ALWvyNCIhifcfY/AJCQhsqo1b/ZHqWZT1L2PwBQA1ZDT9W/xCSPqlYz9j8AQGvDN/bUvxTcnWuzFPY/AFCo/aed1L9MXMZSZPb1PwCoiTmSRdS/TyyRtWfY9T8AuLA59O3Tv96QW8u8uvU/AHCPRM6W0794GtnyYZ31PwCgvRceQNO/h1ZGElaA9T8AgEbv4unSv9Nr586XY/U/AOAwOBuU0r+Tf6fiJUf1PwCI2ozFPtK/g0UGQv8q9T8AkCcp4enRv9+9stsiD/U/APhIK22V0b/X3jRHj/P0PwD4uZpnQdG/QCjez0PY9D8AmO+U0O3Qv8ijeMA+vfQ/ABDbGKWa0L+KJeDDf6L0PwC4Y1LmR9C/NITUJAWI9D8A8IZFIuvPvwstGRvObfQ/ALAXdUpHz79UGDnT2VP0PwAwED1EpM6/WoS0RCc69D8AsOlEDQLOv/v4FUG1IPQ/APB3KaJgzb+x9D7aggf0PwCQlQQBwMy/j/5XXY/u8z8AEIlWKSDMv+lMC6DZ1fM/ABCBjReBy78rwRDAYL3zPwDQ08zJ4sq/uNp1KySl8z8AkBIuQEXKvwLQn80ijfM/APAdaHeoyb8ceoTFW3XzPwAwSGltDMm/4jatSc5d8z8AwEWmIHHIv0DUTZh5RvM/ADAUtI/Wx78ky//OXC/zPwBwYjy4PMe/SQ2hdXcY8z8AYDebmqPGv5A5PjfIAfM/AKC3VDELxr9B+JW7TuvyPwAwJHZ9c8W/0akZAgrV8j8AMMKPe9zEvyr9t6j5vvI/AADSUSxGxL+rGwx6HKnyPwAAg7yKsMO/MLUUYHKT8j8AAElrmRvDv/WhV1f6ffI/AECkkFSHwr+/Ox2bs2jyPwCgefi588G/vfWPg51T8j8AoCwlyGDBvzsIyaq3PvI/ACD3V3/OwL+2QKkrASryPwCg/kncPMC/MkHMlnkV8j8AgEu8vVe/v5v80h0gAfI/AEBAlgg3vr8LSE1J9OzxPwBA+T6YF72/aWWPUvXY8T8AoNhOZ/m7v3x+VxEjxfE/AGAvIHncur/pJst0fLHxPwCAKOfDwLm/thosDAGe8T8AwHKzRqa4v71wtnuwivE/AACsswGNt7+2vO8linfxPwAAOEXxdLa/2jFMNY1k8T8AgIdtDl61v91fJ5C5UfE/AOCh3lxItL9M0jKkDj/xPwCgak3ZM7O/2vkQcoss8T8AYMX4eSCyvzG17CgwGvE/ACBimEYOsb+vNITa+wfxPwAA0mps+q+/s2tOD+718D8AQHdKjdqtv86fKl0G5PA/AACF5Oy8q78hpSxjRNLwPwDAEkCJoam/GpjifKfA8D8AwAIzWIinv9E2xoMvr/A/AIDWZ15xpb85E6CY253wPwCAZUmKXKO/3+dSr6uM8D8AQBVk40mhv/soTi+fe/A/AIDrgsBynr8ZjzWMtWrwPwCAUlLxVZq/LPnspe5Z8D8AgIHPYj2Wv5As0c1JSfA/AACqjPsokr+prfDGxjjwPwAA+SB7MYy/qTJ5E2Uo8D8AAKpdNRmEv0hz6ickGPA/AADswgMSeL+VsRQGBAjwPwAAJHkJBGC/Gvom9x/g7z8AAJCE8+9vP3TqYcIcoe8/AAA9NUHchz8umYGwEGPvPwCAwsSjzpM/za3uPPYl7z8AAIkUwZ+bP+cTkQPI6e4/AAARztiwoT+rsct4gK7uPwDAAdBbiqU/mwydohp07j8AgNhAg1ypP7WZCoOROu4/AIBX72onrT9WmmAJ4AHuPwDAmOWYdbA/mLt35QHK7T8AIA3j9VOyPwORfAvyku0/AAA4i90utD/OXPtmrFztPwDAV4dZBrY/nd5eqiwn7T8AAGo1dtq3P80saz5u8uw/AGAcTkOruT8Ceaeibb7sPwBgDbvHeLs/bQg3bSaL7D8AIOcyE0O9PwRYXb2UWOw/AGDecTEKvz+Mn7sztSbsPwBAkSsVZ8A/P+fs7oP16z8AsJKChUfBP8GW23X9xOs/ADDKzW4mwj8oSoYMHpXrPwBQxabXA8M/LD7vxeJl6z8AEDM8w9/DP4uIyWdIN+s/AIB6aza6xD9KMB0hSwnrPwDw0Sg5k8U/fu/yhejb6j8A8BgkzWrGP6I9YDEdr+o/AJBm7PhAxz+nWNM/5oLqPwDwGvXAFcg/i3MJ70BX6j8AgPZUKenIPydLq5AqLOo/AED4Aja7yT/R8pMToAHqPwAALBzti8o/GzzbJJ/X6T8A0AFcUVvLP5CxxwUlruk/AMC8zGcpzD8vzpfyLoXpPwBgSNU19sw/dUuk7rpc6T8AwEY0vcHNPzhI553GNOk/AODPuAGMzj/mUmcvTw3pPwCQF8AJVc8/ndf/jlLm6D8AuB8SbA7QP3wAzJ/Ov+g/ANCTDrhx0D8Ow77awJnoPwBwhp5r1NA/+xcjqid06D8A0EszhzbRPwias6wAT+g/AEgjZw2Y0T9VPmXoSSroPwCAzOD/+NE/YAL0lQEG6D8AaGPXX1nSPymj4GMl4uc/AKgUCTC50j+ttdx3s77nPwBgQxByGNM/wiWXZ6qb5z8AGOxtJnfTP1cGF/IHeec/ADCv+0/V0z8ME9bbylbnPwDgL+PuMtQ/a7ZPAQAQ5j88W0KRbAJ+PJW0TQMAMOY/QV0ASOq/jTx41JQNAFDmP7el1oanf448rW9OBwBw5j9MJVRr6vxhPK4P3/7/j+Y//Q5ZTCd+fLy8xWMHALDmPwHa3EhowYq89sFcHgDQ5j8Rk0mdHD+DPD72Bev/7+Y/Uy3iGgSAfryAl4YOABDnP1J5CXFm/3s8Euln/P8v5z8kh70m4gCMPGoRgd//T+c/0gHxbpECbryQnGcPAHDnP3ScVM1x/Ge8Nch++v+P5z+DBPWewb6BPObCIP7/r+c/ZWTMKRd+cLwAyT/t/8/nPxyLewhygIC8dhom6f/v5z+u+Z1tKMCNPOijnAQAEOg/M0zlUdJ/iTyPLJMXADDoP4HzMLbp/oq8nHMzBgBQ6D+8NWVrv7+JPMaJQiAAcOg/dXsR82W/i7wEefXr/4/oP1fLPaJuAIm83wS8IgCw6D8KS+A43wB9vIobDOX/z+g/BZ//RnEAiLxDjpH8/+/oPzhwetB7gYM8x1/6HgAQ6T8DtN92kT6JPLl7RhMAMOk/dgKYS06AfzxvB+7m/0/pPy5i/9nwfo+80RI83v9v6T+6OCaWqoJwvA2KRfT/j+k/76hkkRuAh7w+Lpjd/6/pPzeTWorgQIe8ZvtJ7f/P6T8A4JvBCM4/PFGc8SAA8Ok/CluIJ6o/irwGsEURABDqP1baWJlI/3Q8+va7BwAw6j8YbSuKq76MPHkdlxAAUOo/MHl43cr+iDxILvUdAHDqP9ur2D12QY+8UjNZHACQ6j8SdsKEAr+OvEs+TyoAsOo/Xz//PAT9abzRHq7X/8/qP7RwkBLnPoK8eARR7v/v6j+j3g7gPgZqPFsNZdv/D+s/uQofOMgGWjxXyqr+/y/rPx08I3QeAXm83LqV2f9P6z+fKoZoEP95vJxlniQAcOs/Pk+G0EX/ijxAFof5/4/rP/nDwpZ3/nw8T8sE0v+v6z/EK/LuJ/9jvEVcQdL/z+s/Ieo77rf/bLzfCWP4/+/rP1wLLpcDQYG8U3a14f8P7D8ZareUZMGLPONX+vH/L+w/7cYwje/+ZLwk5L/c/0/sP3VH7LxoP4S897lU7f9v7D/s4FPwo36EPNWPmev/j+w/8ZL5jQaDczyaISUhALDsPwQOGGSO/Wi8nEaU3f/P7D9y6sccvn6OPHbE/er/7+w//oifrTm+jjwr+JoWABDtP3FauaiRfXU8HfcPDQAw7T/ax3BpkMGJPMQPeer/T+0/DP5YxTcOWLzlh9wuAHDtP0QPwU3WgH+8qoLcIQCQ7T9cXP2Uj3x0vIMCa9j/r+0/fmEhxR1/jDw5R2wpANDtP1Ox/7KeAYg89ZBE5f/v7T+JzFLG0gBuPJT2q83/D+4/0mktIECDf7zdyFLb/y/uP2QIG8rBAHs87xZC8v9P7j9Rq5SwqP9yPBFeiuj/b+4/Wb7vsXP2V7wN/54RAJDuPwHIC16NgIS8RBel3/+v7j+1IEPVBgB4PKF/EhoA0O4/klxWYPgCULzEvLoHAPDuPxHmNV1EQIW8Ao169f8P7z8Fke85MftPvMeK5R4AMO8/VRFz8qyBijyUNIL1/0/vP0PH19RBP4o8a0yp/P9v7z91eJgc9AJivEHE+eH/j+8/S+d39NF9dzx+4+DS/6/vPzGjfJoZAW+8nuR3HADQ7z+xrM5L7oFxPDHD4Pf/7+8/WodwATcFbrxuYGX0/w/wP9oKHEmtfoq8WHqG8/8v8D/gsvzDaX+XvBcN/P3/T/A/W5TLNP6/lzyCTc0DAHDwP8tW5MCDAII86Mvy+f+P8D8adTe+3/9tvGXaDAEAsPA/6ybmrn8/kbw406QBANDwP/efSHn6fYA8/f3a+v/v8D/Aa9ZwBQR3vJb9ugsAEPE/YgtthNSAjjxd9OX6/y/xP+82/WT6v5082ZrVDQBQ8T+uUBJwdwCaPJpVIQ8AcPE/7t7j4vn9jTwmVCf8/4/xP3NyO9wwAJE8WTw9EgCw8T+IAQOAeX+ZPLeeKfj/z/E/Z4yfqzL5ZbwA1Ir0/+/xP+tbp52/f5M8pIaLDAAQ8j8iW/2Ra4CfPANDhQMAMPI/M7+f68L/kzyE9rz//0/yP3IuLn7nAXY82SEp9f9v8j9hDH92u/x/PDw6kxQAkPI/K0ECPMoCcrwTY1UUALDyPwIf8jOCgJK8O1L+6//P8j/y3E84fv+IvJatuAsA8PI/xUEwUFH/hbyv4nr7/w/zP50oXohxAIG8f1+s/v8v8z8Vt7c/Xf+RvFZnpgwAUPM/vYKLIoJ/lTwh9/sRAHDzP8zVDcS6AIA8uS9Z+f+P8z9Rp7ItnT+UvELS3QQAsPM/4Th2cGt/hTxXybL1/8/zPzESvxA6Ano8GLSw6v/v8z+wUrFmbX+YPPSvMhUAEPQ/JIUZXzf4Zzwpi0cXADD0P0NR3HLmAYM8Y7SV5/9P9D9aibK4af+JPOB1BOj/b/Q/VPLCm7HAlbznwW/v/4/0P3IqOvIJQJs8BKe+5f+v9D9FfQ2/t/+UvN4nEBcA0PQ/PWrccWTAmbziPvAPAPD0PxxThQuJf5c80UvcEgAQ9T82pGZxZQRgPHonBRYAMPU/CTIjzs6/lrxMcNvs/0/1P9ehBQVyAom8qVRf7/9v9T8SZMkO5r+bPBIQ5hcAkPU/kO+vgcV+iDySPskDALD1P8AMvwoIQZ+8vBlJHQDQ9T8pRyX7KoGYvIl6uOf/7/U/BGntgLd+lLw=");
  base64DecodeToExistingUint8Array(bufferView, 12100, "4EMAAAEAAAACAAAABAAAAAUAAAAGAAAAAAAAANF0ngBXnb0qgHBSD///PicKAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCAlpgAAOH1BRgAAAA1AAAAcQAAAGv////O+///kr///wAAAAAAAAAAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGA");
  base64DecodeToExistingUint8Array(bufferView, 14995, "QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNf6CK2VHFWdAAAAAAAAAOEMAAPr+Qi52vzo7nrya9wy9vf3/////3z88VFVVVVXFP5ErF89VVaU/F9CkZxERgT8AAAAAAADIQu85+v5CLuY/JMSC/72/zj+19AzXCGusP8xQRtKrsoM/hDpOm+DXVT8=");
  base64DecodeToExistingUint8Array(bufferView, 15182, "8D9uv4gaTzubPDUz+6k99u8/XdzYnBNgcbxhgHc+muzvP9FmhxB6XpC8hX9u6BXj7z8T9mc1UtKMPHSFFdOw2e8/+o75I4DOi7ze9t0pa9DvP2HI5mFO92A8yJt1GEXH7z+Z0zNb5KOQPIPzxso+vu8/bXuDXaaalzwPiflsWLXvP/zv/ZIatY4890dyK5Ks7z/RnC9wPb4+PKLR0zLso+8/C26QiTQDarwb0/6vZpvvPw69LypSVpW8UVsS0AGT7z9V6k6M74BQvMwxbMC9iu8/FvTVuSPJkbzgLamumoLvP69VXOnj04A8UY6lyJh67z9Ik6XqFRuAvHtRfTy4cu8/PTLeVfAfj7zqjYw4+WrvP79TEz+MiYs8dctv61tj7z8m6xF2nNmWvNRcBITgW+8/YC86PvfsmjyquWgxh1TvP504hsuC54+8Hdn8IlBN7z+Nw6ZEQW+KPNaMYog7Ru8/fQTksAV6gDyW3H2RST/vP5SoqOP9jpY8OGJ1bno47z99SHTyGF6HPD+msk/OMe8/8ucfmCtHgDzdfOJlRSvvP14IcT97uJa8gWP14d8k7z8xqwlt4feCPOHeH/WdHu8/+r9vGpshPbyQ2drQfxjvP7QKDHKCN4s8CwPkpoUS7z+Py86JkhRuPFYvPqmvDO8/tquwTXVNgzwVtzEK/gbvP0x0rOIBQoY8MdhM/HAB7z9K+NNdOd2PPP8WZLII/O4/BFuOO4Cjhrzxn5JfxfbuP2hQS8ztSpK8y6k6N6fx7j+OLVEb+AeZvGbYBW2u7O4/0jaUPujRcbz3n+U02+fuPxUbzrMZGZm85agTwy3j7j9tTCqnSJ+FPCI0Ekym3u4/imkoemASk7wcgKwERdruP1uJF0iPp1i8Ki73IQrW7j8bmklnmyx8vJeoUNn10e4/EazCYO1jQzwtiWFgCM7uP+9kBjsJZpY8VwAd7UHK7j95A6Ha4cxuPNA8wbWixu4/MBIPP47/kzze09fwKsPuP7CvervOkHY8Jyo21dq/7j934FTrvR2TPA3d/ZmyvO4/jqNxADSUj7ynLJ12srnuP0mjk9zM3oe8QmbPotq27j9fOA+9xt54vIJPnVYrtO4/9lx77EYShrwPkl3KpLHuP47X/RgFNZM82ie1Nkev7j8Fm4ovt5h7PP3Hl9QSre4/CVQc4uFjkDwpVEjdB6vuP+rGGVCFxzQ8t0ZZiiap7j81wGQr5jKUPEghrRVvp+4/n3aZYUrkjLwJ3Ha54aXuP6hN7zvFM4y8hVU6sH6k7j+u6SuJeFOEvCDDzDRGo+4/WFhWeN3Ok7wlIlWCOKLuP2QZfoCqEFc8c6lM1FWh7j8oIl6/77OTvM07f2aeoO4/grk0h60Sary/2gt1EqDuP+6pbbjvZ2O8LxplPLKf7j9RiOBUPdyAvISUUfl9n+4/zz5afmQfeLx0X+zodZ/uP7B9i8BK7oa8dIGlSJqf7j+K5lUeMhmGvMlnQlbrn+4/09QJXsuckDw/Xd5PaaDuPx2lTbncMnu8hwHrcxSh7j9rwGdU/eyUPDLBMAHtoe4/VWzWq+HrZTxiTs8286LuP0LPsy/FoYi8Eho+VCek7j80NzvxtmmTvBPOTJmJpe4/Hv8ZOoRegLytxyNGGqfuP25XcthQ1JS87ZJEm9mo7j8Aig5bZ62QPJlmitnHqu4/tOrwwS+3jTzboCpC5azuP//nxZxgtmW8jES1FjKv7j9EX/NZg/Z7PDZ3FZmuse4/gz0epx8Jk7zG/5ELW7TuPykebIu4qV285cXNsDe37j9ZuZB8+SNsvA9SyMtEuu4/qvn0IkNDkrxQTt6fgr3uP0uOZtdsyoW8ugfKcPHA7j8nzpEr/K9xPJDwo4KRxO4/u3MK4TXSbTwjI+MZY8juP2MiYiIExYe8ZeVde2bM7j/VMeLjhhyLPDMtSuyb0O4/Fbu809G7kbxdJT6yA9XuP9Ix7pwxzJA8WLMwE57Z7j+zWnNuhGmEPL/9eVVr3u4/tJ2Ol83fgrx689O/a+PuP4czy5J3Gow8rdNamZ/o7j/62dFKj3uQvGa2jSkH7u4/uq7cVtnDVbz7FU+4ovPuP0D2pj0OpJC8OlnljXL57j80k6049NZovEde+/J2/+4/NYpYa+LukbxKBqEwsAXvP83dXwrX/3Q80sFLkB4M7z+smJL6+72RvAke11vCEu8/swyvMK5uczycUoXdmxnvP5T9n1wy4448etD/X6sg7z+sWQnRj+CEPEvRVy7xJ+8/ZxpOOK/NYzy15waUbS/vP2gZkmwsa2c8aZDv3CA37z/StcyDGIqAvPrDXVULP+8/b/r/P12tj7x8iQdKLUfvP0mpdTiuDZC88okNCIdP7z+nBz2mhaN0PIek+9wYWO8/DyJAIJ6RgryYg8kW42DvP6ySwdVQWo48hTLbA+Zp7z9LawGsWTqEPGC0AfMhc+8/Hz60ByHVgrxfm3szl3zvP8kNRzu5Kom8KaH1FEaG7z/TiDpgBLZ0PPY/i+cukO8/cXKdUezFgzyDTMf7UZrvP/CR048S94+82pCkoq+k7z99dCPimK6NvPFnji1Ir+8/CCCqQbzDjjwnWmHuG7rvPzLrqcOUK4Q8l7prNyvF7z/uhdExqWSKPEBFblt20O8/7eM75Lo3jrwUvpyt/dvvP53NkU07iXc82JCegcHn7z+JzGBBwQVTPPFxjyvC8+8/");
  base64DecodeToExistingUint8Array(bufferView, 17216, "MFABAFsXAAArFwAAAAAAAAk=");
  base64DecodeToExistingUint8Array(bufferView, 17244, "Aw==");
  base64DecodeToExistingUint8Array(bufferView, 17264, "BAAAAAAAAAAFAAAAGEgAAAAE");
  base64DecodeToExistingUint8Array(bufferView, 17308, "/////w==");
  base64DecodeToExistingUint8Array(bufferView, 17376, "BQ==");
  base64DecodeToExistingUint8Array(bufferView, 17388, "Cg==");
  base64DecodeToExistingUint8Array(bufferView, 17412, "CwAAAAwAAAAoTAAAAAQ=");
  base64DecodeToExistingUint8Array(bufferView, 17436, "AQ==");
  base64DecodeToExistingUint8Array(bufferView, 17452, "/////wo=");
  base64DecodeToExistingUint8Array(bufferView, 17520, "4EM=");
  base64DecodeToExistingUint8Array(bufferView, 17568, "AwAAAAAAAABDGQAAAQAAAAE=");
  base64DecodeToExistingUint8Array(bufferView, 17612, "AwAAAAAAAABDGQAAAQ==");
  base64DecodeToExistingUint8Array(bufferView, 17656, "AwAAAAAAAABDGQ==");
  base64DecodeToExistingUint8Array(bufferView, 17676, "Bg==");
  base64DecodeToExistingUint8Array(bufferView, 17700, "BAAAAAAAAABDGQAAAQAAAAEAAAAI");
  base64DecodeToExistingUint8Array(bufferView, 17744, "BAAAAAAAAABDGQAAAQAAAAAAAAAI");
  base64DecodeToExistingUint8Array(bufferView, 17788, "BQAAAAAAAABDGQAAAQAAAAAAAAAI");
  base64DecodeToExistingUint8Array(bufferView, 17832, "BgAAAAAAAAAmGQAAAQAAAAAAAAAM");
  base64DecodeToExistingUint8Array(bufferView, 17876, "BgAAAAAAAAAmGQAAAQAAAAAAAAAM");
  base64DecodeToExistingUint8Array(bufferView, 17920, "BgAAAAAAAAD3GA==");
}

  var scratchBuffer = new ArrayBuffer(16);
  var i32ScratchView = new Int32Array(scratchBuffer);
  var f32ScratchView = new Float32Array(scratchBuffer);
  var f64ScratchView = new Float64Array(scratchBuffer);
  
  function wasm2js_scratch_load_i32(index) {
    return i32ScratchView[index];
  }
      
  function wasm2js_scratch_store_i32(index, value) {
    i32ScratchView[index] = value;
  }
      
  function wasm2js_scratch_load_f64() {
    return f64ScratchView[0];
  }
      
  function wasm2js_scratch_store_f64(value) {
    f64ScratchView[0] = value;
  }
      
  function wasm2js_memory_copy(dest, source, size) {
    // TODO: traps on invalid things
    bufferView.copyWithin(dest, source, source + size);
  }
      
  function wasm2js_memory_fill(dest, value, size) {
    dest = dest >>> 0;
    size = size >>> 0;
    if (dest + size > bufferView.length) throw "trap: invalid memory.fill";
    bufferView.fill(value, dest, dest + size);
  }
      
  function wasm2js_scratch_store_f32(value) {
    f32ScratchView[2] = value;
  }
      
function asmFunc(imports) {
 var buffer = new ArrayBuffer(16908288);
 var HEAP8 = new Int8Array(buffer);
 var HEAP16 = new Int16Array(buffer);
 var HEAP32 = new Int32Array(buffer);
 var HEAPU8 = new Uint8Array(buffer);
 var HEAPU16 = new Uint16Array(buffer);
 var HEAPU32 = new Uint32Array(buffer);
 var HEAPF32 = new Float32Array(buffer);
 var HEAPF64 = new Float64Array(buffer);
 var Math_imul = Math.imul;
 var Math_fround = Math.fround;
 var Math_abs = Math.abs;
 var Math_clz32 = Math.clz32;
 var Math_min = Math.min;
 var Math_max = Math.max;
 var Math_floor = Math.floor;
 var Math_ceil = Math.ceil;
 var Math_trunc = Math.trunc;
 var Math_sqrt = Math.sqrt;
 var env = imports.env;
 var emscripten_resize_heap = env.emscripten_resize_heap;
 var wasi_snapshot_preview1 = imports.wasi_snapshot_preview1;
 var __wasi_fd_close = wasi_snapshot_preview1.fd_close;
 var __wasi_fd_read = wasi_snapshot_preview1.fd_read;
 var __wasi_fd_write = wasi_snapshot_preview1.fd_write;
 var legalimport$__wasi_fd_seek = wasi_snapshot_preview1.fd_seek;
 var __stack_pointer = 86064;
 var __wasm_intrinsics_temp_i64 = 0;
 var __wasm_intrinsics_temp_i64$hi = 0;
 var i64toi32_i32$HIGH_BITS = 0;
 // EMSCRIPTEN_START_FUNCS
;
 function __wasm_call_ctors() {
  
 }
 
 function sbrk($0) {
  var $1 = 0, $2 = 0;
  $1 = HEAP32[4304];
  $2 = $0 + 7 & -8;
  $0 = $1 + $2 | 0;
  block2 : {
   if (!(!!$2 & $0 >>> 0 <= $1 >>> 0)) {
    if ($0 >>> 0 <= __wasm_memory_size() << 16 >>> 0) {
     break block2
    }
    if (emscripten_resize_heap($0 | 0) | 0) {
     break block2
    }
   }
   HEAP32[4484] = 48;
   return -1;
  }
  HEAP32[4304] = $0;
  return $1;
 }
 
 function __memcpy($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ($2 >>> 0 >= 512) {
   if ($2) {
    wasm2js_memory_copy($0, $1, $2)
   }
   return;
  }
  $3 = $0 + $2 | 0;
  block6 : {
   if (!(($0 ^ $1) & 3)) {
    block3 : {
     if (!($0 & 3)) {
      $2 = $0;
      break block3;
     }
     if (!$2) {
      $2 = $0;
      break block3;
     }
     $2 = $0;
     while (1) {
      HEAP8[$2 | 0] = HEAPU8[$1 | 0];
      $1 = $1 + 1 | 0;
      $2 = $2 + 1 | 0;
      if (!($2 & 3)) {
       break block3
      }
      if ($2 >>> 0 < $3 >>> 0) {
       continue
      }
      break;
     };
    }
    $0 = $3 & -4;
    block5 : {
     if ($3 >>> 0 < 64) {
      break block5
     }
     $4 = $0 + -64 | 0;
     if ($4 >>> 0 < $2 >>> 0) {
      break block5
     }
     while (1) {
      HEAP32[$2 >> 2] = HEAP32[$1 >> 2];
      HEAP32[$2 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
      HEAP32[$2 + 8 >> 2] = HEAP32[$1 + 8 >> 2];
      HEAP32[$2 + 12 >> 2] = HEAP32[$1 + 12 >> 2];
      HEAP32[$2 + 16 >> 2] = HEAP32[$1 + 16 >> 2];
      HEAP32[$2 + 20 >> 2] = HEAP32[$1 + 20 >> 2];
      HEAP32[$2 + 24 >> 2] = HEAP32[$1 + 24 >> 2];
      HEAP32[$2 + 28 >> 2] = HEAP32[$1 + 28 >> 2];
      HEAP32[$2 + 32 >> 2] = HEAP32[$1 + 32 >> 2];
      HEAP32[$2 + 36 >> 2] = HEAP32[$1 + 36 >> 2];
      HEAP32[$2 + 40 >> 2] = HEAP32[$1 + 40 >> 2];
      HEAP32[$2 + 44 >> 2] = HEAP32[$1 + 44 >> 2];
      HEAP32[$2 + 48 >> 2] = HEAP32[$1 + 48 >> 2];
      HEAP32[$2 + 52 >> 2] = HEAP32[$1 + 52 >> 2];
      HEAP32[$2 + 56 >> 2] = HEAP32[$1 + 56 >> 2];
      HEAP32[$2 + 60 >> 2] = HEAP32[$1 + 60 >> 2];
      $1 = $1 - -64 | 0;
      $2 = $2 - -64 | 0;
      if ($4 >>> 0 >= $2 >>> 0) {
       continue
      }
      break;
     };
    }
    if ($0 >>> 0 <= $2 >>> 0) {
     break block6
    }
    while (1) {
     HEAP32[$2 >> 2] = HEAP32[$1 >> 2];
     $1 = $1 + 4 | 0;
     $2 = $2 + 4 | 0;
     if ($0 >>> 0 > $2 >>> 0) {
      continue
     }
     break;
    };
    break block6;
   }
   if ($3 >>> 0 < 4) {
    $2 = $0;
    break block6;
   }
   $4 = $3 - 4 | 0;
   if ($0 >>> 0 > $4 >>> 0) {
    $2 = $0;
    break block6;
   }
   $2 = $0;
   while (1) {
    HEAP8[$2 | 0] = HEAPU8[$1 | 0];
    HEAP8[$2 + 1 | 0] = HEAPU8[$1 + 1 | 0];
    HEAP8[$2 + 2 | 0] = HEAPU8[$1 + 2 | 0];
    HEAP8[$2 + 3 | 0] = HEAPU8[$1 + 3 | 0];
    $1 = $1 + 4 | 0;
    $2 = $2 + 4 | 0;
    if ($4 >>> 0 >= $2 >>> 0) {
     continue
    }
    break;
   };
  }
  if ($2 >>> 0 < $3 >>> 0) {
   while (1) {
    HEAP8[$2 | 0] = HEAPU8[$1 | 0];
    $1 = $1 + 1 | 0;
    $2 = $2 + 1 | 0;
    if (($3 | 0) != ($2 | 0)) {
     continue
    }
    break;
   }
  }
 }
 
 function emscripten_builtin_malloc($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
  $10 = __stack_pointer - 16 | 0;
  __stack_pointer = $10;
  block4 : {
   block15 : {
    block28 : {
     block61 : {
      block50 : {
       block57 : {
        block54 : {
         block31 : {
          block18 : {
           block5 : {
            if ($0 >>> 0 <= 244) {
             $4 = HEAP32[4485];
             $7 = $0 >>> 0 < 11 ? 16 : $0 + 11 & 504;
             $0 = $7 >>> 3 | 0;
             $1 = $4 >>> $0 | 0;
             if ($1 & 3) {
              $2 = $0 + (($1 ^ -1) & 1) | 0;
              $1 = $2 << 3;
              $0 = $1 + 17980 | 0;
              $1 = HEAP32[$1 + 17988 >> 2];
              $3 = HEAP32[$1 + 8 >> 2];
              block3 : {
               if (($0 | 0) == ($3 | 0)) {
                (wasm2js_i32$0 = 17940, wasm2js_i32$1 = __wasm_rotl_i32(-2, $2) & $4), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
                break block3;
               }
               HEAP32[$3 + 12 >> 2] = $0;
               HEAP32[$0 + 8 >> 2] = $3;
              }
              $0 = $1 + 8 | 0;
              $2 = $2 << 3;
              HEAP32[$1 + 4 >> 2] = $2 | 3;
              $1 = $1 + $2 | 0;
              HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 1;
              break block4;
             }
             $8 = HEAP32[4487];
             if ($8 >>> 0 >= $7 >>> 0) {
              break block5
             }
             if ($1) {
              $2 = 2 << $0;
              $1 = __wasm_ctz_i32((0 - $2 | $2) & $1 << $0);
              $0 = $1 << 3;
              $2 = $0 + 17980 | 0;
              $0 = HEAP32[$0 + 17988 >> 2];
              $3 = HEAP32[$0 + 8 >> 2];
              block8 : {
               if (($2 | 0) == ($3 | 0)) {
                $4 = __wasm_rotl_i32(-2, $1) & $4;
                HEAP32[4485] = $4;
                break block8;
               }
               HEAP32[$3 + 12 >> 2] = $2;
               HEAP32[$2 + 8 >> 2] = $3;
              }
              HEAP32[$0 + 4 >> 2] = $7 | 3;
              $6 = $0 + $7 | 0;
              $1 = $1 << 3;
              $3 = $1 - $7 | 0;
              HEAP32[$6 + 4 >> 2] = $3 | 1;
              HEAP32[$0 + $1 >> 2] = $3;
              if ($8) {
               $1 = ($8 & -8) + 17980 | 0;
               $2 = HEAP32[4490];
               $5 = 1 << ($8 >>> 3);
               block11 : {
                if (!($5 & $4)) {
                 HEAP32[4485] = $5 | $4;
                 $5 = $1;
                 break block11;
                }
                $5 = HEAP32[$1 + 8 >> 2];
               }
               HEAP32[$1 + 8 >> 2] = $2;
               HEAP32[$5 + 12 >> 2] = $2;
               HEAP32[$2 + 12 >> 2] = $1;
               HEAP32[$2 + 8 >> 2] = $5;
              }
              $0 = $0 + 8 | 0;
              HEAP32[4490] = $6;
              HEAP32[4487] = $3;
              break block4;
             }
             $11 = HEAP32[4486];
             if (!$11) {
              break block5
             }
             $2 = HEAP32[(__wasm_ctz_i32($11) << 2) + 18244 >> 2];
             $5 = (HEAP32[$2 + 4 >> 2] & -8) - $7 | 0;
             $1 = $2;
             while (1) {
              block13 : {
               $0 = HEAP32[$1 + 16 >> 2];
               if (!$0) {
                $0 = HEAP32[$1 + 20 >> 2];
                if (!$0) {
                 break block13
                }
               }
               $3 = (HEAP32[$0 + 4 >> 2] & -8) - $7 | 0;
               $1 = $3 >>> 0 < $5 >>> 0;
               $5 = $1 ? $3 : $5;
               $2 = $1 ? $0 : $2;
               $1 = $0;
               continue;
              }
              break;
             };
             $9 = HEAP32[$2 + 24 >> 2];
             $0 = HEAP32[$2 + 12 >> 2];
             if (($0 | 0) != ($2 | 0)) {
              $1 = HEAP32[$2 + 8 >> 2];
              HEAP32[$1 + 12 >> 2] = $0;
              HEAP32[$0 + 8 >> 2] = $1;
              break block15;
             }
             $1 = HEAP32[$2 + 20 >> 2];
             if ($1) {
              $3 = $2 + 20 | 0
             } else {
              $1 = HEAP32[$2 + 16 >> 2];
              if (!$1) {
               break block18
              }
              $3 = $2 + 16 | 0;
             }
             while (1) {
              $6 = $3;
              $0 = $1;
              $3 = $0 + 20 | 0;
              $1 = HEAP32[$0 + 20 >> 2];
              if ($1) {
               continue
              }
              $3 = $0 + 16 | 0;
              $1 = HEAP32[$0 + 16 >> 2];
              if ($1) {
               continue
              }
              break;
             };
             HEAP32[$6 >> 2] = 0;
             break block15;
            }
            $7 = -1;
            if ($0 >>> 0 > 4294967231) {
             break block5
            }
            $1 = $0 + 11 | 0;
            $7 = $1 & -8;
            $6 = HEAP32[4486];
            if (!$6) {
             break block5
            }
            $8 = 31;
            $5 = 0 - $7 | 0;
            if ($0 >>> 0 <= 16777204) {
             $0 = Math_clz32($1 >>> 8 | 0);
             $8 = (($7 >>> 38 - $0 & 1) - ($0 << 1) | 0) + 62 | 0;
            }
            $1 = HEAP32[($8 << 2) + 18244 >> 2];
            block25 : {
             block23 : {
              block21 : {
               if (!$1) {
                $0 = 0;
                break block21;
               }
               $0 = 0;
               $2 = $7 << (($8 | 0) != 31 ? 25 - ($8 >>> 1 | 0) | 0 : 0);
               while (1) {
                block22 : {
                 $4 = (HEAP32[$1 + 4 >> 2] & -8) - $7 | 0;
                 if ($4 >>> 0 >= $5 >>> 0) {
                  break block22
                 }
                 $3 = $1;
                 $5 = $4;
                 if ($5) {
                  break block22
                 }
                 $5 = 0;
                 $0 = $1;
                 break block23;
                }
                $4 = HEAP32[$1 + 20 >> 2];
                $1 = HEAP32[(($2 >>> 29 & 4) + $1 | 0) + 16 >> 2];
                $0 = $4 ? (($1 | 0) == ($4 | 0) ? $0 : $4) : $0;
                $2 = $2 << 1;
                if ($1) {
                 continue
                }
                break;
               };
              }
              if (!($0 | $3)) {
               $3 = 0;
               $0 = 2 << $8;
               $0 = (0 - $0 | $0) & $6;
               if (!$0) {
                break block5
               }
               $0 = HEAP32[(__wasm_ctz_i32($0) << 2) + 18244 >> 2];
              }
              if (!$0) {
               break block25
              }
             }
             while (1) {
              $2 = (HEAP32[$0 + 4 >> 2] & -8) - $7 | 0;
              $1 = $2 >>> 0 < $5 >>> 0;
              $5 = $1 ? $2 : $5;
              $3 = $1 ? $0 : $3;
              $1 = HEAP32[$0 + 16 >> 2];
              if ($1) {
               $0 = $1
              } else {
               $0 = HEAP32[$0 + 20 >> 2]
              }
              if ($0) {
               continue
              }
              break;
             };
            }
            if (!$3 | HEAP32[4487] - $7 >>> 0 <= $5 >>> 0) {
             break block5
            }
            $8 = HEAP32[$3 + 24 >> 2];
            $0 = HEAP32[$3 + 12 >> 2];
            if (($0 | 0) != ($3 | 0)) {
             $1 = HEAP32[$3 + 8 >> 2];
             HEAP32[$1 + 12 >> 2] = $0;
             HEAP32[$0 + 8 >> 2] = $1;
             break block28;
            }
            $1 = HEAP32[$3 + 20 >> 2];
            if ($1) {
             $2 = $3 + 20 | 0
            } else {
             $1 = HEAP32[$3 + 16 >> 2];
             if (!$1) {
              break block31
             }
             $2 = $3 + 16 | 0;
            }
            while (1) {
             $4 = $2;
             $0 = $1;
             $2 = $0 + 20 | 0;
             $1 = HEAP32[$0 + 20 >> 2];
             if ($1) {
              continue
             }
             $2 = $0 + 16 | 0;
             $1 = HEAP32[$0 + 16 >> 2];
             if ($1) {
              continue
             }
             break;
            };
            HEAP32[$4 >> 2] = 0;
            break block28;
           }
           $3 = HEAP32[4487];
           if ($7 >>> 0 <= $3 >>> 0) {
            $0 = HEAP32[4490];
            $1 = $3 - $7 | 0;
            block34 : {
             if ($1 >>> 0 >= 16) {
              $2 = $0 + $7 | 0;
              HEAP32[$2 + 4 >> 2] = $1 | 1;
              HEAP32[$0 + $3 >> 2] = $1;
              HEAP32[$0 + 4 >> 2] = $7 | 3;
              break block34;
             }
             HEAP32[$0 + 4 >> 2] = $3 | 3;
             $1 = $0 + $3 | 0;
             HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 1;
             $2 = 0;
             $1 = 0;
            }
            HEAP32[4487] = $1;
            HEAP32[4490] = $2;
            $0 = $0 + 8 | 0;
            break block4;
           }
           $2 = HEAP32[4488];
           if ($7 >>> 0 < $2 >>> 0) {
            $1 = $2 - $7 | 0;
            HEAP32[4488] = $1;
            $0 = HEAP32[4491];
            $2 = $0 + $7 | 0;
            HEAP32[4491] = $2;
            HEAP32[$2 + 4 >> 2] = $1 | 1;
            HEAP32[$0 + 4 >> 2] = $7 | 3;
            $0 = $0 + 8 | 0;
            break block4;
           }
           $0 = 0;
           if (HEAP32[4603]) {
            $1 = HEAP32[4605]
           } else {
            HEAP32[4606] = -1;
            HEAP32[4607] = -1;
            HEAP32[4604] = 4096;
            HEAP32[4605] = 4096;
            HEAP32[4603] = $10 + 12 & -16 ^ 1431655768;
            HEAP32[4608] = 0;
            HEAP32[4596] = 0;
            $1 = 4096;
           }
           $5 = $7 + 47 | 0;
           $4 = $1 + $5 | 0;
           $6 = 0 - $1 | 0;
           $1 = $4 & $6;
           if ($1 >>> 0 <= $7 >>> 0) {
            break block4
           }
           $3 = HEAP32[4595];
           if ($3) {
            $9 = $3;
            $3 = HEAP32[4593];
            $8 = $3 + $1 | 0;
            if ($9 >>> 0 < $8 >>> 0 | $3 >>> 0 >= $8 >>> 0) {
             break block4
            }
           }
           block47 : {
            if (!(HEAPU8[18384] & 4)) {
             block43 : {
              block48 : {
               block46 : {
                block42 : {
                 $3 = HEAP32[4491];
                 if ($3) {
                  $0 = 18388;
                  while (1) {
                   $8 = HEAP32[$0 >> 2];
                   if ($3 >>> 0 >= $8 >>> 0 & $3 >>> 0 < $8 + HEAP32[$0 + 4 >> 2] >>> 0) {
                    break block42
                   }
                   $0 = HEAP32[$0 + 8 >> 2];
                   if ($0) {
                    continue
                   }
                   break;
                  };
                 }
                 $2 = sbrk(0);
                 if (($2 | 0) == -1) {
                  break block43
                 }
                 $4 = $1;
                 $0 = HEAP32[4604];
                 $3 = $0 - 1 | 0;
                 if ($3 & $2) {
                  $4 = ($1 - $2 | 0) + ($2 + $3 & 0 - $0) | 0
                 }
                 if ($4 >>> 0 <= $7 >>> 0) {
                  break block43
                 }
                 $0 = HEAP32[4595];
                 if ($0) {
                  $6 = $0;
                  $0 = HEAP32[4593];
                  $3 = $0 + $4 | 0;
                  if ($6 >>> 0 < $3 >>> 0 | $0 >>> 0 >= $3 >>> 0) {
                   break block43
                  }
                 }
                 $0 = sbrk($4);
                 if (($2 | 0) != ($0 | 0)) {
                  break block46
                 }
                 break block47;
                }
                $4 = $6 & $4 - $2;
                $2 = sbrk($4);
                if (($2 | 0) == (HEAP32[$0 >> 2] + HEAP32[$0 + 4 >> 2] | 0)) {
                 break block48
                }
                $0 = $2;
               }
               if (($0 | 0) == -1) {
                break block43
               }
               if ($4 >>> 0 >= $7 + 48 >>> 0) {
                $2 = $0;
                break block47;
               }
               $2 = HEAP32[4605];
               $2 = $2 + ($5 - $4 | 0) & 0 - $2;
               if ((sbrk($2) | 0) == -1) {
                break block43
               }
               $4 = $2 + $4 | 0;
               $2 = $0;
               break block47;
              }
              if (($2 | 0) != -1) {
               break block47
              }
             }
             HEAP32[4596] = HEAP32[4596] | 4;
            }
            $2 = sbrk($1);
            $0 = sbrk(0);
            if (($2 | 0) == -1 | ($0 | 0) == -1 | $0 >>> 0 <= $2 >>> 0) {
             break block50
            }
            $4 = $0 - $2 | 0;
            if ($4 >>> 0 <= $7 + 40 >>> 0) {
             break block50
            }
           }
           $0 = HEAP32[4593] + $4 | 0;
           HEAP32[4593] = $0;
           if (HEAPU32[4594] < $0 >>> 0) {
            HEAP32[4594] = $0
           }
           block53 : {
            $5 = HEAP32[4491];
            if ($5) {
             $0 = 18388;
             while (1) {
              $1 = HEAP32[$0 >> 2];
              $3 = HEAP32[$0 + 4 >> 2];
              if (($1 + $3 | 0) == ($2 | 0)) {
               break block53
              }
              $0 = HEAP32[$0 + 8 >> 2];
              if ($0) {
               continue
              }
              break;
             };
             break block54;
            }
            $0 = HEAP32[4489];
            if (!(!!$0 & $0 >>> 0 <= $2 >>> 0)) {
             HEAP32[4489] = $2
            }
            $0 = 0;
            HEAP32[4598] = $4;
            HEAP32[4597] = $2;
            HEAP32[4493] = -1;
            HEAP32[4494] = HEAP32[4603];
            HEAP32[4600] = 0;
            while (1) {
             $1 = $0 << 3;
             $3 = $1 + 17980 | 0;
             HEAP32[$1 + 17988 >> 2] = $3;
             HEAP32[$1 + 17992 >> 2] = $3;
             $0 = $0 + 1 | 0;
             if (($0 | 0) != 32) {
              continue
             }
             break;
            };
            $0 = $4 - 40 | 0;
            $1 = -8 - $2 & 7;
            $3 = $0 - $1 | 0;
            HEAP32[4488] = $3;
            $1 = $1 + $2 | 0;
            HEAP32[4491] = $1;
            HEAP32[$1 + 4 >> 2] = $3 | 1;
            HEAP32[($0 + $2 | 0) + 4 >> 2] = 40;
            HEAP32[4492] = HEAP32[4607];
            break block57;
           }
           if (HEAP32[$0 + 12 >> 2] & 8 | ($2 >>> 0 <= $5 >>> 0 | $1 >>> 0 > $5 >>> 0)) {
            break block54
           }
           HEAP32[$0 + 4 >> 2] = $4 + $3;
           $0 = -8 - $5 & 7;
           $1 = $0 + $5 | 0;
           HEAP32[4491] = $1;
           $2 = HEAP32[4488] + $4 | 0;
           $0 = $2 - $0 | 0;
           HEAP32[4488] = $0;
           HEAP32[$1 + 4 >> 2] = $0 | 1;
           HEAP32[($2 + $5 | 0) + 4 >> 2] = 40;
           HEAP32[4492] = HEAP32[4607];
           break block57;
          }
          $0 = 0;
          break block15;
         }
         $0 = 0;
         break block28;
        }
        if ($2 >>> 0 < HEAPU32[4489]) {
         HEAP32[4489] = $2
        }
        $3 = $2 + $4 | 0;
        $0 = 18388;
        block60 : {
         while (1) {
          $1 = HEAP32[$0 >> 2];
          if (($3 | 0) != ($1 | 0)) {
           $0 = HEAP32[$0 + 8 >> 2];
           if ($0) {
            continue
           }
           break block60;
          }
          break;
         };
         if (!(HEAPU8[$0 + 12 | 0] & 8)) {
          break block61
         }
        }
        $0 = 18388;
        while (1) {
         block63 : {
          $1 = HEAP32[$0 >> 2];
          if ($5 >>> 0 >= $1 >>> 0) {
           $3 = $1 + HEAP32[$0 + 4 >> 2] | 0;
           if ($3 >>> 0 > $5 >>> 0) {
            break block63
           }
          }
          $0 = HEAP32[$0 + 8 >> 2];
          continue;
         }
         break;
        };
        $0 = $4 - 40 | 0;
        $1 = -8 - $2 & 7;
        $6 = $0 - $1 | 0;
        HEAP32[4488] = $6;
        $1 = $1 + $2 | 0;
        HEAP32[4491] = $1;
        HEAP32[$1 + 4 >> 2] = $6 | 1;
        HEAP32[($0 + $2 | 0) + 4 >> 2] = 40;
        HEAP32[4492] = HEAP32[4607];
        $0 = ($3 + (39 - $3 & 7) | 0) - 47 | 0;
        $1 = $0 >>> 0 < $5 + 16 >>> 0 ? $5 : $0;
        HEAP32[$1 + 4 >> 2] = 27;
        $0 = HEAP32[4600];
        $6 = $1 + 16 | 0;
        HEAP32[$6 >> 2] = HEAP32[4599];
        HEAP32[$6 + 4 >> 2] = $0;
        $0 = HEAP32[4598];
        HEAP32[$1 + 8 >> 2] = HEAP32[4597];
        HEAP32[$1 + 12 >> 2] = $0;
        HEAP32[4599] = $1 + 8;
        HEAP32[4598] = $4;
        HEAP32[4597] = $2;
        HEAP32[4600] = 0;
        $0 = $1 + 24 | 0;
        while (1) {
         HEAP32[$0 + 4 >> 2] = 7;
         $2 = $0 + 8 | 0;
         $0 = $0 + 4 | 0;
         if ($2 >>> 0 < $3 >>> 0) {
          continue
         }
         break;
        };
        if (($1 | 0) == ($5 | 0)) {
         break block57
        }
        HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] & -2;
        $2 = $1 - $5 | 0;
        HEAP32[$5 + 4 >> 2] = $2 | 1;
        HEAP32[$1 >> 2] = $2;
        block67 : {
         if ($2 >>> 0 <= 255) {
          $0 = ($2 & -8) + 17980 | 0;
          $1 = HEAP32[4485];
          $2 = 1 << ($2 >>> 3);
          block66 : {
           if (!($1 & $2)) {
            HEAP32[4485] = $1 | $2;
            $1 = $0;
            break block66;
           }
           $1 = HEAP32[$0 + 8 >> 2];
          }
          HEAP32[$0 + 8 >> 2] = $5;
          HEAP32[$1 + 12 >> 2] = $5;
          $2 = 12;
          $3 = 8;
          break block67;
         }
         $0 = 31;
         if ($2 >>> 0 <= 16777215) {
          $0 = Math_clz32($2 >>> 8 | 0);
          $0 = (($2 >>> 38 - $0 & 1) - ($0 << 1) | 0) + 62 | 0;
         }
         HEAP32[$5 + 28 >> 2] = $0;
         HEAP32[$5 + 16 >> 2] = 0;
         HEAP32[$5 + 20 >> 2] = 0;
         $1 = ($0 << 2) + 18244 | 0;
         block71 : {
          $3 = HEAP32[4486];
          $4 = 1 << $0;
          block70 : {
           if (!($3 & $4)) {
            HEAP32[4486] = $4 | $3;
            HEAP32[$1 >> 2] = $5;
            break block70;
           }
           $0 = $2 << (($0 | 0) != 31 ? 25 - ($0 >>> 1 | 0) | 0 : 0);
           $3 = HEAP32[$1 >> 2];
           while (1) {
            $1 = $3;
            if (($2 | 0) == (HEAP32[$1 + 4 >> 2] & -8)) {
             break block71
            }
            $3 = $0 >>> 29 | 0;
            $0 = $0 << 1;
            $4 = ($3 & 4) + $1 | 0;
            $3 = HEAP32[$4 + 16 >> 2];
            if ($3) {
             continue
            }
            break;
           };
           HEAP32[$4 + 16 >> 2] = $5;
          }
          HEAP32[$5 + 24 >> 2] = $1;
          $2 = 8;
          $1 = $5;
          $0 = $1;
          $3 = 12;
          break block67;
         }
         $0 = HEAP32[$1 + 8 >> 2];
         HEAP32[$0 + 12 >> 2] = $5;
         HEAP32[$1 + 8 >> 2] = $5;
         HEAP32[$5 + 8 >> 2] = $0;
         $0 = 0;
         $2 = 24;
         $3 = 12;
        }
        HEAP32[$3 + $5 >> 2] = $1;
        HEAP32[$2 + $5 >> 2] = $0;
       }
       $0 = HEAP32[4488];
       if ($0 >>> 0 <= $7 >>> 0) {
        break block50
       }
       $1 = $0 - $7 | 0;
       HEAP32[4488] = $1;
       $0 = HEAP32[4491];
       $2 = $0 + $7 | 0;
       HEAP32[4491] = $2;
       HEAP32[$2 + 4 >> 2] = $1 | 1;
       HEAP32[$0 + 4 >> 2] = $7 | 3;
       $0 = $0 + 8 | 0;
       break block4;
      }
      HEAP32[4484] = 48;
      $0 = 0;
      break block4;
     }
     HEAP32[$0 >> 2] = $2;
     HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + $4;
     $8 = (-8 - $2 & 7) + $2 | 0;
     HEAP32[$8 + 4 >> 2] = $7 | 3;
     $4 = (-8 - $1 & 7) + $1 | 0;
     $5 = $7 + $8 | 0;
     $6 = $4 - $5 | 0;
     block1 : {
      if (($4 | 0) == HEAP32[4491]) {
       HEAP32[4491] = $5;
       $0 = HEAP32[4488] + $6 | 0;
       HEAP32[4488] = $0;
       HEAP32[$5 + 4 >> 2] = $0 | 1;
       break block1;
      }
      if (($4 | 0) == HEAP32[4490]) {
       HEAP32[4490] = $5;
       $0 = HEAP32[4487] + $6 | 0;
       HEAP32[4487] = $0;
       HEAP32[$5 + 4 >> 2] = $0 | 1;
       HEAP32[$0 + $5 >> 2] = $0;
       break block1;
      }
      $0 = HEAP32[$4 + 4 >> 2];
      if (($0 & 3) == 1) {
       $9 = $0 & -8;
       $2 = HEAP32[$4 + 12 >> 2];
       block6 : {
        if ($0 >>> 0 <= 255) {
         $1 = HEAP32[$4 + 8 >> 2];
         if (($2 | 0) == ($1 | 0)) {
          (wasm2js_i32$0 = 17940, wasm2js_i32$1 = HEAP32[4485] & __wasm_rotl_i32(-2, $0 >>> 3 | 0)), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
          break block6;
         }
         HEAP32[$1 + 12 >> 2] = $2;
         HEAP32[$2 + 8 >> 2] = $1;
         break block6;
        }
        $7 = HEAP32[$4 + 24 >> 2];
        block80 : {
         if (($2 | 0) != ($4 | 0)) {
          $0 = HEAP32[$4 + 8 >> 2];
          HEAP32[$0 + 12 >> 2] = $2;
          HEAP32[$2 + 8 >> 2] = $0;
          break block80;
         }
         block111 : {
          $0 = HEAP32[$4 + 20 >> 2];
          if ($0) {
           $1 = $4 + 20 | 0
          } else {
           $0 = HEAP32[$4 + 16 >> 2];
           if (!$0) {
            break block111
           }
           $1 = $4 + 16 | 0;
          }
          while (1) {
           $3 = $1;
           $2 = $0;
           $1 = $0 + 20 | 0;
           $0 = HEAP32[$0 + 20 >> 2];
           if ($0) {
            continue
           }
           $1 = $2 + 16 | 0;
           $0 = HEAP32[$2 + 16 >> 2];
           if ($0) {
            continue
           }
           break;
          };
          HEAP32[$3 >> 2] = 0;
          break block80;
         }
         $2 = 0;
        }
        if (!$7) {
         break block6
        }
        $0 = HEAP32[$4 + 28 >> 2];
        $1 = ($0 << 2) + 18244 | 0;
        block1313 : {
         if (($4 | 0) == HEAP32[$1 >> 2]) {
          HEAP32[$1 >> 2] = $2;
          if ($2) {
           break block1313
          }
          (wasm2js_i32$0 = 17944, wasm2js_i32$1 = HEAP32[4486] & __wasm_rotl_i32(-2, $0)), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
          break block6;
         }
         block1514 : {
          if (($4 | 0) == HEAP32[$7 + 16 >> 2]) {
           HEAP32[$7 + 16 >> 2] = $2;
           break block1514;
          }
          HEAP32[$7 + 20 >> 2] = $2;
         }
         if (!$2) {
          break block6
         }
        }
        HEAP32[$2 + 24 >> 2] = $7;
        $0 = HEAP32[$4 + 16 >> 2];
        if ($0) {
         HEAP32[$2 + 16 >> 2] = $0;
         HEAP32[$0 + 24 >> 2] = $2;
        }
        $0 = HEAP32[$4 + 20 >> 2];
        if (!$0) {
         break block6
        }
        HEAP32[$2 + 20 >> 2] = $0;
        HEAP32[$0 + 24 >> 2] = $2;
       }
       $6 = $6 + $9 | 0;
       $4 = $4 + $9 | 0;
       $0 = HEAP32[$4 + 4 >> 2];
      }
      HEAP32[$4 + 4 >> 2] = $0 & -2;
      HEAP32[$5 + 4 >> 2] = $6 | 1;
      HEAP32[$5 + $6 >> 2] = $6;
      if ($6 >>> 0 <= 255) {
       $0 = ($6 & -8) + 17980 | 0;
       $1 = HEAP32[4485];
       $2 = 1 << ($6 >>> 3);
       block19 : {
        if (!($1 & $2)) {
         HEAP32[4485] = $1 | $2;
         $1 = $0;
         break block19;
        }
        $1 = HEAP32[$0 + 8 >> 2];
       }
       HEAP32[$0 + 8 >> 2] = $5;
       HEAP32[$1 + 12 >> 2] = $5;
       HEAP32[$5 + 12 >> 2] = $0;
       HEAP32[$5 + 8 >> 2] = $1;
       break block1;
      }
      $2 = 31;
      if ($6 >>> 0 <= 16777215) {
       $0 = Math_clz32($6 >>> 8 | 0);
       $2 = (($6 >>> 38 - $0 & 1) - ($0 << 1) | 0) + 62 | 0;
      }
      HEAP32[$5 + 28 >> 2] = $2;
      HEAP32[$5 + 16 >> 2] = 0;
      HEAP32[$5 + 20 >> 2] = 0;
      $0 = ($2 << 2) + 18244 | 0;
      block2315 : {
       $1 = HEAP32[4486];
       $3 = 1 << $2;
       block2216 : {
        if (!($1 & $3)) {
         HEAP32[4486] = $1 | $3;
         HEAP32[$0 >> 2] = $5;
         break block2216;
        }
        $2 = $6 << (($2 | 0) != 31 ? 25 - ($2 >>> 1 | 0) | 0 : 0);
        $1 = HEAP32[$0 >> 2];
        while (1) {
         $0 = $1;
         if ((HEAP32[$0 + 4 >> 2] & -8) == ($6 | 0)) {
          break block2315
         }
         $1 = $2 >>> 29 | 0;
         $2 = $2 << 1;
         $3 = $0 + ($1 & 4) | 0;
         $1 = HEAP32[$3 + 16 >> 2];
         if ($1) {
          continue
         }
         break;
        };
        HEAP32[$3 + 16 >> 2] = $5;
       }
       HEAP32[$5 + 24 >> 2] = $0;
       HEAP32[$5 + 12 >> 2] = $5;
       HEAP32[$5 + 8 >> 2] = $5;
       break block1;
      }
      $1 = HEAP32[$0 + 8 >> 2];
      HEAP32[$1 + 12 >> 2] = $5;
      HEAP32[$0 + 8 >> 2] = $5;
      HEAP32[$5 + 24 >> 2] = 0;
      HEAP32[$5 + 12 >> 2] = $0;
      HEAP32[$5 + 8 >> 2] = $1;
     }
     $0 = $8 + 8 | 0;
     break block4;
    }
    block72 : {
     if (!$8) {
      break block72
     }
     $1 = HEAP32[$3 + 28 >> 2];
     $2 = ($1 << 2) + 18244 | 0;
     block74 : {
      if (($3 | 0) == HEAP32[$2 >> 2]) {
       HEAP32[$2 >> 2] = $0;
       if ($0) {
        break block74
       }
       $6 = __wasm_rotl_i32(-2, $1) & $6;
       HEAP32[4486] = $6;
       break block72;
      }
      block76 : {
       if (($3 | 0) == HEAP32[$8 + 16 >> 2]) {
        HEAP32[$8 + 16 >> 2] = $0;
        break block76;
       }
       HEAP32[$8 + 20 >> 2] = $0;
      }
      if (!$0) {
       break block72
      }
     }
     HEAP32[$0 + 24 >> 2] = $8;
     $1 = HEAP32[$3 + 16 >> 2];
     if ($1) {
      HEAP32[$0 + 16 >> 2] = $1;
      HEAP32[$1 + 24 >> 2] = $0;
     }
     $1 = HEAP32[$3 + 20 >> 2];
     if (!$1) {
      break block72
     }
     HEAP32[$0 + 20 >> 2] = $1;
     HEAP32[$1 + 24 >> 2] = $0;
    }
    block79 : {
     if ($5 >>> 0 <= 15) {
      $0 = $5 + $7 | 0;
      HEAP32[$3 + 4 >> 2] = $0 | 3;
      $0 = $0 + $3 | 0;
      HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 1;
      break block79;
     }
     HEAP32[$3 + 4 >> 2] = $7 | 3;
     $4 = $3 + $7 | 0;
     HEAP32[$4 + 4 >> 2] = $5 | 1;
     HEAP32[$5 + $4 >> 2] = $5;
     if ($5 >>> 0 <= 255) {
      $0 = ($5 & -8) + 17980 | 0;
      $1 = HEAP32[4485];
      $2 = 1 << ($5 >>> 3);
      block82 : {
       if (!($1 & $2)) {
        HEAP32[4485] = $1 | $2;
        $1 = $0;
        break block82;
       }
       $1 = HEAP32[$0 + 8 >> 2];
      }
      HEAP32[$0 + 8 >> 2] = $4;
      HEAP32[$1 + 12 >> 2] = $4;
      HEAP32[$4 + 12 >> 2] = $0;
      HEAP32[$4 + 8 >> 2] = $1;
      break block79;
     }
     $0 = 31;
     if ($5 >>> 0 <= 16777215) {
      $0 = Math_clz32($5 >>> 8 | 0);
      $0 = (($5 >>> 38 - $0 & 1) - ($0 << 1) | 0) + 62 | 0;
     }
     HEAP32[$4 + 28 >> 2] = $0;
     HEAP32[$4 + 16 >> 2] = 0;
     HEAP32[$4 + 20 >> 2] = 0;
     $1 = ($0 << 2) + 18244 | 0;
     block86 : {
      $2 = 1 << $0;
      block85 : {
       if (!($2 & $6)) {
        HEAP32[4486] = $2 | $6;
        HEAP32[$1 >> 2] = $4;
        HEAP32[$4 + 24 >> 2] = $1;
        break block85;
       }
       $0 = $5 << (($0 | 0) != 31 ? 25 - ($0 >>> 1 | 0) | 0 : 0);
       $1 = HEAP32[$1 >> 2];
       while (1) {
        $2 = $1;
        if ((HEAP32[$1 + 4 >> 2] & -8) == ($5 | 0)) {
         break block86
        }
        $6 = $0 >>> 29 | 0;
        $0 = $0 << 1;
        $6 = $1 + ($6 & 4) | 0;
        $1 = HEAP32[$6 + 16 >> 2];
        if ($1) {
         continue
        }
        break;
       };
       HEAP32[$6 + 16 >> 2] = $4;
       HEAP32[$4 + 24 >> 2] = $2;
      }
      HEAP32[$4 + 12 >> 2] = $4;
      HEAP32[$4 + 8 >> 2] = $4;
      break block79;
     }
     $0 = HEAP32[$2 + 8 >> 2];
     HEAP32[$0 + 12 >> 2] = $4;
     HEAP32[$2 + 8 >> 2] = $4;
     HEAP32[$4 + 24 >> 2] = 0;
     HEAP32[$4 + 12 >> 2] = $2;
     HEAP32[$4 + 8 >> 2] = $0;
    }
    $0 = $3 + 8 | 0;
    break block4;
   }
   block87 : {
    if (!$9) {
     break block87
    }
    $1 = HEAP32[$2 + 28 >> 2];
    $3 = ($1 << 2) + 18244 | 0;
    block89 : {
     if (($2 | 0) == HEAP32[$3 >> 2]) {
      HEAP32[$3 >> 2] = $0;
      if ($0) {
       break block89
      }
      (wasm2js_i32$0 = 17944, wasm2js_i32$1 = __wasm_rotl_i32(-2, $1) & $11), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
      break block87;
     }
     block91 : {
      if (($2 | 0) == HEAP32[$9 + 16 >> 2]) {
       HEAP32[$9 + 16 >> 2] = $0;
       break block91;
      }
      HEAP32[$9 + 20 >> 2] = $0;
     }
     if (!$0) {
      break block87
     }
    }
    HEAP32[$0 + 24 >> 2] = $9;
    $1 = HEAP32[$2 + 16 >> 2];
    if ($1) {
     HEAP32[$0 + 16 >> 2] = $1;
     HEAP32[$1 + 24 >> 2] = $0;
    }
    $1 = HEAP32[$2 + 20 >> 2];
    if (!$1) {
     break block87
    }
    HEAP32[$0 + 20 >> 2] = $1;
    HEAP32[$1 + 24 >> 2] = $0;
   }
   block94 : {
    if ($5 >>> 0 <= 15) {
     $0 = $5 + $7 | 0;
     HEAP32[$2 + 4 >> 2] = $0 | 3;
     $0 = $0 + $2 | 0;
     HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] | 1;
     break block94;
    }
    HEAP32[$2 + 4 >> 2] = $7 | 3;
    $3 = $2 + $7 | 0;
    HEAP32[$3 + 4 >> 2] = $5 | 1;
    HEAP32[$5 + $3 >> 2] = $5;
    if ($8) {
     $0 = ($8 & -8) + 17980 | 0;
     $1 = HEAP32[4490];
     $6 = 1 << ($8 >>> 3);
     block97 : {
      if (!($6 & $4)) {
       HEAP32[4485] = $4 | $6;
       $4 = $0;
       break block97;
      }
      $4 = HEAP32[$0 + 8 >> 2];
     }
     HEAP32[$0 + 8 >> 2] = $1;
     HEAP32[$4 + 12 >> 2] = $1;
     HEAP32[$1 + 12 >> 2] = $0;
     HEAP32[$1 + 8 >> 2] = $4;
    }
    HEAP32[4490] = $3;
    HEAP32[4487] = $5;
   }
   $0 = $2 + 8 | 0;
  }
  __stack_pointer = $10 + 16 | 0;
  return $0;
 }
 
 function emscripten_builtin_free($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
  block : {
   if (!$0) {
    break block
   }
   $3 = $0 - 8 | 0;
   $1 = HEAP32[$0 - 4 >> 2];
   $0 = $1 & -8;
   $5 = $3 + $0 | 0;
   block1 : {
    if ($1 & 1) {
     break block1
    }
    if (!($1 & 2)) {
     break block
    }
    $1 = HEAP32[$3 >> 2];
    $3 = $3 - $1 | 0;
    if ($3 >>> 0 < HEAPU32[4489]) {
     break block
    }
    $0 = $0 + $1 | 0;
    block6 : {
     block9 : {
      block4 : {
       if (($3 | 0) != HEAP32[4490]) {
        $2 = HEAP32[$3 + 12 >> 2];
        if ($1 >>> 0 <= 255) {
         $4 = HEAP32[$3 + 8 >> 2];
         if (($4 | 0) != ($2 | 0)) {
          break block4
         }
         (wasm2js_i32$0 = 17940, wasm2js_i32$1 = HEAP32[4485] & __wasm_rotl_i32(-2, $1 >>> 3 | 0)), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
         break block1;
        }
        $7 = HEAP32[$3 + 24 >> 2];
        if (($2 | 0) != ($3 | 0)) {
         $1 = HEAP32[$3 + 8 >> 2];
         HEAP32[$1 + 12 >> 2] = $2;
         HEAP32[$2 + 8 >> 2] = $1;
         break block6;
        }
        $1 = HEAP32[$3 + 20 >> 2];
        if ($1) {
         $4 = $3 + 20 | 0
        } else {
         $1 = HEAP32[$3 + 16 >> 2];
         if (!$1) {
          break block9
         }
         $4 = $3 + 16 | 0;
        }
        while (1) {
         $6 = $4;
         $2 = $1;
         $4 = $1 + 20 | 0;
         $1 = HEAP32[$1 + 20 >> 2];
         if ($1) {
          continue
         }
         $4 = $2 + 16 | 0;
         $1 = HEAP32[$2 + 16 >> 2];
         if ($1) {
          continue
         }
         break;
        };
        HEAP32[$6 >> 2] = 0;
        break block6;
       }
       $1 = HEAP32[$5 + 4 >> 2];
       if (($1 & 3) != 3) {
        break block1
       }
       HEAP32[4487] = $0;
       HEAP32[$5 + 4 >> 2] = $1 & -2;
       HEAP32[$3 + 4 >> 2] = $0 | 1;
       HEAP32[$5 >> 2] = $0;
       return;
      }
      HEAP32[$4 + 12 >> 2] = $2;
      HEAP32[$2 + 8 >> 2] = $4;
      break block1;
     }
     $2 = 0;
    }
    if (!$7) {
     break block1
    }
    $1 = HEAP32[$3 + 28 >> 2];
    $4 = ($1 << 2) + 18244 | 0;
    block11 : {
     if (($3 | 0) == HEAP32[$4 >> 2]) {
      HEAP32[$4 >> 2] = $2;
      if ($2) {
       break block11
      }
      (wasm2js_i32$0 = 17944, wasm2js_i32$1 = HEAP32[4486] & __wasm_rotl_i32(-2, $1)), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
      break block1;
     }
     block13 : {
      if (($3 | 0) == HEAP32[$7 + 16 >> 2]) {
       HEAP32[$7 + 16 >> 2] = $2;
       break block13;
      }
      HEAP32[$7 + 20 >> 2] = $2;
     }
     if (!$2) {
      break block1
     }
    }
    HEAP32[$2 + 24 >> 2] = $7;
    $1 = HEAP32[$3 + 16 >> 2];
    if ($1) {
     HEAP32[$2 + 16 >> 2] = $1;
     HEAP32[$1 + 24 >> 2] = $2;
    }
    $1 = HEAP32[$3 + 20 >> 2];
    if (!$1) {
     break block1
    }
    HEAP32[$2 + 20 >> 2] = $1;
    HEAP32[$1 + 24 >> 2] = $2;
   }
   if ($3 >>> 0 >= $5 >>> 0) {
    break block
   }
   $1 = HEAP32[$5 + 4 >> 2];
   if (!($1 & 1)) {
    break block
   }
   block26 : {
    block20 : {
     block22 : {
      block25 : {
       if (!($1 & 2)) {
        if (HEAP32[4491] == ($5 | 0)) {
         HEAP32[4491] = $3;
         $0 = HEAP32[4488] + $0 | 0;
         HEAP32[4488] = $0;
         HEAP32[$3 + 4 >> 2] = $0 | 1;
         if (HEAP32[4490] != ($3 | 0)) {
          break block
         }
         HEAP32[4487] = 0;
         HEAP32[4490] = 0;
         return;
        }
        $8 = HEAP32[4490];
        if (($5 | 0) == ($8 | 0)) {
         HEAP32[4490] = $3;
         $0 = HEAP32[4487] + $0 | 0;
         HEAP32[4487] = $0;
         HEAP32[$3 + 4 >> 2] = $0 | 1;
         HEAP32[$0 + $3 >> 2] = $0;
         return;
        }
        $0 = ($1 & -8) + $0 | 0;
        $2 = HEAP32[$5 + 12 >> 2];
        if ($1 >>> 0 <= 255) {
         $4 = HEAP32[$5 + 8 >> 2];
         if (($2 | 0) == ($4 | 0)) {
          (wasm2js_i32$0 = 17940, wasm2js_i32$1 = HEAP32[4485] & __wasm_rotl_i32(-2, $1 >>> 3 | 0)), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
          break block20;
         }
         HEAP32[$4 + 12 >> 2] = $2;
         HEAP32[$2 + 8 >> 2] = $4;
         break block20;
        }
        $7 = HEAP32[$5 + 24 >> 2];
        if (($2 | 0) != ($5 | 0)) {
         $1 = HEAP32[$5 + 8 >> 2];
         HEAP32[$1 + 12 >> 2] = $2;
         HEAP32[$2 + 8 >> 2] = $1;
         break block22;
        }
        $1 = HEAP32[$5 + 20 >> 2];
        if ($1) {
         $4 = $5 + 20 | 0
        } else {
         $1 = HEAP32[$5 + 16 >> 2];
         if (!$1) {
          break block25
         }
         $4 = $5 + 16 | 0;
        }
        while (1) {
         $6 = $4;
         $2 = $1;
         $4 = $1 + 20 | 0;
         $1 = HEAP32[$1 + 20 >> 2];
         if ($1) {
          continue
         }
         $4 = $2 + 16 | 0;
         $1 = HEAP32[$2 + 16 >> 2];
         if ($1) {
          continue
         }
         break;
        };
        HEAP32[$6 >> 2] = 0;
        break block22;
       }
       HEAP32[$5 + 4 >> 2] = $1 & -2;
       HEAP32[$3 + 4 >> 2] = $0 | 1;
       HEAP32[$0 + $3 >> 2] = $0;
       break block26;
      }
      $2 = 0;
     }
     if (!$7) {
      break block20
     }
     $1 = HEAP32[$5 + 28 >> 2];
     $4 = ($1 << 2) + 18244 | 0;
     block28 : {
      if (HEAP32[$4 >> 2] == ($5 | 0)) {
       HEAP32[$4 >> 2] = $2;
       if ($2) {
        break block28
       }
       (wasm2js_i32$0 = 17944, wasm2js_i32$1 = HEAP32[4486] & __wasm_rotl_i32(-2, $1)), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
       break block20;
      }
      block30 : {
       if (HEAP32[$7 + 16 >> 2] == ($5 | 0)) {
        HEAP32[$7 + 16 >> 2] = $2;
        break block30;
       }
       HEAP32[$7 + 20 >> 2] = $2;
      }
      if (!$2) {
       break block20
      }
     }
     HEAP32[$2 + 24 >> 2] = $7;
     $1 = HEAP32[$5 + 16 >> 2];
     if ($1) {
      HEAP32[$2 + 16 >> 2] = $1;
      HEAP32[$1 + 24 >> 2] = $2;
     }
     $1 = HEAP32[$5 + 20 >> 2];
     if (!$1) {
      break block20
     }
     HEAP32[$2 + 20 >> 2] = $1;
     HEAP32[$1 + 24 >> 2] = $2;
    }
    HEAP32[$3 + 4 >> 2] = $0 | 1;
    HEAP32[$0 + $3 >> 2] = $0;
    if (($3 | 0) != ($8 | 0)) {
     break block26
    }
    HEAP32[4487] = $0;
    return;
   }
   if ($0 >>> 0 <= 255) {
    $1 = ($0 & -8) + 17980 | 0;
    $4 = HEAP32[4485];
    $0 = 1 << ($0 >>> 3);
    block34 : {
     if (!($4 & $0)) {
      HEAP32[4485] = $0 | $4;
      $0 = $1;
      break block34;
     }
     $0 = HEAP32[$1 + 8 >> 2];
    }
    HEAP32[$1 + 8 >> 2] = $3;
    HEAP32[$0 + 12 >> 2] = $3;
    HEAP32[$3 + 12 >> 2] = $1;
    HEAP32[$3 + 8 >> 2] = $0;
    return;
   }
   $2 = 31;
   if ($0 >>> 0 <= 16777215) {
    $1 = Math_clz32($0 >>> 8 | 0);
    $2 = (($0 >>> 38 - $1 & 1) - ($1 << 1) | 0) + 62 | 0;
   }
   HEAP32[$3 + 28 >> 2] = $2;
   HEAP32[$3 + 16 >> 2] = 0;
   HEAP32[$3 + 20 >> 2] = 0;
   $4 = ($2 << 2) + 18244 | 0;
   block39 : {
    block38 : {
     $1 = HEAP32[4486];
     $6 = 1 << $2;
     block37 : {
      if (!($1 & $6)) {
       HEAP32[4486] = $1 | $6;
       HEAP32[$4 >> 2] = $3;
       $2 = 24;
       $0 = 8;
       break block37;
      }
      $2 = $0 << (($2 | 0) != 31 ? 25 - ($2 >>> 1 | 0) | 0 : 0);
      $4 = HEAP32[$4 >> 2];
      while (1) {
       $1 = $4;
       if ((HEAP32[$1 + 4 >> 2] & -8) == ($0 | 0)) {
        break block38
       }
       $4 = $2 >>> 29 | 0;
       $2 = $2 << 1;
       $6 = ($4 & 4) + $1 | 0;
       $4 = HEAP32[$6 + 16 >> 2];
       if ($4) {
        continue
       }
       break;
      };
      HEAP32[$6 + 16 >> 2] = $3;
      $2 = 24;
      $4 = $1;
      $0 = 8;
     }
     $1 = $3;
     $6 = $1;
     break block39;
    }
    $4 = HEAP32[$1 + 8 >> 2];
    HEAP32[$4 + 12 >> 2] = $3;
    HEAP32[$1 + 8 >> 2] = $3;
    $0 = 24;
    $2 = 8;
    $6 = 0;
   }
   HEAP32[$2 + $3 >> 2] = $4;
   HEAP32[$3 + 12 >> 2] = $1;
   HEAP32[$0 + $3 >> 2] = $6;
   $0 = HEAP32[4493] - 1 | 0;
   HEAP32[4493] = $0 ? $0 : -1;
  }
 }
 
 function emscripten_builtin_realloc($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
  if (!$0) {
   return emscripten_builtin_malloc($1)
  }
  if ($1 >>> 0 >= 4294967232) {
   HEAP32[4484] = 48;
   return 0;
  }
  $7 = $1 >>> 0 < 11 ? 16 : $1 + 11 & -8;
  $4 = $0 - 8 | 0;
  $9 = HEAP32[$4 + 4 >> 2];
  $5 = $9 & -8;
  __inlined_func$try_realloc_chunk$6 : {
   block1 : {
    if (!($9 & 3)) {
     if ($7 >>> 0 < 256) {
      break block1
     }
     if ($7 + 4 >>> 0 <= $5 >>> 0) {
      $2 = $4;
      if ($5 - $7 >>> 0 <= HEAP32[4605] << 1 >>> 0) {
       break block1
      }
     }
     $2 = 0;
     break __inlined_func$try_realloc_chunk$6;
    }
    $8 = $4 + $5 | 0;
    block4 : {
     if ($7 >>> 0 <= $5 >>> 0) {
      $3 = $5 - $7 | 0;
      if ($3 >>> 0 < 16) {
       break block4
      }
      HEAP32[$4 + 4 >> 2] = $9 & 1 | $7 | 2;
      $2 = $4 + $7 | 0;
      HEAP32[$2 + 4 >> 2] = $3 | 3;
      HEAP32[$8 + 4 >> 2] = HEAP32[$8 + 4 >> 2] | 1;
      dispose_chunk($2, $3);
      break block4;
     }
     if (($8 | 0) == HEAP32[4491]) {
      $5 = $5 + HEAP32[4488] | 0;
      if ($5 >>> 0 <= $7 >>> 0) {
       break block1
      }
      HEAP32[$4 + 4 >> 2] = $9 & 1 | $7 | 2;
      $3 = $4 + $7 | 0;
      $2 = $5 - $7 | 0;
      HEAP32[$3 + 4 >> 2] = $2 | 1;
      HEAP32[4488] = $2;
      HEAP32[4491] = $3;
      break block4;
     }
     if (($8 | 0) == HEAP32[4490]) {
      $3 = $5 + HEAP32[4487] | 0;
      if ($3 >>> 0 < $7 >>> 0) {
       break block1
      }
      $2 = $3 - $7 | 0;
      block8 : {
       if ($2 >>> 0 >= 16) {
        HEAP32[$4 + 4 >> 2] = $9 & 1 | $7 | 2;
        $5 = $4 + $7 | 0;
        HEAP32[$5 + 4 >> 2] = $2 | 1;
        $3 = $3 + $4 | 0;
        HEAP32[$3 >> 2] = $2;
        HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] & -2;
        break block8;
       }
       HEAP32[$4 + 4 >> 2] = $3 | $9 & 1 | 2;
       $2 = $3 + $4 | 0;
       HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 1;
       $2 = 0;
       $5 = 0;
      }
      HEAP32[4490] = $5;
      HEAP32[4487] = $2;
      break block4;
     }
     $3 = HEAP32[$8 + 4 >> 2];
     if ($3 & 2) {
      break block1
     }
     $10 = $5 + ($3 & -8) | 0;
     if ($10 >>> 0 < $7 >>> 0) {
      break block1
     }
     $12 = $10 - $7 | 0;
     $6 = HEAP32[$8 + 12 >> 2];
     block11 : {
      if ($3 >>> 0 <= 255) {
       $2 = HEAP32[$8 + 8 >> 2];
       if (($6 | 0) == ($2 | 0)) {
        (wasm2js_i32$0 = 17940, wasm2js_i32$1 = HEAP32[4485] & __wasm_rotl_i32(-2, $3 >>> 3 | 0)), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
        break block11;
       }
       HEAP32[$2 + 12 >> 2] = $6;
       HEAP32[$6 + 8 >> 2] = $2;
       break block11;
      }
      $11 = HEAP32[$8 + 24 >> 2];
      block13 : {
       if (($6 | 0) != ($8 | 0)) {
        $2 = HEAP32[$8 + 8 >> 2];
        HEAP32[$2 + 12 >> 2] = $6;
        HEAP32[$6 + 8 >> 2] = $2;
        break block13;
       }
       block16 : {
        $2 = HEAP32[$8 + 20 >> 2];
        if ($2) {
         $5 = $8 + 20 | 0
        } else {
         $2 = HEAP32[$8 + 16 >> 2];
         if (!$2) {
          break block16
         }
         $5 = $8 + 16 | 0;
        }
        while (1) {
         $3 = $5;
         $6 = $2;
         $5 = $2 + 20 | 0;
         $2 = HEAP32[$2 + 20 >> 2];
         if ($2) {
          continue
         }
         $5 = $6 + 16 | 0;
         $2 = HEAP32[$6 + 16 >> 2];
         if ($2) {
          continue
         }
         break;
        };
        HEAP32[$3 >> 2] = 0;
        break block13;
       }
       $6 = 0;
      }
      if (!$11) {
       break block11
      }
      $3 = HEAP32[$8 + 28 >> 2];
      $2 = ($3 << 2) + 18244 | 0;
      block18 : {
       if (($8 | 0) == HEAP32[$2 >> 2]) {
        HEAP32[$2 >> 2] = $6;
        if ($6) {
         break block18
        }
        (wasm2js_i32$0 = 17944, wasm2js_i32$1 = HEAP32[4486] & __wasm_rotl_i32(-2, $3)), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
        break block11;
       }
       block20 : {
        if (($8 | 0) == HEAP32[$11 + 16 >> 2]) {
         HEAP32[$11 + 16 >> 2] = $6;
         break block20;
        }
        HEAP32[$11 + 20 >> 2] = $6;
       }
       if (!$6) {
        break block11
       }
      }
      HEAP32[$6 + 24 >> 2] = $11;
      $2 = HEAP32[$8 + 16 >> 2];
      if ($2) {
       HEAP32[$6 + 16 >> 2] = $2;
       HEAP32[$2 + 24 >> 2] = $6;
      }
      $2 = HEAP32[$8 + 20 >> 2];
      if (!$2) {
       break block11
      }
      HEAP32[$6 + 20 >> 2] = $2;
      HEAP32[$2 + 24 >> 2] = $6;
     }
     if ($12 >>> 0 <= 15) {
      HEAP32[$4 + 4 >> 2] = $9 & 1 | $10 | 2;
      $2 = $4 + $10 | 0;
      HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 1;
      break block4;
     }
     HEAP32[$4 + 4 >> 2] = $9 & 1 | $7 | 2;
     $3 = $4 + $7 | 0;
     HEAP32[$3 + 4 >> 2] = $12 | 3;
     $2 = $4 + $10 | 0;
     HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] | 1;
     dispose_chunk($3, $12);
    }
    $2 = $4;
   }
  }
  if ($2) {
   return $2 + 8 | 0
  }
  $4 = emscripten_builtin_malloc($1);
  if (!$4) {
   return 0
  }
  $2 = HEAP32[$0 - 4 >> 2];
  $2 = ($2 & 3 ? -4 : -8) + ($2 & -8) | 0;
  __memcpy($4, $0, $1 >>> 0 > $2 >>> 0 ? $2 : $1);
  emscripten_builtin_free($0);
  return $4;
 }
 
 function dispose_chunk($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
  $5 = $0 + $1 | 0;
  $2 = HEAP32[$0 + 4 >> 2];
  block1 : {
   block : {
    if ($2 & 1) {
     break block
    }
    if (!($2 & 2)) {
     break block1
    }
    $2 = HEAP32[$0 >> 2];
    $1 = $2 + $1 | 0;
    block6 : {
     block9 : {
      block4 : {
       $0 = $0 - $2 | 0;
       if (($0 | 0) != HEAP32[4490]) {
        $3 = HEAP32[$0 + 12 >> 2];
        if ($2 >>> 0 <= 255) {
         $4 = HEAP32[$0 + 8 >> 2];
         if (($4 | 0) != ($3 | 0)) {
          break block4
         }
         (wasm2js_i32$0 = 17940, wasm2js_i32$1 = HEAP32[4485] & __wasm_rotl_i32(-2, $2 >>> 3 | 0)), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
         break block;
        }
        $6 = HEAP32[$0 + 24 >> 2];
        if (($0 | 0) != ($3 | 0)) {
         $2 = HEAP32[$0 + 8 >> 2];
         HEAP32[$2 + 12 >> 2] = $3;
         HEAP32[$3 + 8 >> 2] = $2;
         break block6;
        }
        $4 = HEAP32[$0 + 20 >> 2];
        if ($4) {
         $2 = $0 + 20 | 0
        } else {
         $4 = HEAP32[$0 + 16 >> 2];
         if (!$4) {
          break block9
         }
         $2 = $0 + 16 | 0;
        }
        while (1) {
         $7 = $2;
         $3 = $4;
         $2 = $3 + 20 | 0;
         $4 = HEAP32[$3 + 20 >> 2];
         if ($4) {
          continue
         }
         $2 = $3 + 16 | 0;
         $4 = HEAP32[$3 + 16 >> 2];
         if ($4) {
          continue
         }
         break;
        };
        HEAP32[$7 >> 2] = 0;
        break block6;
       }
       $2 = HEAP32[$5 + 4 >> 2];
       if (($2 & 3) != 3) {
        break block
       }
       HEAP32[4487] = $1;
       HEAP32[$5 + 4 >> 2] = $2 & -2;
       HEAP32[$0 + 4 >> 2] = $1 | 1;
       HEAP32[$5 >> 2] = $1;
       return;
      }
      HEAP32[$4 + 12 >> 2] = $3;
      HEAP32[$3 + 8 >> 2] = $4;
      break block;
     }
     $3 = 0;
    }
    if (!$6) {
     break block
    }
    $2 = HEAP32[$0 + 28 >> 2];
    $4 = ($2 << 2) + 18244 | 0;
    block11 : {
     if (($0 | 0) == HEAP32[$4 >> 2]) {
      HEAP32[$4 >> 2] = $3;
      if ($3) {
       break block11
      }
      (wasm2js_i32$0 = 17944, wasm2js_i32$1 = HEAP32[4486] & __wasm_rotl_i32(-2, $2)), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
      break block;
     }
     block13 : {
      if (($0 | 0) == HEAP32[$6 + 16 >> 2]) {
       HEAP32[$6 + 16 >> 2] = $3;
       break block13;
      }
      HEAP32[$6 + 20 >> 2] = $3;
     }
     if (!$3) {
      break block
     }
    }
    HEAP32[$3 + 24 >> 2] = $6;
    $2 = HEAP32[$0 + 16 >> 2];
    if ($2) {
     HEAP32[$3 + 16 >> 2] = $2;
     HEAP32[$2 + 24 >> 2] = $3;
    }
    $2 = HEAP32[$0 + 20 >> 2];
    if (!$2) {
     break block
    }
    HEAP32[$3 + 20 >> 2] = $2;
    HEAP32[$2 + 24 >> 2] = $3;
   }
   block26 : {
    block20 : {
     block22 : {
      block25 : {
       $2 = HEAP32[$5 + 4 >> 2];
       if (!($2 & 2)) {
        if (HEAP32[4491] == ($5 | 0)) {
         HEAP32[4491] = $0;
         $1 = HEAP32[4488] + $1 | 0;
         HEAP32[4488] = $1;
         HEAP32[$0 + 4 >> 2] = $1 | 1;
         if (HEAP32[4490] != ($0 | 0)) {
          break block1
         }
         HEAP32[4487] = 0;
         HEAP32[4490] = 0;
         return;
        }
        $8 = HEAP32[4490];
        if (($5 | 0) == ($8 | 0)) {
         HEAP32[4490] = $0;
         $1 = HEAP32[4487] + $1 | 0;
         HEAP32[4487] = $1;
         HEAP32[$0 + 4 >> 2] = $1 | 1;
         HEAP32[$0 + $1 >> 2] = $1;
         return;
        }
        $1 = ($2 & -8) + $1 | 0;
        $3 = HEAP32[$5 + 12 >> 2];
        if ($2 >>> 0 <= 255) {
         $4 = HEAP32[$5 + 8 >> 2];
         if (($3 | 0) == ($4 | 0)) {
          (wasm2js_i32$0 = 17940, wasm2js_i32$1 = HEAP32[4485] & __wasm_rotl_i32(-2, $2 >>> 3 | 0)), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
          break block20;
         }
         HEAP32[$4 + 12 >> 2] = $3;
         HEAP32[$3 + 8 >> 2] = $4;
         break block20;
        }
        $6 = HEAP32[$5 + 24 >> 2];
        if (($3 | 0) != ($5 | 0)) {
         $2 = HEAP32[$5 + 8 >> 2];
         HEAP32[$2 + 12 >> 2] = $3;
         HEAP32[$3 + 8 >> 2] = $2;
         break block22;
        }
        $4 = HEAP32[$5 + 20 >> 2];
        if ($4) {
         $2 = $5 + 20 | 0
        } else {
         $4 = HEAP32[$5 + 16 >> 2];
         if (!$4) {
          break block25
         }
         $2 = $5 + 16 | 0;
        }
        while (1) {
         $7 = $2;
         $3 = $4;
         $2 = $3 + 20 | 0;
         $4 = HEAP32[$3 + 20 >> 2];
         if ($4) {
          continue
         }
         $2 = $3 + 16 | 0;
         $4 = HEAP32[$3 + 16 >> 2];
         if ($4) {
          continue
         }
         break;
        };
        HEAP32[$7 >> 2] = 0;
        break block22;
       }
       HEAP32[$5 + 4 >> 2] = $2 & -2;
       HEAP32[$0 + 4 >> 2] = $1 | 1;
       HEAP32[$0 + $1 >> 2] = $1;
       break block26;
      }
      $3 = 0;
     }
     if (!$6) {
      break block20
     }
     $2 = HEAP32[$5 + 28 >> 2];
     $4 = ($2 << 2) + 18244 | 0;
     block28 : {
      if (HEAP32[$4 >> 2] == ($5 | 0)) {
       HEAP32[$4 >> 2] = $3;
       if ($3) {
        break block28
       }
       (wasm2js_i32$0 = 17944, wasm2js_i32$1 = HEAP32[4486] & __wasm_rotl_i32(-2, $2)), HEAP32[wasm2js_i32$0 >> 2] = wasm2js_i32$1;
       break block20;
      }
      block30 : {
       if (HEAP32[$6 + 16 >> 2] == ($5 | 0)) {
        HEAP32[$6 + 16 >> 2] = $3;
        break block30;
       }
       HEAP32[$6 + 20 >> 2] = $3;
      }
      if (!$3) {
       break block20
      }
     }
     HEAP32[$3 + 24 >> 2] = $6;
     $2 = HEAP32[$5 + 16 >> 2];
     if ($2) {
      HEAP32[$3 + 16 >> 2] = $2;
      HEAP32[$2 + 24 >> 2] = $3;
     }
     $2 = HEAP32[$5 + 20 >> 2];
     if (!$2) {
      break block20
     }
     HEAP32[$3 + 20 >> 2] = $2;
     HEAP32[$2 + 24 >> 2] = $3;
    }
    HEAP32[$0 + 4 >> 2] = $1 | 1;
    HEAP32[$0 + $1 >> 2] = $1;
    if (($0 | 0) != ($8 | 0)) {
     break block26
    }
    HEAP32[4487] = $1;
    return;
   }
   if ($1 >>> 0 <= 255) {
    $2 = ($1 & -8) + 17980 | 0;
    $3 = HEAP32[4485];
    $1 = 1 << ($1 >>> 3);
    block34 : {
     if (!($3 & $1)) {
      HEAP32[4485] = $1 | $3;
      $1 = $2;
      break block34;
     }
     $1 = HEAP32[$2 + 8 >> 2];
    }
    HEAP32[$2 + 8 >> 2] = $0;
    HEAP32[$1 + 12 >> 2] = $0;
    HEAP32[$0 + 12 >> 2] = $2;
    HEAP32[$0 + 8 >> 2] = $1;
    return;
   }
   $3 = 31;
   if ($1 >>> 0 <= 16777215) {
    $2 = Math_clz32($1 >>> 8 | 0);
    $3 = (($1 >>> 38 - $2 & 1) - ($2 << 1) | 0) + 62 | 0;
   }
   HEAP32[$0 + 28 >> 2] = $3;
   HEAP32[$0 + 16 >> 2] = 0;
   HEAP32[$0 + 20 >> 2] = 0;
   $2 = ($3 << 2) + 18244 | 0;
   block38 : {
    $4 = HEAP32[4486];
    $7 = 1 << $3;
    block37 : {
     if (!($4 & $7)) {
      HEAP32[4486] = $4 | $7;
      HEAP32[$2 >> 2] = $0;
      HEAP32[$0 + 24 >> 2] = $2;
      break block37;
     }
     $3 = $1 << (($3 | 0) != 31 ? 25 - ($3 >>> 1 | 0) | 0 : 0);
     $2 = HEAP32[$2 >> 2];
     while (1) {
      $4 = $2;
      if ((HEAP32[$2 + 4 >> 2] & -8) == ($1 | 0)) {
       break block38
      }
      $2 = $3 >>> 29 | 0;
      $3 = $3 << 1;
      $7 = $4 + ($2 & 4) | 0;
      $2 = HEAP32[$7 + 16 >> 2];
      if ($2) {
       continue
      }
      break;
     };
     HEAP32[$7 + 16 >> 2] = $0;
     HEAP32[$0 + 24 >> 2] = $4;
    }
    HEAP32[$0 + 12 >> 2] = $0;
    HEAP32[$0 + 8 >> 2] = $0;
    return;
   }
   $1 = HEAP32[$4 + 8 >> 2];
   HEAP32[$1 + 12 >> 2] = $0;
   HEAP32[$4 + 8 >> 2] = $0;
   HEAP32[$0 + 24 >> 2] = 0;
   HEAP32[$0 + 12 >> 2] = $4;
   HEAP32[$0 + 8 >> 2] = $1;
  }
 }
 
 function emscripten_builtin_calloc($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  block1 : {
   if (!$0) {
    break block1
   }
   $2 = __wasm_i64_mul($0, 0, $1, 0);
   if (($0 | $1) >>> 0 < 65536) {
    break block1
   }
   $2 = i64toi32_i32$HIGH_BITS ? -1 : $2;
  }
  $0 = emscripten_builtin_malloc($2);
  if (!(!$0 | !(HEAPU8[$0 - 4 | 0] & 3))) {
   block : {
    if (!$2) {
     break block
    }
    HEAP8[$0 | 0] = 0;
    $1 = $0 + $2 | 0;
    HEAP8[$1 - 1 | 0] = 0;
    if ($2 >>> 0 < 3) {
     break block
    }
    HEAP8[$0 + 2 | 0] = 0;
    HEAP8[$0 + 1 | 0] = 0;
    HEAP8[$1 - 3 | 0] = 0;
    HEAP8[$1 - 2 | 0] = 0;
    if ($2 >>> 0 < 7) {
     break block
    }
    HEAP8[$0 + 3 | 0] = 0;
    HEAP8[$1 - 4 | 0] = 0;
    if ($2 >>> 0 < 9) {
     break block
    }
    $1 = 0 - $0 & 3;
    $3 = $1 + $0 | 0;
    HEAP32[$3 >> 2] = 0;
    $1 = $2 - $1 & -4;
    $2 = $1 + $3 | 0;
    HEAP32[$2 - 4 >> 2] = 0;
    if ($1 >>> 0 < 9) {
     break block
    }
    HEAP32[$3 + 8 >> 2] = 0;
    HEAP32[$3 + 4 >> 2] = 0;
    HEAP32[$2 - 8 >> 2] = 0;
    HEAP32[$2 - 12 >> 2] = 0;
    if ($1 >>> 0 < 25) {
     break block
    }
    HEAP32[$3 + 24 >> 2] = 0;
    HEAP32[$3 + 20 >> 2] = 0;
    HEAP32[$3 + 16 >> 2] = 0;
    HEAP32[$3 + 12 >> 2] = 0;
    HEAP32[$2 - 16 >> 2] = 0;
    HEAP32[$2 - 20 >> 2] = 0;
    HEAP32[$2 - 24 >> 2] = 0;
    HEAP32[$2 - 28 >> 2] = 0;
    $2 = $1;
    $1 = $3 & 4 | 24;
    $2 = $2 - $1 | 0;
    if ($2 >>> 0 < 32) {
     break block
    }
    $4 = __wasm_i64_mul(0, 0, 1, 1);
    $5 = i64toi32_i32$HIGH_BITS;
    $1 = $1 + $3 | 0;
    while (1) {
     HEAP32[$1 + 24 >> 2] = $4;
     HEAP32[$1 + 28 >> 2] = $5;
     HEAP32[$1 + 16 >> 2] = $4;
     HEAP32[$1 + 20 >> 2] = $5;
     HEAP32[$1 + 8 >> 2] = $4;
     HEAP32[$1 + 12 >> 2] = $5;
     HEAP32[$1 >> 2] = $4;
     HEAP32[$1 + 4 >> 2] = $5;
     $1 = $1 + 32 | 0;
     $2 = $2 - 32 | 0;
     if ($2 >>> 0 > 31) {
      continue
     }
     break;
    };
   }
  }
  return $0;
 }
 
 function frexp($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  wasm2js_scratch_store_f64(+$0);
  $3 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  $2 = $3 >>> 20 & 2047;
  if (($2 | 0) != 2047) {
   if (!$2) {
    if ($0 == 0.0) {
     $2 = 0
    } else {
     $0 = frexp($0 * 18446744073709551615.0, $1);
     $2 = HEAP32[$1 >> 2] + -64 | 0;
    }
    HEAP32[$1 >> 2] = $2;
    return $0;
   }
   HEAP32[$1 >> 2] = $2 - 1022;
   wasm2js_scratch_store_i32(0, $4 | 0);
   wasm2js_scratch_store_i32(1, $3 & -2146435073 | 1071644672);
   $0 = +wasm2js_scratch_load_f64();
  }
  return $0;
 }
 
 function __ashlti3($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  block1 : {
   if ($5 & 64) {
    $4 = $5 + -64 | 0;
    $5 = $1;
    $3 = $4 & 31;
    if (($4 & 63) >>> 0 >= 32) {
     $4 = $5 << $3;
     $3 = 0;
    } else {
     $4 = (1 << $3) - 1 & $5 >>> 32 - $3 | $2 << $3;
     $3 = $5 << $3;
    }
    $1 = 0;
    $2 = 0;
    break block1;
   }
   if (!$5) {
    break block1
   }
   $7 = $1;
   $8 = 64 - $5 | 0;
   $6 = $8 & 31;
   if (($8 & 63) >>> 0 >= 32) {
    $8 = 0;
    $9 = $2 >>> $6 | 0;
   } else {
    $8 = $2 >>> $6 | 0;
    $9 = ((1 << $6) - 1 & $2) << 32 - $6 | $7 >>> $6;
   }
   $7 = $3;
   $6 = $5 & 31;
   if (($5 & 63) >>> 0 >= 32) {
    $4 = $3 << $6;
    $3 = 0;
   } else {
    $4 = (1 << $6) - 1 & $7 >>> 32 - $6 | $4 << $6;
    $3 = $7 << $6;
   }
   $3 = $9 | $3;
   $4 = $4 | $8;
   $7 = $1;
   $6 = $5 & 31;
   if (($5 & 63) >>> 0 >= 32) {
    $8 = $7 << $6;
    $1 = 0;
   } else {
    $8 = (1 << $6) - 1 & $7 >>> 32 - $6 | $2 << $6;
    $1 = $7 << $6;
   }
   $2 = $8;
  }
  HEAP32[$0 >> 2] = $1;
  HEAP32[$0 + 4 >> 2] = $2;
  HEAP32[$0 + 8 >> 2] = $3;
  HEAP32[$0 + 12 >> 2] = $4;
 }
 
 function __lshrti3($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  block1 : {
   if ($5 & 64) {
    $2 = $5 + -64 | 0;
    $1 = $2 & 31;
    if (($2 & 63) >>> 0 >= 32) {
     $2 = 0;
     $1 = $4 >>> $1 | 0;
    } else {
     $2 = $4 >>> $1 | 0;
     $1 = ((1 << $1) - 1 & $4) << 32 - $1 | $3 >>> $1;
    }
    $3 = 0;
    $4 = 0;
    break block1;
   }
   if (!$5) {
    break block1
   }
   $8 = $3;
   $7 = 64 - $5 | 0;
   $6 = $7 & 31;
   if (($7 & 63) >>> 0 >= 32) {
    $7 = $3 << $6;
    $9 = 0;
   } else {
    $7 = (1 << $6) - 1 & $8 >>> 32 - $6 | $4 << $6;
    $9 = $8 << $6;
   }
   $8 = $1;
   $1 = $5 & 31;
   if (($5 & 63) >>> 0 >= 32) {
    $6 = 0;
    $1 = $2 >>> $1 | 0;
   } else {
    $6 = $2 >>> $1 | 0;
    $1 = ((1 << $1) - 1 & $2) << 32 - $1 | $8 >>> $1;
   }
   $1 = $9 | $1;
   $2 = $6 | $7;
   $6 = $3;
   $3 = $5 & 31;
   if (($5 & 63) >>> 0 >= 32) {
    $7 = 0;
    $3 = $4 >>> $3 | 0;
   } else {
    $7 = $4 >>> $3 | 0;
    $3 = ((1 << $3) - 1 & $4) << 32 - $3 | $6 >>> $3;
   }
   $4 = $7;
  }
  HEAP32[$0 >> 2] = $1;
  HEAP32[$0 + 4 >> 2] = $2;
  HEAP32[$0 + 8 >> 2] = $3;
  HEAP32[$0 + 12 >> 2] = $4;
 }
 
 function FLAC__crc8($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  block1 : {
   if (!$1) {
    break block1
   }
   $3 = $1 & 3;
   block3 : {
    if ($1 >>> 0 < 4) {
     $1 = $0;
     break block3;
    }
    $6 = $1 & -4;
    while (1) {
     $2 = HEAPU8[(HEAPU8[$0 + 3 | 0] ^ HEAPU8[(HEAPU8[$0 + 2 | 0] ^ HEAPU8[(HEAPU8[$0 + 1 | 0] ^ HEAPU8[($2 ^ HEAPU8[$0 | 0]) + 1024 | 0]) + 1024 | 0]) + 1024 | 0]) + 1024 | 0];
     $1 = $0 + 4 | 0;
     $0 = $1;
     $4 = $4 + 4 | 0;
     if (($4 | 0) != ($6 | 0)) {
      continue
     }
     break;
    };
   }
   if (!$3) {
    break block1
   }
   while (1) {
    $2 = HEAPU8[(HEAPU8[$1 | 0] ^ $2) + 1024 | 0];
    $1 = $1 + 1 | 0;
    $5 = $5 + 1 | 0;
    if (($5 | 0) != ($3 | 0)) {
     continue
    }
    break;
   };
  }
  return $2;
 }
 
 function FLAC__crc16_update_words32($0, $1, $2) {
  var $3 = 0;
  if ($1 >>> 0 >= 2) {
   while (1) {
    $3 = $2;
    $2 = HEAP32[$0 >> 2];
    $3 = $3 ^ $2 >>> 16;
    $3 = HEAPU16[((($3 & 255) << 1) + 1280 | 0) + 3072 >> 1] ^ HEAPU16[(($3 >>> 7 & 510) + 1280 | 0) + 3584 >> 1] ^ HEAPU16[(($2 >>> 7 & 510) + 1280 | 0) + 2560 >> 1] ^ HEAPU16[((($2 & 255) << 1) + 1280 | 0) + 2048 >> 1];
    $2 = HEAP32[$0 + 4 >> 2];
    $2 = $3 ^ HEAPU16[(($2 >>> 23 & 510) + 1280 | 0) + 1536 >> 1] ^ HEAPU16[(($2 >>> 15 & 510) + 1280 | 0) + 1024 >> 1] ^ HEAPU16[(($2 >>> 7 & 510) + 1280 | 0) + 512 >> 1] ^ HEAPU16[(($2 & 255) << 1) + 1280 >> 1];
    $0 = $0 + 8 | 0;
    $1 = $1 - 2 | 0;
    if ($1 >>> 0 > 1) {
     continue
    }
    break;
   }
  }
  if ($1) {
   $0 = HEAP32[$0 >> 2];
   $1 = $0 >>> 16 ^ $2;
   $2 = HEAPU16[((($1 & 255) << 1) + 1280 | 0) + 1024 >> 1] ^ HEAPU16[(($1 >>> 7 & 510) + 1280 | 0) + 1536 >> 1] ^ HEAPU16[(($0 >>> 7 & 510) + 1280 | 0) + 512 >> 1] ^ HEAPU16[(($0 & 255) << 1) + 1280 >> 1];
  }
  return $2 & 65535;
 }
 
 function FLAC__bitreader_delete($0) {
  var $1 = 0;
  $1 = HEAP32[$0 >> 2];
  if ($1) {
   emscripten_builtin_free($1)
  }
  emscripten_builtin_free($0);
 }
 
 function FLAC__bitreader_is_consumed_byte_aligned($0) {
  return !(HEAPU8[$0 + 20 | 0] & 7);
 }
 
 function FLAC__bitreader_bits_left_for_byte_alignment($0) {
  return 8 - (HEAP32[$0 + 20 >> 2] & 7) | 0;
 }
 
 function FLAC__bitreader_read_raw_uint32($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  block6 : {
   if ($2) {
    block1 : {
     while (1) {
      $5 = HEAP32[$0 + 8 >> 2];
      $4 = HEAP32[$0 + 16 >> 2];
      $3 = HEAP32[$0 + 20 >> 2];
      if ((($5 - $4 << 5) + (HEAP32[$0 + 12 >> 2] << 3) | 0) - $3 >>> 0 >= $2 >>> 0) {
       break block1
      }
      if (bitreader_read_from_client_($0)) {
       continue
      }
      break;
     };
     return 0;
    }
    if ($4 >>> 0 < $5 >>> 0) {
     if ($3) {
      $5 = HEAP32[$0 >> 2];
      $4 = HEAP32[$5 + ($4 << 2) >> 2] & -1 >>> $3;
      $3 = 32 - $3 | 0;
      if ($2 >>> 0 < $3 >>> 0) {
       HEAP32[$1 >> 2] = $4 >>> $3 - $2;
       HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + $2;
       break block6;
      }
      HEAP32[$1 >> 2] = $4;
      HEAP32[$0 + 20 >> 2] = 0;
      HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 1;
      if (($2 | 0) == ($3 | 0)) {
       break block6
      }
      $2 = $2 - $3 | 0;
      $3 = HEAP32[$1 >> 2] << $2;
      HEAP32[$1 >> 2] = $3;
      HEAP32[$1 >> 2] = $3 | HEAP32[(HEAP32[$0 + 16 >> 2] << 2) + $5 >> 2] >>> 32 - $2;
      HEAP32[$0 + 20 >> 2] = $2;
      return 1;
     }
     $3 = HEAP32[HEAP32[$0 >> 2] + ($4 << 2) >> 2];
     if ($2 >>> 0 <= 31) {
      HEAP32[$1 >> 2] = $3 >>> 32 - $2;
      HEAP32[$0 + 20 >> 2] = $2;
      break block6;
     }
     HEAP32[$1 >> 2] = $3;
     HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 1;
     return 1;
    }
    $4 = HEAP32[HEAP32[$0 >> 2] + ($4 << 2) >> 2];
    if ($3) {
     HEAP32[$1 >> 2] = ($4 & -1 >>> $3) >>> 32 - ($2 + $3 | 0);
     HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + $2;
     break block6;
    }
    HEAP32[$1 >> 2] = $4 >>> 32 - $2;
    HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + $2;
    break block6;
   }
   HEAP32[$1 >> 2] = 0;
  }
  return 1;
 }
 
 function bitreader_read_from_client_($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  $9 = __stack_pointer - 16 | 0;
  __stack_pointer = $9;
  $7 = HEAP32[$0 + 16 >> 2];
  block1 : {
   if (!$7) {
    $2 = HEAP32[$0 + 8 >> 2];
    break block1;
   }
   $1 = HEAP32[$0 + 28 >> 2];
   block3 : {
    if ($7 >>> 0 <= $1 >>> 0) {
     $8 = HEAP32[$0 >> 2];
     $2 = $1;
     break block3;
    }
    $8 = HEAP32[$0 >> 2];
    $4 = HEAP32[$0 + 32 >> 2];
    if (!$4) {
     $2 = $1;
     break block3;
    }
    $2 = $1 + 1 | 0;
    HEAP32[$0 + 28 >> 2] = $2;
    $3 = HEAP32[$0 + 24 >> 2];
    block5 : {
     if ($4 >>> 0 > 31) {
      break block5
     }
     $1 = HEAP32[($1 << 2) + $8 >> 2];
     $6 = HEAPU16[(($1 >>> 24 - $4 & 255 ^ $3 >>> 8) << 1) + 1280 >> 1];
     $3 = $6 ^ $3 << 8 & 65280;
     if ($4 >>> 0 > 23) {
      break block5
     }
     $5 = $6 << 8 & 65280;
     $6 = HEAPU16[(($1 >>> 16 - $4 & 255 ^ $3 >>> 8) << 1) + 1280 >> 1];
     $3 = $5 ^ $6;
     if ($4 >>> 0 > 15) {
      break block5
     }
     $5 = $6 << 8 & 65280;
     $6 = HEAPU16[(($1 >>> 8 - $4 & 255 ^ $3 >>> 8) << 1) + 1280 >> 1];
     $3 = $5 ^ $6;
     if (($4 | 16) >>> 0 > 23) {
      break block5
     }
     $3 = HEAPU16[(($1 >>> 0 - $4 & 255 ^ $3 >>> 8) << 1) + 1280 >> 1] ^ $6 << 8 & 65280;
    }
    HEAP32[$0 + 32 >> 2] = 0;
    HEAP32[$0 + 24 >> 2] = $3;
   }
   $2 = FLAC__crc16_update_words32(($2 << 2) + $8 | 0, $7 - $2 | 0, HEAPU16[$0 + 24 >> 1]);
   HEAP32[$0 + 28 >> 2] = 0;
   HEAP32[$0 + 24 >> 2] = $2;
   $2 = HEAP32[$0 + 16 >> 2];
   $1 = (HEAP32[$0 + 8 >> 2] - $2 | 0) + (HEAP32[$0 + 12 >> 2] != 0) << 2;
   if ($1) {
    $3 = HEAP32[$0 >> 2];
    wasm2js_memory_copy($3, $3 + ($2 << 2) | 0, $1);
   }
   HEAP32[$0 + 16 >> 2] = 0;
   $2 = HEAP32[$0 + 8 >> 2] - $2 | 0;
   HEAP32[$0 + 8 >> 2] = $2;
  }
  $4 = HEAP32[$0 + 4 >> 2] - $2 << 2;
  $1 = HEAP32[$0 + 12 >> 2];
  HEAP32[$9 + 12 >> 2] = $4 - $1;
  $3 = 0;
  block7 : {
   if (($1 | 0) == ($4 | 0)) {
    break block7
   }
   $2 = HEAP32[$0 >> 2] + ($2 << 2) | 0;
   $4 = $2 + $1 | 0;
   if ($1) {
    $1 = $2;
    $2 = HEAP32[$2 >> 2];
    HEAP32[$1 >> 2] = $2 << 24 | ($2 & 65280) << 8 | ($2 >>> 8 & 65280 | $2 >>> 24);
   }
   if (!(FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]]($4, $9 + 12 | 0, HEAP32[$0 + 40 >> 2]) | 0)) {
    break block7
   }
   $6 = HEAP32[$9 + 12 >> 2];
   $2 = HEAP32[$0 + 12 >> 2];
   $1 = HEAP32[$0 + 8 >> 2];
   $8 = ($6 + ($2 + ($1 << 2) | 0) | 0) + 3 >>> 2 | 0;
   if ($1 >>> 0 < $8 >>> 0) {
    $4 = HEAP32[$0 >> 2];
    $2 = $1;
    $10 = $8 - $1 & 3;
    if ($10) {
     while (1) {
      $11 = $4 + ($2 << 2) | 0;
      $7 = HEAP32[$11 >> 2];
      HEAP32[$11 >> 2] = $7 << 24 | ($7 & 65280) << 8 | ($7 >>> 8 & 65280 | $7 >>> 24);
      $2 = $2 + 1 | 0;
      $3 = $3 + 1 | 0;
      if (($10 | 0) != ($3 | 0)) {
       continue
      }
      break;
     }
    }
    if ($1 - $8 >>> 0 <= 4294967292) {
     $7 = $4 + 12 | 0;
     $10 = $4 + 8 | 0;
     $11 = $4 + 4 | 0;
     while (1) {
      $3 = $2 << 2;
      $5 = $3 + $4 | 0;
      $1 = HEAP32[$5 >> 2];
      HEAP32[$5 >> 2] = $1 << 24 | ($1 & 65280) << 8 | ($1 >>> 8 & 65280 | $1 >>> 24);
      $5 = $3 + $11 | 0;
      $1 = HEAP32[$5 >> 2];
      HEAP32[$5 >> 2] = $1 << 24 | ($1 & 65280) << 8 | ($1 >>> 8 & 65280 | $1 >>> 24);
      $5 = $3 + $10 | 0;
      $1 = HEAP32[$5 >> 2];
      HEAP32[$5 >> 2] = $1 << 24 | ($1 & 65280) << 8 | ($1 >>> 8 & 65280 | $1 >>> 24);
      $3 = $3 + $7 | 0;
      $1 = HEAP32[$3 >> 2];
      HEAP32[$3 >> 2] = $1 << 24 | ($1 & 65280) << 8 | ($1 >>> 8 & 65280 | $1 >>> 24);
      $2 = $2 + 4 | 0;
      if (($8 | 0) != ($2 | 0)) {
       continue
      }
      break;
     };
    }
    $2 = HEAP32[$0 + 12 >> 2];
    $1 = HEAP32[$0 + 8 >> 2];
   }
   $2 = $2 + $6 | 0;
   HEAP32[$0 + 12 >> 2] = $2 & 3;
   HEAP32[$0 + 8 >> 2] = ($2 >>> 2 | 0) + $1 & 1073741823;
   $3 = 1;
  }
  __stack_pointer = $9 + 16 | 0;
  return $3;
 }
 
 function FLAC__bitreader_read_raw_int32($0, $1, $2) {
  var $3 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  if (FLAC__bitreader_read_raw_uint32($0, $3 + 12 | 0, $2)) {
   $0 = $1;
   $1 = 1 << $2 - 1;
   HEAP32[$0 >> 2] = ($1 ^ HEAP32[$3 + 12 >> 2]) - $1;
   $0 = 1;
  } else {
   $0 = 0
  }
  __stack_pointer = $3 + 16 | 0;
  return $0;
 }
 
 function FLAC__bitreader_read_raw_uint64($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  block1 : {
   block2 : {
    if ($2 >>> 0 >= 33) {
     if (!FLAC__bitreader_read_raw_uint32($0, $3 + 12 | 0, $2 - 32 | 0)) {
      break block1
     }
     if (!FLAC__bitreader_read_raw_uint32($0, $3 + 8 | 0, 32)) {
      break block1
     }
     $2 = HEAP32[$3 + 8 >> 2];
     $0 = HEAP32[$3 + 12 >> 2];
     break block2;
    }
    if (!FLAC__bitreader_read_raw_uint32($0, $3 + 8 | 0, $2)) {
     break block1
    }
    $2 = HEAP32[$3 + 8 >> 2];
    $0 = 0;
   }
   HEAP32[$1 >> 2] = $2;
   HEAP32[$1 + 4 >> 2] = $0;
   $4 = 1;
  }
  __stack_pointer = $3 + 16 | 0;
  return $4;
 }
 
 function FLAC__bitreader_read_uint32_little_endian($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  HEAP32[$2 + 8 >> 2] = 0;
  block : {
   if (!FLAC__bitreader_read_raw_uint32($0, $2 + 8 | 0, 8)) {
    break block
   }
   $3 = $2 + 12 | 0;
   if (!FLAC__bitreader_read_raw_uint32($0, $3, 8)) {
    break block
   }
   $4 = HEAP32[$2 + 8 >> 2];
   $5 = HEAP32[$2 + 12 >> 2];
   if (!FLAC__bitreader_read_raw_uint32($0, $3, 8)) {
    break block
   }
   $6 = HEAP32[$2 + 12 >> 2];
   if (!FLAC__bitreader_read_raw_uint32($0, $3, 8)) {
    break block
   }
   HEAP32[$1 >> 2] = $5 << 8 | $4 | $6 << 16 | HEAP32[$2 + 12 >> 2] << 24;
   $7 = 1;
  }
  __stack_pointer = $2 + 16 | 0;
  return $7;
 }
 
 function FLAC__bitreader_skip_bits_no_crc($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  block3 : {
   block : {
    if (!$1) {
     break block
    }
    $2 = HEAP32[$0 + 20 >> 2] & 7;
    if ($2) {
     $2 = 8 - $2 | 0;
     $2 = $1 >>> 0 > $2 >>> 0 ? $2 : $1;
     $3 = 0;
     if (!FLAC__bitreader_read_raw_uint32($0, $4 + 8 | 0, $2)) {
      break block3
     }
     $1 = $1 - $2 | 0;
    }
    block9 : {
     if ($1 >>> 0 >= 8) {
      $2 = $1 >>> 3 | 0;
      while (1) {
       block10 : {
        if (!HEAP32[$0 + 20 >> 2]) {
         if ($2 >>> 0 > 3) {
          while (1) {
           $3 = HEAP32[$0 + 16 >> 2];
           block8 : {
            if ($3 >>> 0 < HEAPU32[$0 + 8 >> 2]) {
             HEAP32[$0 + 16 >> 2] = $3 + 1;
             $2 = $2 - 4 | 0;
             break block8;
            }
            if (!bitreader_read_from_client_($0)) {
             break block9
            }
           }
           if ($2 >>> 0 > 3) {
            continue
           }
           break;
          };
          if (!$2) {
           break block10
          }
         }
         while (1) {
          if (!FLAC__bitreader_read_raw_uint32($0, $4 + 12 | 0, 8)) {
           break block9
          }
          $2 = $2 - 1 | 0;
          if ($2) {
           continue
          }
          break;
         };
         break block10;
        }
        if (!FLAC__bitreader_read_raw_uint32($0, $4 + 12 | 0, 8)) {
         break block9
        }
        $2 = $2 - 1 | 0;
        if ($2) {
         continue
        }
       }
       break;
      };
      $1 = $1 & 7;
     }
     if (!$1) {
      break block
     }
     if (FLAC__bitreader_read_raw_uint32($0, $4 + 8 | 0, $1)) {
      break block
     }
     $3 = 0;
     break block3;
    }
    $3 = 0;
    break block3;
   }
   $3 = 1;
  }
  $0 = $3;
  __stack_pointer = $4 + 16 | 0;
  return $0;
 }
 
 function FLAC__bitreader_skip_byte_block_aligned_no_crc($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  $3 = 1;
  block : {
   if (!$1) {
    break block
   }
   while (1) {
    block5 : {
     if (!HEAP32[$0 + 20 >> 2]) {
      block2 : {
       if ($1 >>> 0 < 4) {
        break block2
       }
       while (1) {
        $4 = HEAP32[$0 + 16 >> 2];
        block4 : {
         if ($4 >>> 0 < HEAPU32[$0 + 8 >> 2]) {
          HEAP32[$0 + 16 >> 2] = $4 + 1;
          $1 = $1 - 4 | 0;
          break block4;
         }
         if (!bitreader_read_from_client_($0)) {
          break block5
         }
        }
        if ($1 >>> 0 > 3) {
         continue
        }
        break;
       };
       if ($1) {
        break block2
       }
       break block;
      }
      while (1) {
       if (!FLAC__bitreader_read_raw_uint32($0, $2 + 12 | 0, 8)) {
        break block5
       }
       $1 = $1 - 1 | 0;
       if ($1) {
        continue
       }
       break;
      };
      break block;
     }
     if (!FLAC__bitreader_read_raw_uint32($0, $2 + 12 | 0, 8)) {
      break block5
     }
     $1 = $1 - 1 | 0;
     if ($1) {
      continue
     }
     break block;
    }
    break;
   };
   $3 = 0;
  }
  __stack_pointer = $2 + 16 | 0;
  return $3;
 }
 
 function FLAC__bitreader_read_byte_block_aligned_no_crc($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  block1 : {
   if (!$2) {
    $3 = 1;
    break block1;
   }
   while (1) {
    if (!HEAP32[$0 + 20 >> 2]) {
     block3 : {
      if ($2 >>> 0 < 4) {
       break block3
      }
      while (1) {
       block5 : {
        $3 = HEAP32[$0 + 16 >> 2];
        if ($3 >>> 0 < HEAPU32[$0 + 8 >> 2]) {
         HEAP32[$0 + 16 >> 2] = $3 + 1;
         $3 = HEAP32[HEAP32[$0 >> 2] + ($3 << 2) >> 2];
         $3 = $3 << 24 | ($3 & 65280) << 8 | ($3 >>> 8 & 65280 | $3 >>> 24);
         HEAP8[$1 | 0] = $3;
         HEAP8[$1 + 1 | 0] = $3 >>> 8;
         HEAP8[$1 + 2 | 0] = $3 >>> 16;
         HEAP8[$1 + 3 | 0] = $3 >>> 24;
         $2 = $2 - 4 | 0;
         $1 = $1 + 4 | 0;
         break block5;
        }
        if (bitreader_read_from_client_($0)) {
         break block5
        }
        $3 = 0;
        break block1;
       }
       if ($2 >>> 0 > 3) {
        continue
       }
       break;
      };
      if ($2) {
       break block3
      }
      $3 = 1;
      break block1;
     }
     while (1) {
      if (!FLAC__bitreader_read_raw_uint32($0, $4 + 12 | 0, 8)) {
       $3 = 0;
       break block1;
      }
      HEAP8[$1 | 0] = HEAP32[$4 + 12 >> 2];
      $3 = 1;
      $1 = $1 + 1 | 0;
      $2 = $2 - 1 | 0;
      if ($2) {
       continue
      }
      break;
     };
     break block1;
    }
    if (!FLAC__bitreader_read_raw_uint32($0, $4 + 12 | 0, 8)) {
     $3 = 0;
     break block1;
    }
    HEAP8[$1 | 0] = HEAP32[$4 + 12 >> 2];
    $3 = 1;
    $1 = $1 + 1 | 0;
    $2 = $2 - 1 | 0;
    if ($2) {
     continue
    }
    break;
   };
  }
  __stack_pointer = $4 + 16 | 0;
  return $3;
 }
 
 function FLAC__bitreader_read_unary_unsigned($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  HEAP32[$1 >> 2] = 0;
  block5 : {
   block4 : {
    block1 : {
     block3 : {
      while (1) {
       $4 = HEAP32[$0 + 20 >> 2];
       $2 = HEAP32[$0 + 16 >> 2];
       block : {
        if ($2 >>> 0 >= HEAPU32[$0 + 8 >> 2]) {
         break block
        }
        $3 = HEAP32[$0 >> 2];
        $2 = HEAP32[$3 + ($2 << 2) >> 2] << $4;
        if ($2) {
         break block1
        }
        HEAP32[$1 >> 2] = (HEAP32[$1 >> 2] - $4 | 0) + 32;
        $4 = 0;
        HEAP32[$0 + 20 >> 2] = 0;
        $2 = HEAP32[$0 + 16 >> 2] + 1 | 0;
        HEAP32[$0 + 16 >> 2] = $2;
        if (HEAPU32[$0 + 8 >> 2] <= $2 >>> 0) {
         break block
        }
        while (1) {
         $2 = HEAP32[$3 + ($2 << 2) >> 2];
         if ($2) {
          break block1
         }
         HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 32;
         HEAP32[$0 + 20 >> 2] = 0;
         $2 = HEAP32[$0 + 16 >> 2] + 1 | 0;
         HEAP32[$0 + 16 >> 2] = $2;
         if (HEAPU32[$0 + 8 >> 2] > $2 >>> 0) {
          continue
         }
         break;
        };
       }
       $3 = HEAP32[$0 + 12 >> 2] << 3;
       if ($4 >>> 0 < $3 >>> 0) {
        $5 = HEAP32[$1 >> 2];
        $2 = (HEAP32[HEAP32[$0 >> 2] + ($2 << 2) >> 2] & -1 << 32 - $3) << $4;
        if ($2) {
         break block3
        }
        HEAP32[$1 >> 2] = ($3 - $4 | 0) + $5;
        HEAP32[$0 + 20 >> 2] = $3;
       }
       if (bitreader_read_from_client_($0)) {
        continue
       }
       break;
      };
      return 0;
     }
     $3 = $1;
     $1 = Math_clz32($2);
     HEAP32[$3 >> 2] = $1 + $5;
     $1 = ($1 + HEAP32[$0 + 20 >> 2] | 0) + 1 | 0;
     break block4;
    }
    $3 = $1;
    $4 = HEAP32[$1 >> 2];
    $1 = Math_clz32($2);
    HEAP32[$3 >> 2] = $4 + $1;
    $1 = ($1 + HEAP32[$0 + 20 >> 2] | 0) + 1 | 0;
    HEAP32[$0 + 20 >> 2] = $1;
    if ($1 >>> 0 < 32) {
     break block5
    }
    HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 1;
    $1 = 0;
   }
   HEAP32[$0 + 20 >> 2] = $1;
  }
  return 1;
 }
 
 function sift($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  $5 = __stack_pointer - 240 | 0;
  __stack_pointer = $5;
  HEAP32[$5 >> 2] = $0;
  $6 = 1;
  block : {
   if (($1 | 0) < 2) {
    break block
   }
   $3 = $0;
   while (1) {
    $3 = $3 - 24 | 0;
    $7 = $1 - 2 | 0;
    $4 = $3 - HEAP32[($7 << 2) + $2 >> 2] | 0;
    if ((FUNCTION_TABLE[1]($0, $4, 2) | 0) >= 0) {
     if ((FUNCTION_TABLE[1]($0, $3, 2) | 0) >= 0) {
      break block
     }
    }
    $8 = $4;
    $4 = (FUNCTION_TABLE[1]($4, $3, 2) | 0) >= 0;
    $3 = $4 ? $8 : $3;
    HEAP32[($6 << 2) + $5 >> 2] = $3;
    $6 = $6 + 1 | 0;
    $1 = $4 ? $1 - 1 | 0 : $7;
    if (($1 | 0) > 1) {
     continue
    }
    break;
   };
  }
  cycle($5, $6);
  __stack_pointer = $5 + 240 | 0;
 }
 
 function shr($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = HEAP32[$0 + 4 >> 2];
  block1 : {
   if ($1 >>> 0 <= 31) {
    $3 = HEAP32[$0 >> 2];
    break block1;
   }
   $1 = $1 - 32 | 0;
   $3 = $2;
   $2 = 0;
  }
  HEAP32[$0 + 4 >> 2] = $2 >>> $1;
  HEAP32[$0 >> 2] = $2 << 32 - $1 | $3 >>> $1;
 }
 
 function trinkle($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  $6 = __stack_pointer - 240 | 0;
  __stack_pointer = $6;
  $5 = HEAP32[$1 >> 2];
  HEAP32[$6 + 232 >> 2] = $5;
  $1 = HEAP32[$1 + 4 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 236 >> 2] = $1;
  $9 = !$3;
  block7 : {
   block6 : {
    block2 : {
     block1 : {
      if (($5 | 0) != 1) {
       $5 = $0;
       $3 = 1;
       break block1;
      }
      $5 = $0;
      $3 = 1;
      if ($1) {
       break block1
      }
      break block2;
     }
     while (1) {
      $7 = ($2 << 2) + $4 | 0;
      $1 = $5 - HEAP32[$7 >> 2] | 0;
      if ((FUNCTION_TABLE[1]($1, $0, 2) | 0) <= 0) {
       break block2
      }
      $8 = $9 ^ -1;
      $9 = 1;
      block5 : {
       if (!(($8 | ($2 | 0) < 2) & 1)) {
        $7 = HEAP32[$7 - 8 >> 2];
        $8 = $5 - 24 | 0;
        if ((FUNCTION_TABLE[1]($8, $1, 2) | 0) >= 0) {
         break block5
        }
        if ((FUNCTION_TABLE[1]($8 - $7 | 0, $1, 2) | 0) >= 0) {
         break block5
        }
       }
       HEAP32[($3 << 2) + $6 >> 2] = $1;
       $5 = $6 + 232 | 0;
       $7 = $5;
       $5 = pntz($5);
       shr($7, $5);
       $3 = $3 + 1 | 0;
       $2 = $2 + $5 | 0;
       $5 = $1;
       if (HEAP32[$6 + 236 >> 2] | HEAP32[$6 + 232 >> 2] != 1) {
        continue
       }
       break block6;
      }
      break;
     };
     $1 = $5;
     break block6;
    }
    $1 = $5;
    if (!$9) {
     break block7
    }
   }
   cycle($6, $3);
   sift($1, $2, $4);
  }
  __stack_pointer = $6 + 240 | 0;
 }
 
 function shl($0, $1) {
  var $2 = 0, $3 = 0;
  block1 : {
   if ($1 >>> 0 <= 31) {
    $3 = HEAP32[$0 >> 2];
    $2 = $0 + 4 | 0;
    break block1;
   }
   $1 = $1 - 32 | 0;
   $2 = $0;
  }
  $2 = HEAP32[$2 >> 2];
  HEAP32[$0 >> 2] = $3 << $1;
  HEAP32[$0 + 4 >> 2] = $2 << $1 | $3 >>> 32 - $1;
 }
 
 function pntz($0) {
  var $1 = 0;
  $1 = a_ctz_32(HEAP32[$0 >> 2] - 1 | 0);
  if (!$1) {
   $0 = a_ctz_32(HEAP32[$0 + 4 >> 2]);
   $1 = $0 ? $0 | 32 : 0;
  }
  return $1;
 }
 
 function cycle($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  $2 = 24;
  $5 = __stack_pointer - 256 | 0;
  __stack_pointer = $5;
  if (($1 | 0) >= 2) {
   $7 = ($1 << 2) + $0 | 0;
   HEAP32[$7 >> 2] = $5;
   while (1) {
    $4 = $2 >>> 0 >= 256 ? 256 : $2;
    __memcpy(HEAP32[$7 >> 2], HEAP32[$0 >> 2], $4);
    $3 = 0;
    while (1) {
     $6 = ($3 << 2) + $0 | 0;
     $3 = $3 + 1 | 0;
     __memcpy(HEAP32[$6 >> 2], HEAP32[($3 << 2) + $0 >> 2], $4);
     HEAP32[$6 >> 2] = HEAP32[$6 >> 2] + $4;
     if (($1 | 0) != ($3 | 0)) {
      continue
     }
     break;
    };
    $2 = $2 - $4 | 0;
    if ($2) {
     continue
    }
    break;
   };
  }
  __stack_pointer = $5 + 256 | 0;
 }
 
 function a_ctz_32($0) {
  var wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
  return wasm2js_i32$0 = __wasm_ctz_i32($0), wasm2js_i32$1 = 0, wasm2js_i32$2 = $0, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1;
 }
 
 function wrapper_cmp($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  return FUNCTION_TABLE[$2 | 0]($0, $1) | 0;
 }
 
 function FLAC__format_seektable_sort($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  block : {
   $3 = HEAP32[$0 >> 2];
   if (!$3) {
    break block
   }
   $5 = HEAP32[$0 + 4 >> 2];
   $1 = __stack_pointer - 208 | 0;
   __stack_pointer = $1;
   HEAP32[$1 + 8 >> 2] = 1;
   HEAP32[$1 + 12 >> 2] = 0;
   $6 = Math_imul($3, 24);
   block0 : {
    if (!$6) {
     break block0
    }
    HEAP32[$1 + 16 >> 2] = 24;
    HEAP32[$1 + 20 >> 2] = 24;
    $3 = 24;
    $2 = $3;
    $4 = 2;
    while (1) {
     $7 = $2 + 24 | 0;
     $2 = $3;
     $3 = $2 + $7 | 0;
     HEAP32[($1 + 16 | 0) + ($4 << 2) >> 2] = $3;
     $4 = $4 + 1 | 0;
     if ($3 >>> 0 < $6 >>> 0) {
      continue
     }
     break;
    };
    $2 = ($5 + $6 | 0) - 24 | 0;
    block2 : {
     if ($5 >>> 0 >= $2 >>> 0) {
      $3 = 1;
      break block2;
     }
     $4 = 1;
     $3 = 1;
     while (1) {
      block4 : {
       if (($4 & 3) == 3) {
        sift($5, $3, $1 + 16 | 0);
        shr($1 + 8 | 0, 2);
        $3 = $3 + 2 | 0;
        break block4;
       }
       $4 = $1 + 16 | 0;
       $6 = $3 - 1 | 0;
       block6 : {
        if (HEAPU32[$4 + ($6 << 2) >> 2] >= $2 - $5 >>> 0) {
         trinkle($5, $1 + 8 | 0, $3, 0, $4);
         break block6;
        }
        sift($5, $3, $1 + 16 | 0);
       }
       if (($3 | 0) == 1) {
        shl($1 + 8 | 0, 1);
        $3 = 0;
        break block4;
       }
       shl($1 + 8 | 0, $6);
       $3 = 1;
      }
      $4 = HEAP32[$1 + 8 >> 2] | 1;
      HEAP32[$1 + 8 >> 2] = $4;
      $5 = $5 + 24 | 0;
      if ($2 >>> 0 > $5 >>> 0) {
       continue
      }
      break;
     };
    }
    trinkle($5, $1 + 8 | 0, $3, 0, $1 + 16 | 0);
    if (!(HEAP32[$1 + 12 >> 2] | (($3 | 0) != 1 | HEAP32[$1 + 8 >> 2] != 1))) {
     break block0
    }
    while (1) {
     block10 : {
      if (($3 | 0) <= 1) {
       $2 = $1 + 8 | 0;
       $6 = $2;
       $2 = pntz($2);
       shr($6, $2);
       $3 = $3 + $2 | 0;
       break block10;
      }
      $2 = $1 + 8 | 0;
      shl($2, 2);
      HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] ^ 7;
      shr($2, 1);
      $7 = $5 - 24 | 0;
      $4 = $1 + 16 | 0;
      $6 = $3 - 2 | 0;
      trinkle($7 - HEAP32[$4 + ($6 << 2) >> 2] | 0, $2, $3 - 1 | 0, 1, $4);
      shl($2, 1);
      HEAP32[$1 + 8 >> 2] = HEAP32[$1 + 8 >> 2] | 1;
      trinkle($7, $2, $6, 1, $4);
      $3 = $6;
     }
     $5 = $5 - 24 | 0;
     if (HEAP32[$1 + 12 >> 2] | (($3 | 0) != 1 | HEAP32[$1 + 8 >> 2] != 1)) {
      continue
     }
     break;
    };
   }
   __stack_pointer = $1 + 208 | 0;
   if (!HEAP32[$0 >> 2]) {
    break block
   }
   $2 = 1;
   $1 = HEAP32[$0 >> 2];
   if ($1 >>> 0 > 1) {
    $3 = 1;
    while (1) {
     $4 = HEAP32[$0 + 4 >> 2];
     $5 = $4 + Math_imul($3, 24) | 0;
     $6 = HEAP32[$5 >> 2];
     $7 = HEAP32[$5 + 4 >> 2];
     block3 : {
      if (($6 & $7) != -1) {
       $8 = ($4 + Math_imul($2, 24) | 0) - 24 | 0;
       if (($6 | 0) == HEAP32[$8 >> 2] & HEAP32[$8 + 4 >> 2] == ($7 | 0)) {
        break block3
       }
      }
      $6 = HEAP32[$5 + 4 >> 2];
      $1 = $4 + Math_imul($2, 24) | 0;
      HEAP32[$1 >> 2] = HEAP32[$5 >> 2];
      HEAP32[$1 + 4 >> 2] = $6;
      $4 = $5 + 16 | 0;
      $6 = HEAP32[$4 + 4 >> 2];
      $7 = $1 + 16 | 0;
      HEAP32[$7 >> 2] = HEAP32[$4 >> 2];
      HEAP32[$7 + 4 >> 2] = $6;
      $5 = $5 + 8 | 0;
      $4 = HEAP32[$5 + 4 >> 2];
      $1 = $1 + 8 | 0;
      HEAP32[$1 >> 2] = HEAP32[$5 >> 2];
      HEAP32[$1 + 4 >> 2] = $4;
      $2 = $2 + 1 | 0;
      $1 = HEAP32[$0 >> 2];
     }
     $3 = $3 + 1 | 0;
     if ($1 >>> 0 > $3 >>> 0) {
      continue
     }
     break;
    };
   }
   if ($1 >>> 0 <= $2 >>> 0) {
    break block
   }
   $5 = HEAP32[$0 + 4 >> 2];
   $3 = $2;
   $6 = $1 - $2 & 3;
   if ($6) {
    $4 = 0;
    while (1) {
     $0 = $5 + Math_imul($3, 24) | 0;
     HEAP32[$0 + 16 >> 2] = 0;
     HEAP32[$0 + 8 >> 2] = 0;
     HEAP32[$0 + 12 >> 2] = 0;
     HEAP32[$0 >> 2] = -1;
     HEAP32[$0 + 4 >> 2] = -1;
     $3 = $3 + 1 | 0;
     $4 = $4 + 1 | 0;
     if (($6 | 0) != ($4 | 0)) {
      continue
     }
     break;
    };
   }
   if ($2 - $1 >>> 0 > 4294967292) {
    break block
   }
   while (1) {
    $0 = $5 + Math_imul($3, 24) | 0;
    HEAP32[$0 + 16 >> 2] = 0;
    HEAP32[$0 + 8 >> 2] = 0;
    HEAP32[$0 + 12 >> 2] = 0;
    HEAP32[$0 >> 2] = -1;
    HEAP32[$0 + 4 >> 2] = -1;
    $2 = $0 + 24 | 0;
    HEAP32[$2 >> 2] = -1;
    HEAP32[$2 + 4 >> 2] = -1;
    $2 = $0 + 32 | 0;
    HEAP32[$2 >> 2] = 0;
    HEAP32[$2 + 4 >> 2] = 0;
    HEAP32[$0 + 40 >> 2] = 0;
    HEAP32[$0 - -64 >> 2] = 0;
    $2 = $0 + 56 | 0;
    HEAP32[$2 >> 2] = 0;
    HEAP32[$2 + 4 >> 2] = 0;
    $2 = $0 + 48 | 0;
    HEAP32[$2 >> 2] = -1;
    HEAP32[$2 + 4 >> 2] = -1;
    HEAP32[$0 + 88 >> 2] = 0;
    $2 = $0 + 80 | 0;
    HEAP32[$2 >> 2] = 0;
    HEAP32[$2 + 4 >> 2] = 0;
    $0 = $0 + 72 | 0;
    HEAP32[$0 >> 2] = -1;
    HEAP32[$0 + 4 >> 2] = -1;
    $3 = $3 + 4 | 0;
    if (($1 | 0) != ($3 | 0)) {
     continue
    }
    break;
   };
  }
 }
 
 function seekpoint_compare_($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0;
  $2 = HEAP32[$0 >> 2];
  $3 = HEAP32[$1 >> 2];
  $0 = HEAP32[$0 + 4 >> 2];
  $1 = HEAP32[$1 + 4 >> 2];
  return (($0 | 0) == ($1 | 0) & $2 >>> 0 > $3 >>> 0 | $0 >>> 0 > $1 >>> 0) - (($0 | 0) == ($1 | 0) & $2 >>> 0 < $3 >>> 0 | $0 >>> 0 < $1 >>> 0) | 0;
 }
 
 function FLAC__format_entropy_coding_method_partitioned_rice_contents_init($0) {
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
 }
 
 function FLAC__format_entropy_coding_method_partitioned_rice_contents_clear($0) {
  var $1 = 0;
  $1 = HEAP32[$0 >> 2];
  if ($1) {
   emscripten_builtin_free($1)
  }
  $1 = HEAP32[$0 + 4 >> 2];
  if ($1) {
   emscripten_builtin_free($1)
  }
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
 }
 
 function FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $3 = 1;
  block : {
   if (HEAPU32[$0 + 8 >> 2] >= $1 >>> 0) {
    break block
   }
   $3 = HEAP32[$0 >> 2];
   $4 = 4 << $1;
   $2 = emscripten_builtin_realloc($3, $4);
   if (!($2 | $1 >>> 0 > 29)) {
    emscripten_builtin_free($3);
    HEAP32[$0 >> 2] = 0;
    return 0;
   }
   HEAP32[$0 >> 2] = $2;
   $3 = 0;
   if (!$2) {
    break block
   }
   $5 = HEAP32[$0 + 4 >> 2];
   $2 = emscripten_builtin_realloc($5, $4);
   if (!($2 | $1 >>> 0 > 29)) {
    emscripten_builtin_free($5);
    HEAP32[$0 + 4 >> 2] = 0;
    return 0;
   }
   HEAP32[$0 + 4 >> 2] = $2;
   if (!$2) {
    break block
   }
   if ($4) {
    wasm2js_memory_fill($2, 0, $4)
   }
   HEAP32[$0 + 8 >> 2] = $1;
   $3 = 1;
  }
  return $3;
 }
 
 function ogg_stream_init($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = -1;
  if ($0) {
   wasm2js_memory_fill($0 + 8 | 0, 0, 352);
   HEAP32[$0 + 24 >> 2] = 1024;
   HEAP32[$0 + 4 >> 2] = 16384;
   $4 = emscripten_builtin_malloc(16384);
   HEAP32[$0 >> 2] = $4;
   $2 = emscripten_builtin_malloc(4096);
   HEAP32[$0 + 16 >> 2] = $2;
   $3 = emscripten_builtin_malloc(8192);
   HEAP32[$0 + 20 >> 2] = $3;
   block4 : {
    if ($4) {
     if (!($3 ? !$2 : 1)) {
      break block4
     }
     emscripten_builtin_free($4);
    }
    if ($2) {
     emscripten_builtin_free($2)
    }
    if ($3) {
     emscripten_builtin_free($3)
    }
    wasm2js_memory_fill($0, 0, 360);
    return -1;
   }
   HEAP32[$0 + 336 >> 2] = $1;
   $2 = 0;
  }
  return $2;
 }
 
 function ogg_stream_clear($0) {
  var $1 = 0;
  if ($0) {
   $1 = HEAP32[$0 >> 2];
   if ($1) {
    emscripten_builtin_free($1)
   }
   $1 = HEAP32[$0 + 16 >> 2];
   if ($1) {
    emscripten_builtin_free($1)
   }
   $1 = HEAP32[$0 + 20 >> 2];
   if ($1) {
    emscripten_builtin_free($1)
   }
   wasm2js_memory_fill($0, 0, 360);
  }
 }
 
 function ogg_page_checksum_set($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ($0) {
   HEAP8[HEAP32[$0 >> 2] + 22 | 0] = 0;
   HEAP8[HEAP32[$0 >> 2] + 23 | 0] = 0;
   HEAP8[HEAP32[$0 >> 2] + 24 | 0] = 0;
   HEAP8[HEAP32[$0 >> 2] + 25 | 0] = 0;
   $1 = HEAP32[$0 + 4 >> 2];
   block1 : {
    if (($1 | 0) <= 0) {
     break block1
    }
    $6 = $1 & 1;
    $4 = HEAP32[$0 >> 2];
    block3 : {
     if (($1 | 0) == 1) {
      $1 = 0;
      break block3;
     }
     $7 = $1 & 2147483646;
     $1 = 0;
     while (1) {
      $5 = $1 + $4 | 0;
      $2 = HEAP32[((HEAPU8[$5 | 0] ^ $2 >>> 24) << 2) + 6800 >> 2] ^ $2 << 8;
      $2 = HEAP32[(($2 >>> 24 ^ HEAPU8[$5 + 1 | 0]) << 2) + 6800 >> 2] ^ $2 << 8;
      $1 = $1 + 2 | 0;
      $3 = $3 + 2 | 0;
      if (($7 | 0) != ($3 | 0)) {
       continue
      }
      break;
     };
    }
    if (!$6) {
     break block1
    }
    $2 = HEAP32[((HEAPU8[$1 + $4 | 0] ^ $2 >>> 24) << 2) + 6800 >> 2] ^ $2 << 8;
   }
   $1 = HEAP32[$0 + 12 >> 2];
   block4 : {
    if (($1 | 0) <= 0) {
     break block4
    }
    $6 = $1 & 1;
    $4 = HEAP32[$0 + 8 >> 2];
    block6 : {
     if (($1 | 0) == 1) {
      $1 = 0;
      break block6;
     }
     $7 = $1 & 2147483646;
     $1 = 0;
     $3 = 0;
     while (1) {
      $5 = $1 + $4 | 0;
      $2 = HEAP32[((HEAPU8[$5 | 0] ^ $2 >>> 24) << 2) + 6800 >> 2] ^ $2 << 8;
      $2 = HEAP32[(($2 >>> 24 ^ HEAPU8[$5 + 1 | 0]) << 2) + 6800 >> 2] ^ $2 << 8;
      $1 = $1 + 2 | 0;
      $3 = $3 + 2 | 0;
      if (($7 | 0) != ($3 | 0)) {
       continue
      }
      break;
     };
    }
    if (!$6) {
     break block4
    }
    $2 = HEAP32[((HEAPU8[$1 + $4 | 0] ^ $2 >>> 24) << 2) + 6800 >> 2] ^ $2 << 8;
   }
   HEAP8[HEAP32[$0 >> 2] + 22 | 0] = $2;
   HEAP8[HEAP32[$0 >> 2] + 23 | 0] = $2 >>> 8;
   HEAP8[HEAP32[$0 >> 2] + 24 | 0] = $2 >>> 16;
   HEAP8[HEAP32[$0 >> 2] + 25 | 0] = $2 >>> 24;
  }
 }
 
 function _os_body_expand($0, $1) {
  var $2 = 0;
  folding_inner0 : {
   $2 = HEAP32[$0 + 4 >> 2];
   if (HEAP32[$0 + 8 >> 2] >= ($2 - $1 | 0)) {
    if (($1 ^ 2147483647) < ($2 | 0)) {
     break folding_inner0
    }
    $1 = $1 + $2 | 0;
    $1 = ($1 | 0) < 2147482623 ? $1 + 1024 | 0 : $1;
    $2 = emscripten_builtin_realloc(HEAP32[$0 >> 2], $1);
    if (!$2) {
     break folding_inner0
    }
    HEAP32[$0 >> 2] = $2;
    HEAP32[$0 + 4 >> 2] = $1;
   }
   return 0;
  }
  $1 = HEAP32[$0 >> 2];
  if ($1) {
   emscripten_builtin_free($1)
  }
  $1 = HEAP32[$0 + 16 >> 2];
  if ($1) {
   emscripten_builtin_free($1)
  }
  $1 = HEAP32[$0 + 20 >> 2];
  if ($1) {
   emscripten_builtin_free($1)
  }
  wasm2js_memory_fill($0, 0, 360);
  return -1;
 }
 
 function _os_lacing_expand($0, $1) {
  var $2 = 0;
  folding_inner0 : {
   $2 = HEAP32[$0 + 24 >> 2];
   if (HEAP32[$0 + 28 >> 2] >= ($2 - $1 | 0)) {
    if (($1 ^ 2147483647) < ($2 | 0)) {
     break folding_inner0
    }
    $1 = $1 + $2 | 0;
    $1 = ($1 | 0) < 2147483615 ? $1 + 32 | 0 : $1;
    $2 = emscripten_builtin_realloc(HEAP32[$0 + 16 >> 2], $1 << 2);
    if (!$2) {
     break folding_inner0
    }
    HEAP32[$0 + 16 >> 2] = $2;
    $2 = emscripten_builtin_realloc(HEAP32[$0 + 20 >> 2], $1 << 3);
    if (!$2) {
     break folding_inner0
    }
    HEAP32[$0 + 24 >> 2] = $1;
    HEAP32[$0 + 20 >> 2] = $2;
   }
   return 0;
  }
  $1 = HEAP32[$0 >> 2];
  if ($1) {
   emscripten_builtin_free($1)
  }
  $1 = HEAP32[$0 + 16 >> 2];
  if ($1) {
   emscripten_builtin_free($1)
  }
  $1 = HEAP32[$0 + 20 >> 2];
  if ($1) {
   emscripten_builtin_free($1)
  }
  wasm2js_memory_fill($0, 0, 360);
  return -1;
 }
 
 function ogg_stream_flush_i($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
  $14 = HEAP32[$0 >> 2];
  block : {
   if (!$14) {
    break block
   }
   $7 = HEAP32[$0 + 28 >> 2];
   if (!$7) {
    break block
   }
   $4 = ($7 | 0) >= 255 ? 255 : $7;
   block8 : {
    block3 : {
     block2 : {
      $11 = HEAP32[$0 + 332 >> 2];
      if ($11) {
       $10 = -1;
       $6 = -1;
       if (($7 | 0) > 0) {
        break block2
       }
       break block3;
      }
      if (($7 | 0) <= 0) {
       break block3
      }
      $8 = HEAP32[$0 + 16 >> 2];
      while (1) {
       $3 = $5 + 1 | 0;
       if (HEAPU8[$8 + ($5 << 2) | 0] != 255) {
        break block3
       }
       $5 = $3;
       if (($3 | 0) != ($4 | 0)) {
        continue
       }
       break;
      };
      $3 = $4;
      break block3;
     }
     block6 : {
      while (1) {
       if (!(($8 | 0) <= 3 | ($5 | 0) <= 4096)) {
        $2 = 1;
        break block6;
       }
       $8 = 0;
       $9 = HEAPU8[HEAP32[$0 + 16 >> 2] + ($3 << 2) | 0];
       if (($9 | 0) != 255) {
        $6 = HEAP32[$0 + 20 >> 2] + ($3 << 3) | 0;
        $10 = HEAP32[$6 >> 2];
        $12 = $12 + 1 | 0;
        $8 = $12;
        $6 = HEAP32[$6 + 4 >> 2];
       }
       $5 = $5 + $9 | 0;
       $3 = $3 + 1 | 0;
       if (($4 | 0) != ($3 | 0)) {
        continue
       }
       break;
      };
      $3 = $4;
     }
     $4 = 255;
     if (($3 | 0) == 255) {
      break block8
     }
    }
    $4 = $3;
    if (!$2) {
     break block
    }
   }
   $5 = 0;
   HEAP16[$0 + 44 >> 1] = 0;
   HEAP32[$0 + 40 >> 2] = 1399285583;
   $2 = HEAP32[$0 + 16 >> 2];
   $3 = !(HEAP32[$2 >> 2] & 256);
   $3 = $11 ? $3 : $3 | 2;
   HEAP8[$0 + 45 | 0] = $3;
   if (!(!HEAP32[$0 + 328 >> 2] | ($4 | 0) != ($7 | 0))) {
    HEAP8[$0 + 45 | 0] = $3 | 4
   }
   $11 = $0 + 40 | 0;
   HEAP8[$0 + 46 | 0] = $10;
   HEAP32[$0 + 332 >> 2] = 1;
   HEAP8[$0 + 66 | 0] = $4;
   HEAP16[$0 + 62 >> 1] = 0;
   HEAP16[$0 + 64 >> 1] = 0;
   HEAP8[$0 + 53 | 0] = $6 >>> 24;
   HEAP8[$0 + 52 | 0] = $6 >>> 16;
   HEAP8[$0 + 51 | 0] = $6 >>> 8;
   HEAP8[$0 + 50 | 0] = $6;
   HEAP8[$0 + 49 | 0] = ($6 & 16777215) << 8 | $10 >>> 24;
   HEAP8[$0 + 48 | 0] = ($6 & 65535) << 16 | $10 >>> 16;
   HEAP8[$0 + 47 | 0] = ($6 & 255) << 24 | $10 >>> 8;
   $3 = HEAP32[$0 + 336 >> 2];
   HEAP8[$0 + 54 | 0] = $3;
   HEAP8[$0 + 55 | 0] = $3 >>> 8;
   HEAP8[$0 + 56 | 0] = $3 >>> 16;
   HEAP8[$0 + 57 | 0] = $3 >>> 24;
   $3 = HEAP32[$0 + 340 >> 2];
   $3 = ($3 | 0) != -1 ? $3 : 0;
   HEAP8[$0 + 58 | 0] = $3;
   HEAP32[$0 + 340 >> 2] = $3 + 1;
   HEAP8[$0 + 61 | 0] = $3 >>> 24;
   HEAP8[$0 + 60 | 0] = $3 >>> 16;
   HEAP8[$0 + 59 | 0] = $3 >>> 8;
   block10 : {
    if (($4 | 0) <= 0) {
     break block10
    }
    $6 = $4 & 1;
    block12 : {
     if (($4 | 0) == 1) {
      $3 = 0;
      break block12;
     }
     $10 = $4 & 2147483646;
     $3 = 0;
     $8 = 0;
     while (1) {
      $9 = $3 + $11 | 0;
      $12 = $2 + ($3 << 2) | 0;
      $13 = HEAP32[$12 >> 2];
      HEAP8[$9 + 27 | 0] = $13;
      $15 = $9;
      $9 = HEAP32[$12 + 4 >> 2];
      HEAP8[$15 + 28 | 0] = $9;
      $5 = (($13 & 255) + $5 | 0) + ($9 & 255) | 0;
      $3 = $3 + 2 | 0;
      $8 = $8 + 2 | 0;
      if (($10 | 0) != ($8 | 0)) {
       continue
      }
      break;
     };
    }
    if (!$6) {
     break block10
    }
    $8 = $3 + $11 | 0;
    $3 = HEAP32[$2 + ($3 << 2) >> 2];
    HEAP8[$8 + 27 | 0] = $3;
    $5 = ($3 & 255) + $5 | 0;
   }
   HEAP32[$1 >> 2] = $11;
   $3 = $4 + 27 | 0;
   HEAP32[$0 + 324 >> 2] = $3;
   HEAP32[$1 + 4 >> 2] = $3;
   $3 = HEAP32[$0 + 12 >> 2];
   HEAP32[$1 + 12 >> 2] = $5;
   HEAP32[$1 + 8 >> 2] = $3 + $14;
   $3 = $7 - $4 | 0;
   HEAP32[$0 + 28 >> 2] = $3;
   $3 = $3 << 2;
   if ($3) {
    wasm2js_memory_copy($2, $2 + ($4 << 2) | 0, $3)
   }
   $2 = HEAP32[$0 + 28 >> 2] << 3;
   if ($2) {
    $3 = HEAP32[$0 + 20 >> 2];
    wasm2js_memory_copy($3, $3 + ($4 << 3) | 0, $2);
   }
   HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + $5;
   $0 = 0;
   HEAP8[HEAP32[$1 >> 2] + 22 | 0] = 0;
   HEAP8[HEAP32[$1 >> 2] + 23 | 0] = 0;
   HEAP8[HEAP32[$1 >> 2] + 24 | 0] = 0;
   HEAP8[HEAP32[$1 >> 2] + 25 | 0] = 0;
   $2 = HEAP32[$1 + 4 >> 2];
   block15 : {
    if (($2 | 0) <= 0) {
     break block15
    }
    $6 = $2 & 1;
    $4 = HEAP32[$1 >> 2];
    block17 : {
     if (($2 | 0) == 1) {
      $3 = 0;
      break block17;
     }
     $2 = $2 & 2147483646;
     $3 = 0;
     $5 = 0;
     while (1) {
      $7 = $3 + $4 | 0;
      $0 = HEAP32[((HEAPU8[$7 | 0] ^ $0 >>> 24) << 2) + 6800 >> 2] ^ $0 << 8;
      $0 = HEAP32[(($0 >>> 24 ^ HEAPU8[$7 + 1 | 0]) << 2) + 6800 >> 2] ^ $0 << 8;
      $3 = $3 + 2 | 0;
      $5 = $5 + 2 | 0;
      if (($2 | 0) != ($5 | 0)) {
       continue
      }
      break;
     };
    }
    if (!$6) {
     break block15
    }
    $0 = HEAP32[((HEAPU8[$3 + $4 | 0] ^ $0 >>> 24) << 2) + 6800 >> 2] ^ $0 << 8;
   }
   $2 = HEAP32[$1 + 12 >> 2];
   block18 : {
    if (($2 | 0) <= 0) {
     break block18
    }
    $6 = $2 & 1;
    $4 = HEAP32[$1 + 8 >> 2];
    block20 : {
     if (($2 | 0) == 1) {
      $3 = 0;
      break block20;
     }
     $2 = $2 & 2147483646;
     $3 = 0;
     $5 = 0;
     while (1) {
      $7 = $3 + $4 | 0;
      $0 = HEAP32[((HEAPU8[$7 | 0] ^ $0 >>> 24) << 2) + 6800 >> 2] ^ $0 << 8;
      $0 = HEAP32[(($0 >>> 24 ^ HEAPU8[$7 + 1 | 0]) << 2) + 6800 >> 2] ^ $0 << 8;
      $3 = $3 + 2 | 0;
      $5 = $5 + 2 | 0;
      if (($2 | 0) != ($5 | 0)) {
       continue
      }
      break;
     };
    }
    if (!$6) {
     break block18
    }
    $0 = HEAP32[((HEAPU8[$3 + $4 | 0] ^ $0 >>> 24) << 2) + 6800 >> 2] ^ $0 << 8;
   }
   HEAP8[HEAP32[$1 >> 2] + 22 | 0] = $0;
   HEAP8[HEAP32[$1 >> 2] + 23 | 0] = $0 >>> 8;
   HEAP8[HEAP32[$1 >> 2] + 24 | 0] = $0 >>> 16;
   HEAP8[HEAP32[$1 >> 2] + 25 | 0] = $0 >>> 24;
   $13 = 1;
  }
  return $13;
 }
 
 function ogg_sync_reset($0) {
  if (HEAP32[$0 + 4 >> 2] < 0) {
   return
  }
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = 0;
  HEAP32[$0 + 24 >> 2] = 0;
  $0 = $0 + 16 | 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
 }
 
 function ogg_stream_reset($0) {
  if (!$0 | !HEAP32[$0 >> 2]) {
   $0 = -1
  } else {
   HEAP32[$0 + 344 >> 2] = 0;
   HEAP32[$0 + 348 >> 2] = 0;
   HEAP32[$0 + 340 >> 2] = -1;
   HEAP32[$0 + 332 >> 2] = 0;
   HEAP32[$0 + 324 >> 2] = 0;
   HEAP32[$0 + 328 >> 2] = 0;
   HEAP32[$0 + 36 >> 2] = 0;
   HEAP32[$0 + 28 >> 2] = 0;
   HEAP32[$0 + 32 >> 2] = 0;
   HEAP32[$0 + 8 >> 2] = 0;
   HEAP32[$0 + 12 >> 2] = 0;
   $0 = $0 + 352 | 0;
   HEAP32[$0 >> 2] = 0;
   HEAP32[$0 + 4 >> 2] = 0;
   $0 = 0;
  }
 }
 
 function FLAC__ogg_decoder_aspect_set_defaults($0) {
  HEAP32[$0 >> 2] = 1;
 }
 
 function FLAC__MD5Init($0) {
  HEAP32[$0 + 80 >> 2] = 0;
  HEAP32[$0 + 84 >> 2] = 0;
  HEAP32[$0 + 72 >> 2] = -1732584194;
  HEAP32[$0 + 76 >> 2] = 271733878;
  HEAP32[$0 + 64 >> 2] = 1732584193;
  HEAP32[$0 + 68 >> 2] = -271733879;
  $0 = $0 + 88 | 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
 }
 
 function FLAC__MD5Final($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = HEAP32[$1 + 80 >> 2] & 63;
  $3 = $2 + $1 | 0;
  HEAP8[$3 | 0] = 128;
  $3 = $3 + 1 | 0;
  if ($2 >>> 0 < 56) {
   $2 = 55 - $2 | 0
  } else {
   $2 = $2 ^ 63;
   if ($2) {
    wasm2js_memory_fill($3, 0, $2)
   }
   FLAC__MD5Transform($1 - -64 | 0, $1);
   $3 = $1;
   $2 = 56;
  }
  if ($2) {
   wasm2js_memory_fill($3, 0, $2)
  }
  $3 = HEAP32[$1 + 80 >> 2];
  HEAP32[$1 + 56 >> 2] = $3 << 3;
  HEAP32[$1 + 60 >> 2] = HEAP32[$1 + 84 >> 2] << 3 | $3 >>> 29;
  FLAC__MD5Transform($1 - -64 | 0, $1);
  $2 = $1 + 72 | 0;
  $4 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
  $3 = $0 + 8 | 0;
  $2 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
  HEAP8[$3 | 0] = $2;
  HEAP8[$3 + 1 | 0] = $2 >>> 8;
  HEAP8[$3 + 2 | 0] = $2 >>> 16;
  HEAP8[$3 + 3 | 0] = $2 >>> 24;
  HEAP8[$3 + 4 | 0] = $4;
  HEAP8[$3 + 5 | 0] = $4 >>> 8;
  HEAP8[$3 + 6 | 0] = $4 >>> 16;
  HEAP8[$3 + 7 | 0] = $4 >>> 24;
  $3 = HEAPU8[$1 + 68 | 0] | HEAPU8[$1 + 69 | 0] << 8 | (HEAPU8[$1 + 70 | 0] << 16 | HEAPU8[$1 + 71 | 0] << 24);
  $2 = HEAPU8[$1 + 64 | 0] | HEAPU8[$1 + 65 | 0] << 8 | (HEAPU8[$1 + 66 | 0] << 16 | HEAPU8[$1 + 67 | 0] << 24);
  HEAP8[$0 | 0] = $2;
  HEAP8[$0 + 1 | 0] = $2 >>> 8;
  HEAP8[$0 + 2 | 0] = $2 >>> 16;
  HEAP8[$0 + 3 | 0] = $2 >>> 24;
  HEAP8[$0 + 4 | 0] = $3;
  HEAP8[$0 + 5 | 0] = $3 >>> 8;
  HEAP8[$0 + 6 | 0] = $3 >>> 16;
  HEAP8[$0 + 7 | 0] = $3 >>> 24;
  $0 = HEAP32[$1 + 88 >> 2];
  if ($0) {
   emscripten_builtin_free($0)
  }
  wasm2js_memory_fill($1, 0, 96);
 }
 
 function FLAC__MD5Transform($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
  $11 = HEAP32[$1 + 16 >> 2];
  $8 = HEAP32[$1 + 32 >> 2];
  $12 = HEAP32[$1 + 48 >> 2];
  $13 = HEAP32[$1 + 36 >> 2];
  $14 = HEAP32[$1 + 52 >> 2];
  $15 = HEAP32[$1 + 4 >> 2];
  $6 = HEAP32[$1 + 20 >> 2];
  $7 = HEAP32[$0 + 4 >> 2];
  $9 = HEAP32[$1 >> 2];
  $25 = HEAP32[$0 >> 2];
  $16 = HEAP32[$0 + 12 >> 2];
  $10 = HEAP32[$0 + 8 >> 2];
  $3 = $7 + __wasm_rotl_i32((($9 + $25 | 0) + ($16 ^ ($10 ^ $16) & $7) | 0) - 680876936 | 0, 7) | 0;
  $17 = HEAP32[$1 + 12 >> 2];
  $18 = HEAP32[$1 + 8 >> 2];
  $4 = __wasm_rotl_i32((($15 + $16 | 0) + ($3 & ($7 ^ $10) ^ $10) | 0) - 389564586 | 0, 12) + $3 | 0;
  $2 = __wasm_rotl_i32((($18 + $10 | 0) + ($4 & ($3 ^ $7) ^ $7) | 0) + 606105819 | 0, 17) + $4 | 0;
  $5 = __wasm_rotl_i32((($7 + $17 | 0) + ($3 ^ $2 & ($3 ^ $4)) | 0) - 1044525330 | 0, 22) + $2 | 0;
  $3 = __wasm_rotl_i32((($3 + $11 | 0) + ($4 ^ $5 & ($2 ^ $4)) | 0) - 176418897 | 0, 7) + $5 | 0;
  $19 = HEAP32[$1 + 28 >> 2];
  $20 = HEAP32[$1 + 24 >> 2];
  $4 = __wasm_rotl_i32((($4 + $6 | 0) + ($2 ^ $3 & ($2 ^ $5)) | 0) + 1200080426 | 0, 12) + $3 | 0;
  $2 = __wasm_rotl_i32((($2 + $20 | 0) + ($5 ^ $4 & ($3 ^ $5)) | 0) - 1473231341 | 0, 17) + $4 | 0;
  $5 = __wasm_rotl_i32((($5 + $19 | 0) + ($3 ^ $2 & ($3 ^ $4)) | 0) - 45705983 | 0, 22) + $2 | 0;
  $3 = __wasm_rotl_i32((($3 + $8 | 0) + ($4 ^ $5 & ($2 ^ $4)) | 0) + 1770035416 | 0, 7) + $5 | 0;
  $21 = HEAP32[$1 + 44 >> 2];
  $22 = HEAP32[$1 + 40 >> 2];
  $4 = __wasm_rotl_i32((($4 + $13 | 0) + ($2 ^ $3 & ($2 ^ $5)) | 0) - 1958414417 | 0, 12) + $3 | 0;
  $2 = __wasm_rotl_i32((($2 + $22 | 0) + ($5 ^ $4 & ($3 ^ $5)) | 0) - 42063 | 0, 17) + $4 | 0;
  $5 = __wasm_rotl_i32((($5 + $21 | 0) + ($3 ^ $2 & ($3 ^ $4)) | 0) - 1990404162 | 0, 22) + $2 | 0;
  $3 = __wasm_rotl_i32((($3 + $12 | 0) + ($4 ^ $5 & ($2 ^ $4)) | 0) + 1804603682 | 0, 7) + $5 | 0;
  $23 = HEAP32[$1 + 56 >> 2];
  $24 = HEAP32[$1 + 60 >> 2];
  $4 = __wasm_rotl_i32((($4 + $14 | 0) + ($2 ^ $3 & ($2 ^ $5)) | 0) - 40341101 | 0, 12) + $3 | 0;
  $1 = $4 + __wasm_rotl_i32((($2 + $23 | 0) + ($5 ^ ($3 ^ $5) & $4) | 0) - 1502002290 | 0, 17) | 0;
  $26 = $1 + $21 | 0;
  $2 = $3 + $15 | 0;
  $3 = __wasm_rotl_i32((($5 + $24 | 0) + ($3 ^ $1 & ($3 ^ $4)) | 0) + 1236535329 | 0, 22) + $1 | 0;
  $2 = __wasm_rotl_i32(($2 + ($1 ^ ($3 ^ $1) & $4) | 0) - 165796510 | 0, 5) + $3 | 0;
  $1 = __wasm_rotl_i32((($4 + $20 | 0) + ($3 ^ $1 & ($3 ^ $2)) | 0) - 1069501632 | 0, 9) + $2 | 0;
  $4 = __wasm_rotl_i32(($26 + (($2 ^ $1) & $3 ^ $2) | 0) + 643717713 | 0, 14) + $1 | 0;
  $3 = __wasm_rotl_i32((($3 + $9 | 0) + ($1 ^ $2 & ($1 ^ $4)) | 0) - 373897302 | 0, 20) + $4 | 0;
  $2 = __wasm_rotl_i32((($2 + $6 | 0) + ($4 ^ $1 & ($3 ^ $4)) | 0) - 701558691 | 0, 5) + $3 | 0;
  $1 = __wasm_rotl_i32((($1 + $22 | 0) + ($3 ^ $4 & ($3 ^ $2)) | 0) + 38016083 | 0, 9) + $2 | 0;
  $4 = __wasm_rotl_i32((($24 + $4 | 0) + (($2 ^ $1) & $3 ^ $2) | 0) - 660478335 | 0, 14) + $1 | 0;
  $3 = __wasm_rotl_i32((($3 + $11 | 0) + ($1 ^ $2 & ($1 ^ $4)) | 0) - 405537848 | 0, 20) + $4 | 0;
  $2 = __wasm_rotl_i32((($2 + $13 | 0) + ($4 ^ $1 & ($3 ^ $4)) | 0) + 568446438 | 0, 5) + $3 | 0;
  $1 = __wasm_rotl_i32((($1 + $23 | 0) + ($3 ^ $4 & ($3 ^ $2)) | 0) - 1019803690 | 0, 9) + $2 | 0;
  $4 = __wasm_rotl_i32((($4 + $17 | 0) + (($2 ^ $1) & $3 ^ $2) | 0) - 187363961 | 0, 14) + $1 | 0;
  $3 = __wasm_rotl_i32((($3 + $8 | 0) + ($1 ^ $2 & ($1 ^ $4)) | 0) + 1163531501 | 0, 20) + $4 | 0;
  $2 = __wasm_rotl_i32((($2 + $14 | 0) + ($4 ^ $1 & ($3 ^ $4)) | 0) - 1444681467 | 0, 5) + $3 | 0;
  $1 = __wasm_rotl_i32((($1 + $18 | 0) + ($3 ^ $4 & ($3 ^ $2)) | 0) - 51403784 | 0, 9) + $2 | 0;
  $4 = __wasm_rotl_i32((($4 + $19 | 0) + (($2 ^ $1) & $3 ^ $2) | 0) + 1735328473 | 0, 14) + $1 | 0;
  $5 = $1 ^ $4;
  $3 = __wasm_rotl_i32((($3 + $12 | 0) + ($1 ^ $5 & $2) | 0) - 1926607734 | 0, 20) + $4 | 0;
  $2 = __wasm_rotl_i32((($2 + $6 | 0) + ($3 ^ $5) | 0) - 378558 | 0, 4) + $3 | 0;
  $1 = __wasm_rotl_i32((($1 + $8 | 0) + ($3 ^ $4 ^ $2) | 0) - 2022574463 | 0, 11) + $2 | 0;
  $4 = __wasm_rotl_i32((($4 + $21 | 0) + ($1 ^ ($3 ^ $2)) | 0) + 1839030562 | 0, 16) + $1 | 0;
  $3 = __wasm_rotl_i32((($3 + $23 | 0) + ($4 ^ ($1 ^ $2)) | 0) - 35309556 | 0, 23) + $4 | 0;
  $2 = __wasm_rotl_i32((($2 + $15 | 0) + ($3 ^ ($1 ^ $4)) | 0) - 1530992060 | 0, 4) + $3 | 0;
  $1 = __wasm_rotl_i32((($1 + $11 | 0) + ($2 ^ ($3 ^ $4)) | 0) + 1272893353 | 0, 11) + $2 | 0;
  $4 = __wasm_rotl_i32((($4 + $19 | 0) + ($1 ^ ($3 ^ $2)) | 0) - 155497632 | 0, 16) + $1 | 0;
  $3 = __wasm_rotl_i32((($3 + $22 | 0) + ($4 ^ ($1 ^ $2)) | 0) - 1094730640 | 0, 23) + $4 | 0;
  $2 = __wasm_rotl_i32((($2 + $14 | 0) + ($3 ^ ($1 ^ $4)) | 0) + 681279174 | 0, 4) + $3 | 0;
  $1 = __wasm_rotl_i32((($1 + $9 | 0) + ($2 ^ ($3 ^ $4)) | 0) - 358537222 | 0, 11) + $2 | 0;
  $4 = __wasm_rotl_i32((($4 + $17 | 0) + ($1 ^ ($3 ^ $2)) | 0) - 722521979 | 0, 16) + $1 | 0;
  $3 = __wasm_rotl_i32((($3 + $20 | 0) + ($4 ^ ($1 ^ $2)) | 0) + 76029189 | 0, 23) + $4 | 0;
  $2 = __wasm_rotl_i32((($2 + $13 | 0) + ($3 ^ ($1 ^ $4)) | 0) - 640364487 | 0, 4) + $3 | 0;
  $1 = __wasm_rotl_i32((($1 + $12 | 0) + ($2 ^ ($3 ^ $4)) | 0) - 421815835 | 0, 11) + $2 | 0;
  $5 = $2 + $9 | 0;
  $9 = $1 ^ $2;
  $2 = __wasm_rotl_i32((($4 + $24 | 0) + ($1 ^ ($3 ^ $2)) | 0) + 530742520 | 0, 16) + $1 | 0;
  $4 = __wasm_rotl_i32((($3 + $18 | 0) + ($9 ^ $2) | 0) - 995338651 | 0, 23) + $2 | 0;
  $3 = __wasm_rotl_i32(($5 + (($4 | $1 ^ -1) ^ $2) | 0) - 198630844 | 0, 6) + $4 | 0;
  $5 = $4 + $6 | 0;
  $6 = $2 + $23 | 0;
  $2 = __wasm_rotl_i32((($1 + $19 | 0) + ($4 ^ ($3 | $2 ^ -1)) | 0) + 1126891415 | 0, 10) + $3 | 0;
  $4 = __wasm_rotl_i32(($6 + ($3 ^ ($2 | $4 ^ -1)) | 0) - 1416354905 | 0, 15) + $2 | 0;
  $1 = __wasm_rotl_i32(($5 + (($4 | $3 ^ -1) ^ $2) | 0) - 57434055 | 0, 21) + $4 | 0;
  $5 = $4 + $22 | 0;
  $6 = $2 + $17 | 0;
  $2 = __wasm_rotl_i32((($3 + $12 | 0) + ($4 ^ ($1 | $2 ^ -1)) | 0) + 1700485571 | 0, 6) + $1 | 0;
  $4 = __wasm_rotl_i32(($6 + ($1 ^ ($2 | $4 ^ -1)) | 0) - 1894986606 | 0, 10) + $2 | 0;
  $3 = __wasm_rotl_i32(($5 + (($4 | $1 ^ -1) ^ $2) | 0) - 1051523 | 0, 15) + $4 | 0;
  $5 = $4 + $24 | 0;
  $8 = $2 + $8 | 0;
  $2 = __wasm_rotl_i32((($1 + $15 | 0) + ($4 ^ ($3 | $2 ^ -1)) | 0) - 2054922799 | 0, 21) + $3 | 0;
  $4 = __wasm_rotl_i32(($8 + ($3 ^ ($2 | $4 ^ -1)) | 0) + 1873313359 | 0, 6) + $2 | 0;
  $1 = __wasm_rotl_i32(($5 + (($4 | $3 ^ -1) ^ $2) | 0) - 30611744 | 0, 10) + $4 | 0;
  $3 = __wasm_rotl_i32((($3 + $20 | 0) + ($4 ^ ($1 | $2 ^ -1)) | 0) - 1560198380 | 0, 15) + $1 | 0;
  $2 = __wasm_rotl_i32((($2 + $14 | 0) + ($1 ^ ($3 | $4 ^ -1)) | 0) + 1309151649 | 0, 21) + $3 | 0;
  $4 = __wasm_rotl_i32((($4 + $11 | 0) + (($2 | $1 ^ -1) ^ $3) | 0) - 145523070 | 0, 6) + $2 | 0;
  HEAP32[$0 >> 2] = $4 + $25;
  $1 = __wasm_rotl_i32((($1 + $21 | 0) + ($2 ^ ($4 | $3 ^ -1)) | 0) - 1120210379 | 0, 10) + $4 | 0;
  HEAP32[$0 + 12 >> 2] = $1 + $16;
  $3 = __wasm_rotl_i32((($3 + $18 | 0) + ($4 ^ ($1 | $2 ^ -1)) | 0) + 718787259 | 0, 15) + $1 | 0;
  HEAP32[$0 + 8 >> 2] = $3 + $10;
  (wasm2js_i32$0 = $0, wasm2js_i32$1 = __wasm_rotl_i32((($2 + $13 | 0) + ($1 ^ ($3 | $4 ^ -1)) | 0) - 343485551 | 0, 21) + ($3 + $7 | 0) | 0), HEAP32[wasm2js_i32$0 + 4 >> 2] = wasm2js_i32$1;
 }
 
 function FLAC__MD5Accumulate($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
  __wasm_i64_mul($4, 0, $2, 0);
  block : {
   if (i64toi32_i32$HIGH_BITS) {
    break block
   }
   $7 = Math_imul($2, $4);
   __wasm_i64_mul($3, 0, $7, 0);
   if (i64toi32_i32$HIGH_BITS) {
    break block
   }
   $6 = HEAP32[$0 + 88 >> 2];
   $12 = Math_imul($3, $7);
   block2 : {
    if ($12 >>> 0 <= HEAPU32[$0 + 92 >> 2]) {
     $5 = $6;
     break block2;
    }
    block4 : {
     $5 = emscripten_builtin_realloc($6, $12);
     if ($5) {
      HEAP32[$0 + 88 >> 2] = $5;
      break block4;
     }
     emscripten_builtin_free($6);
     $5 = emscripten_builtin_malloc($12);
     HEAP32[$0 + 88 >> 2] = $5;
     if ($5) {
      break block4
     }
     HEAP32[$0 + 92 >> 2] = 0;
     return 0;
    }
    HEAP32[$0 + 92 >> 2] = $12;
   }
   block26 : {
    block8 : {
     block29 : {
      block28 : {
       block31 : {
        block30 : {
         block35 : {
          block34 : {
           block37 : {
            block36 : {
             block6 : {
              block7 : {
               block9 : {
                block10 : {
                 block11 : {
                  block13 : {
                   block14 : {
                    block15 : {
                     block16 : {
                      block17 : {
                       $6 = Math_imul($4, 100) + $2 | 0;
                       if (($6 | 0) <= 300) {
                        block12 : {
                         switch ($6 - 101 | 0) {
                         case 5:
                          break block10;
                         case 7:
                          break block11;
                         case 0:
                          break block6;
                         case 1:
                          break block7;
                         case 2:
                         case 4:
                         case 6:
                          break block8;
                         case 3:
                          break block9;
                         default:
                          break block12;
                         };
                        }
                        switch ($6 - 201 | 0) {
                        case 0:
                         break block13;
                        case 1:
                         break block14;
                        case 3:
                         break block15;
                        case 5:
                         break block16;
                        case 7:
                         break block17;
                        default:
                         break block8;
                        };
                       }
                       block24 : {
                        block25 : {
                         block18 : {
                          switch ($6 - 401 | 0) {
                          default:
                           switch ($6 - 301 | 0) {
                           case 0:
                            break block24;
                           case 1:
                            break block25;
                           default:
                            break block8;
                           };
                          case 7:
                           if (!$3) {
                            break block26
                           }
                           $13 = HEAP32[$1 + 28 >> 2];
                           $11 = HEAP32[$1 + 24 >> 2];
                           $8 = HEAP32[$1 + 20 >> 2];
                           $9 = HEAP32[$1 + 16 >> 2];
                           $7 = HEAP32[$1 + 12 >> 2];
                           $6 = HEAP32[$1 + 8 >> 2];
                           $4 = HEAP32[$1 + 4 >> 2];
                           $1 = HEAP32[$1 >> 2];
                           $2 = 0;
                           while (1) {
                            $10 = $2 << 2;
                            HEAP32[$5 >> 2] = HEAP32[$10 + $1 >> 2];
                            HEAP32[$5 + 4 >> 2] = HEAP32[$4 + $10 >> 2];
                            HEAP32[$5 + 8 >> 2] = HEAP32[$6 + $10 >> 2];
                            HEAP32[$5 + 12 >> 2] = HEAP32[$7 + $10 >> 2];
                            HEAP32[$5 + 16 >> 2] = HEAP32[$9 + $10 >> 2];
                            HEAP32[$5 + 20 >> 2] = HEAP32[$8 + $10 >> 2];
                            HEAP32[$5 + 24 >> 2] = HEAP32[$10 + $11 >> 2];
                            HEAP32[$5 + 28 >> 2] = HEAP32[$10 + $13 >> 2];
                            $5 = $5 + 32 | 0;
                            $2 = $2 + 1 | 0;
                            if (($3 | 0) != ($2 | 0)) {
                             continue
                            }
                            break;
                           };
                           break block26;
                          case 5:
                           if (!$3) {
                            break block26
                           }
                           $8 = HEAP32[$1 + 20 >> 2];
                           $9 = HEAP32[$1 + 16 >> 2];
                           $7 = HEAP32[$1 + 12 >> 2];
                           $6 = HEAP32[$1 + 8 >> 2];
                           $4 = HEAP32[$1 + 4 >> 2];
                           $1 = HEAP32[$1 >> 2];
                           $2 = 0;
                           while (1) {
                            $11 = $2 << 2;
                            HEAP32[$5 >> 2] = HEAP32[$11 + $1 >> 2];
                            HEAP32[$5 + 4 >> 2] = HEAP32[$4 + $11 >> 2];
                            HEAP32[$5 + 8 >> 2] = HEAP32[$6 + $11 >> 2];
                            HEAP32[$5 + 12 >> 2] = HEAP32[$7 + $11 >> 2];
                            HEAP32[$5 + 16 >> 2] = HEAP32[$9 + $11 >> 2];
                            HEAP32[$5 + 20 >> 2] = HEAP32[$8 + $11 >> 2];
                            $5 = $5 + 24 | 0;
                            $2 = $2 + 1 | 0;
                            if (($3 | 0) != ($2 | 0)) {
                             continue
                            }
                            break;
                           };
                           break block26;
                          case 3:
                           if (!$3) {
                            break block26
                           }
                           $4 = $3 & 1;
                           $11 = HEAP32[$1 + 12 >> 2];
                           $8 = HEAP32[$1 + 8 >> 2];
                           $9 = HEAP32[$1 + 4 >> 2];
                           $7 = HEAP32[$1 >> 2];
                           $2 = 0;
                           if (($3 | 0) != 1) {
                            $1 = $3 & -2;
                            $3 = 0;
                            while (1) {
                             $6 = $2 << 2;
                             HEAP32[$5 >> 2] = HEAP32[$6 + $7 >> 2];
                             HEAP32[$5 + 4 >> 2] = HEAP32[$6 + $9 >> 2];
                             HEAP32[$5 + 8 >> 2] = HEAP32[$6 + $8 >> 2];
                             HEAP32[$5 + 12 >> 2] = HEAP32[$6 + $11 >> 2];
                             $6 = $6 | 4;
                             HEAP32[$5 + 16 >> 2] = HEAP32[$6 + $7 >> 2];
                             HEAP32[$5 + 20 >> 2] = HEAP32[$6 + $9 >> 2];
                             HEAP32[$5 + 24 >> 2] = HEAP32[$6 + $8 >> 2];
                             HEAP32[$5 + 28 >> 2] = HEAP32[$6 + $11 >> 2];
                             $2 = $2 + 2 | 0;
                             $5 = $5 + 32 | 0;
                             $3 = $3 + 2 | 0;
                             if (($1 | 0) != ($3 | 0)) {
                              continue
                             }
                             break;
                            };
                           }
                           if (!$4) {
                            break block26
                           }
                           $1 = $2 << 2;
                           HEAP32[$5 >> 2] = HEAP32[$1 + $7 >> 2];
                           HEAP32[$5 + 4 >> 2] = HEAP32[$1 + $9 >> 2];
                           HEAP32[$5 + 8 >> 2] = HEAP32[$1 + $8 >> 2];
                           HEAP32[$5 + 12 >> 2] = HEAP32[$1 + $11 >> 2];
                           break block26;
                          case 1:
                           if (!$3) {
                            break block26
                           }
                           $4 = $3 & 3;
                           $9 = HEAP32[$1 + 4 >> 2];
                           $7 = HEAP32[$1 >> 2];
                           if ($3 - 1 >>> 0 >= 3) {
                            break block28
                           }
                           $1 = 0;
                           break block29;
                          case 0:
                           break block18;
                          case 2:
                          case 4:
                          case 6:
                           break block8;
                          };
                         }
                         if (!$3) {
                          break block26
                         }
                         $6 = $3 & 3;
                         $4 = HEAP32[$1 >> 2];
                         $2 = 0;
                         if ($3 - 1 >>> 0 >= 3) {
                          break block30
                         }
                         $1 = 0;
                         break block31;
                        }
                        if (!$3) {
                         break block26
                        }
                        $2 = 0;
                        while (1) {
                         $4 = $2 << 2;
                         $6 = HEAP32[$4 + HEAP32[$1 >> 2] >> 2];
                         HEAP8[$5 | 0] = $6;
                         HEAP8[$5 + 2 | 0] = $6 >>> 16;
                         HEAP8[$5 + 1 | 0] = $6 >>> 8;
                         $4 = HEAP32[$4 + HEAP32[$1 + 4 >> 2] >> 2];
                         HEAP8[$5 + 3 | 0] = $4;
                         HEAP8[$5 + 5 | 0] = $4 >>> 16;
                         HEAP8[$5 + 4 | 0] = $4 >>> 8;
                         $5 = $5 + 6 | 0;
                         $2 = $2 + 1 | 0;
                         if (($3 | 0) != ($2 | 0)) {
                          continue
                         }
                         break;
                        };
                        break block26;
                       }
                       if (!$3) {
                        break block26
                       }
                       $7 = $3 & 1;
                       $2 = 0;
                       if (($3 | 0) != 1) {
                        $6 = $3 & -2;
                        $4 = 0;
                        while (1) {
                         $3 = $2 << 2;
                         $9 = HEAP32[$3 + HEAP32[$1 >> 2] >> 2];
                         HEAP8[$5 | 0] = $9;
                         HEAP8[$5 + 2 | 0] = $9 >>> 16;
                         HEAP8[$5 + 1 | 0] = $9 >>> 8;
                         $3 = HEAP32[($3 + HEAP32[$1 >> 2] | 0) + 4 >> 2];
                         HEAP8[$5 + 3 | 0] = $3;
                         HEAP8[$5 + 5 | 0] = $3 >>> 16;
                         HEAP8[$5 + 4 | 0] = $3 >>> 8;
                         $2 = $2 + 2 | 0;
                         $5 = $5 + 6 | 0;
                         $4 = $4 + 2 | 0;
                         if (($6 | 0) != ($4 | 0)) {
                          continue
                         }
                         break;
                        };
                       }
                       if (!$7) {
                        break block26
                       }
                       $1 = HEAP32[HEAP32[$1 >> 2] + ($2 << 2) >> 2];
                       HEAP8[$5 | 0] = $1;
                       HEAP8[$5 + 2 | 0] = $1 >>> 16;
                       HEAP8[$5 + 1 | 0] = $1 >>> 8;
                       break block26;
                      }
                      if (!$3) {
                       break block26
                      }
                      $13 = HEAP32[$1 + 28 >> 2];
                      $11 = HEAP32[$1 + 24 >> 2];
                      $8 = HEAP32[$1 + 20 >> 2];
                      $9 = HEAP32[$1 + 16 >> 2];
                      $7 = HEAP32[$1 + 12 >> 2];
                      $6 = HEAP32[$1 + 8 >> 2];
                      $4 = HEAP32[$1 + 4 >> 2];
                      $1 = HEAP32[$1 >> 2];
                      $2 = 0;
                      while (1) {
                       $10 = $2 << 2;
                       HEAP16[$5 >> 1] = HEAP32[$10 + $1 >> 2];
                       HEAP16[$5 + 2 >> 1] = HEAP32[$4 + $10 >> 2];
                       HEAP16[$5 + 4 >> 1] = HEAP32[$6 + $10 >> 2];
                       HEAP16[$5 + 6 >> 1] = HEAP32[$7 + $10 >> 2];
                       HEAP16[$5 + 8 >> 1] = HEAP32[$9 + $10 >> 2];
                       HEAP16[$5 + 10 >> 1] = HEAP32[$8 + $10 >> 2];
                       HEAP16[$5 + 12 >> 1] = HEAP32[$10 + $11 >> 2];
                       HEAP16[$5 + 14 >> 1] = HEAP32[$10 + $13 >> 2];
                       $5 = $5 + 16 | 0;
                       $2 = $2 + 1 | 0;
                       if (($3 | 0) != ($2 | 0)) {
                        continue
                       }
                       break;
                      };
                      break block26;
                     }
                     if (!$3) {
                      break block26
                     }
                     $8 = HEAP32[$1 + 20 >> 2];
                     $9 = HEAP32[$1 + 16 >> 2];
                     $7 = HEAP32[$1 + 12 >> 2];
                     $6 = HEAP32[$1 + 8 >> 2];
                     $4 = HEAP32[$1 + 4 >> 2];
                     $1 = HEAP32[$1 >> 2];
                     $2 = 0;
                     while (1) {
                      $11 = $2 << 2;
                      HEAP16[$5 >> 1] = HEAP32[$11 + $1 >> 2];
                      HEAP16[$5 + 2 >> 1] = HEAP32[$4 + $11 >> 2];
                      HEAP16[$5 + 4 >> 1] = HEAP32[$6 + $11 >> 2];
                      HEAP16[$5 + 6 >> 1] = HEAP32[$7 + $11 >> 2];
                      HEAP16[$5 + 8 >> 1] = HEAP32[$9 + $11 >> 2];
                      HEAP16[$5 + 10 >> 1] = HEAP32[$8 + $11 >> 2];
                      $5 = $5 + 12 | 0;
                      $2 = $2 + 1 | 0;
                      if (($3 | 0) != ($2 | 0)) {
                       continue
                      }
                      break;
                     };
                     break block26;
                    }
                    if (!$3) {
                     break block26
                    }
                    $4 = $3 & 1;
                    $11 = HEAP32[$1 + 12 >> 2];
                    $8 = HEAP32[$1 + 8 >> 2];
                    $9 = HEAP32[$1 + 4 >> 2];
                    $7 = HEAP32[$1 >> 2];
                    $2 = 0;
                    if (($3 | 0) != 1) {
                     $1 = $3 & -2;
                     $3 = 0;
                     while (1) {
                      $6 = $2 << 2;
                      HEAP16[$5 >> 1] = HEAP32[$6 + $7 >> 2];
                      HEAP16[$5 + 2 >> 1] = HEAP32[$6 + $9 >> 2];
                      HEAP16[$5 + 4 >> 1] = HEAP32[$6 + $8 >> 2];
                      HEAP16[$5 + 6 >> 1] = HEAP32[$6 + $11 >> 2];
                      $6 = $6 | 4;
                      HEAP16[$5 + 8 >> 1] = HEAP32[$6 + $7 >> 2];
                      HEAP16[$5 + 10 >> 1] = HEAP32[$6 + $9 >> 2];
                      HEAP16[$5 + 12 >> 1] = HEAP32[$6 + $8 >> 2];
                      HEAP16[$5 + 14 >> 1] = HEAP32[$6 + $11 >> 2];
                      $2 = $2 + 2 | 0;
                      $5 = $5 + 16 | 0;
                      $3 = $3 + 2 | 0;
                      if (($1 | 0) != ($3 | 0)) {
                       continue
                      }
                      break;
                     };
                    }
                    if (!$4) {
                     break block26
                    }
                    $1 = $2 << 2;
                    HEAP16[$5 >> 1] = HEAP32[$1 + $7 >> 2];
                    HEAP16[$5 + 2 >> 1] = HEAP32[$1 + $9 >> 2];
                    HEAP16[$5 + 4 >> 1] = HEAP32[$1 + $8 >> 2];
                    HEAP16[$5 + 6 >> 1] = HEAP32[$1 + $11 >> 2];
                    break block26;
                   }
                   if (!$3) {
                    break block26
                   }
                   $4 = $3 & 3;
                   $9 = HEAP32[$1 + 4 >> 2];
                   $7 = HEAP32[$1 >> 2];
                   if ($3 - 1 >>> 0 >= 3) {
                    break block34
                   }
                   $1 = 0;
                   break block35;
                  }
                  if (!$3) {
                   break block26
                  }
                  $6 = $3 & 3;
                  $4 = HEAP32[$1 >> 2];
                  $2 = 0;
                  if ($3 - 1 >>> 0 >= 3) {
                   break block36
                  }
                  $1 = 0;
                  break block37;
                 }
                 if (!$3) {
                  break block26
                 }
                 $4 = 0;
                 while (1) {
                  $2 = $4 << 2;
                  HEAP8[$5 | 0] = HEAP32[$2 + HEAP32[$1 >> 2] >> 2];
                  HEAP8[$5 + 1 | 0] = HEAP32[$2 + HEAP32[$1 + 4 >> 2] >> 2];
                  HEAP8[$5 + 2 | 0] = HEAP32[$2 + HEAP32[$1 + 8 >> 2] >> 2];
                  HEAP8[$5 + 3 | 0] = HEAP32[$2 + HEAP32[$1 + 12 >> 2] >> 2];
                  HEAP8[$5 + 4 | 0] = HEAP32[$2 + HEAP32[$1 + 16 >> 2] >> 2];
                  HEAP8[$5 + 5 | 0] = HEAP32[$2 + HEAP32[$1 + 20 >> 2] >> 2];
                  HEAP8[$5 + 6 | 0] = HEAP32[$2 + HEAP32[$1 + 24 >> 2] >> 2];
                  HEAP8[$5 + 7 | 0] = HEAP32[$2 + HEAP32[$1 + 28 >> 2] >> 2];
                  $5 = $5 + 8 | 0;
                  $4 = $4 + 1 | 0;
                  if (($4 | 0) != ($3 | 0)) {
                   continue
                  }
                  break;
                 };
                 break block26;
                }
                if (!$3) {
                 break block26
                }
                $4 = 0;
                while (1) {
                 $2 = $4 << 2;
                 HEAP8[$5 | 0] = HEAP32[$2 + HEAP32[$1 >> 2] >> 2];
                 HEAP8[$5 + 1 | 0] = HEAP32[$2 + HEAP32[$1 + 4 >> 2] >> 2];
                 HEAP8[$5 + 2 | 0] = HEAP32[$2 + HEAP32[$1 + 8 >> 2] >> 2];
                 HEAP8[$5 + 3 | 0] = HEAP32[$2 + HEAP32[$1 + 12 >> 2] >> 2];
                 HEAP8[$5 + 4 | 0] = HEAP32[$2 + HEAP32[$1 + 16 >> 2] >> 2];
                 HEAP8[$5 + 5 | 0] = HEAP32[$2 + HEAP32[$1 + 20 >> 2] >> 2];
                 $5 = $5 + 6 | 0;
                 $4 = $4 + 1 | 0;
                 if (($4 | 0) != ($3 | 0)) {
                  continue
                 }
                 break;
                };
                break block26;
               }
               if (!$3) {
                break block26
               }
               $4 = 0;
               while (1) {
                $2 = $4 << 2;
                HEAP8[$5 | 0] = HEAP32[$2 + HEAP32[$1 >> 2] >> 2];
                HEAP8[$5 + 1 | 0] = HEAP32[$2 + HEAP32[$1 + 4 >> 2] >> 2];
                HEAP8[$5 + 2 | 0] = HEAP32[$2 + HEAP32[$1 + 8 >> 2] >> 2];
                HEAP8[$5 + 3 | 0] = HEAP32[$2 + HEAP32[$1 + 12 >> 2] >> 2];
                $5 = $5 + 4 | 0;
                $4 = $4 + 1 | 0;
                if (($4 | 0) != ($3 | 0)) {
                 continue
                }
                break;
               };
               break block26;
              }
              if (!$3) {
               break block26
              }
              $7 = $3 & 1;
              $2 = 0;
              if (($3 | 0) != 1) {
               $6 = $3 & -2;
               $4 = 0;
               while (1) {
                $3 = $2 << 2;
                HEAP8[$5 | 0] = HEAP32[$3 + HEAP32[$1 >> 2] >> 2];
                HEAP8[$5 + 1 | 0] = HEAP32[$3 + HEAP32[$1 + 4 >> 2] >> 2];
                $3 = $3 | 4;
                HEAP8[$5 + 2 | 0] = HEAP32[$3 + HEAP32[$1 >> 2] >> 2];
                HEAP8[$5 + 3 | 0] = HEAP32[$3 + HEAP32[$1 + 4 >> 2] >> 2];
                $2 = $2 + 2 | 0;
                $5 = $5 + 4 | 0;
                $4 = $4 + 2 | 0;
                if (($6 | 0) != ($4 | 0)) {
                 continue
                }
                break;
               };
              }
              if (!$7) {
               break block26
              }
              $2 = $2 << 2;
              HEAP8[$5 | 0] = HEAP32[$2 + HEAP32[$1 >> 2] >> 2];
              HEAP8[$5 + 1 | 0] = HEAP32[$2 + HEAP32[$1 + 4 >> 2] >> 2];
              break block26;
             }
             if (!$3) {
              break block26
             }
             $6 = $3 & 3;
             $4 = 0;
             block40 : {
              if ($3 - 1 >>> 0 < 3) {
               $3 = 0;
               break block40;
              }
              $2 = $3 & -4;
              $3 = 0;
              while (1) {
               $7 = $3 << 2;
               HEAP8[$5 | 0] = HEAP32[$7 + HEAP32[$1 >> 2] >> 2];
               HEAP8[$5 + 1 | 0] = HEAP32[($7 + HEAP32[$1 >> 2] | 0) + 4 >> 2];
               HEAP8[$5 + 2 | 0] = HEAP32[($7 + HEAP32[$1 >> 2] | 0) + 8 >> 2];
               HEAP8[$5 + 3 | 0] = HEAP32[($7 + HEAP32[$1 >> 2] | 0) + 12 >> 2];
               $3 = $3 + 4 | 0;
               $5 = $5 + 4 | 0;
               $8 = $8 + 4 | 0;
               if (($2 | 0) != ($8 | 0)) {
                continue
               }
               break;
              };
             }
             if (!$6) {
              break block26
             }
             while (1) {
              HEAP8[$5 | 0] = HEAP32[HEAP32[$1 >> 2] + ($3 << 2) >> 2];
              $3 = $3 + 1 | 0;
              $5 = $5 + 1 | 0;
              $4 = $4 + 1 | 0;
              if (($6 | 0) != ($4 | 0)) {
               continue
              }
              break;
             };
             break block26;
            }
            $3 = $3 & -4;
            $1 = 0;
            while (1) {
             $7 = $4 + ($1 << 2) | 0;
             HEAP16[$5 >> 1] = HEAP32[$7 >> 2];
             HEAP16[$5 + 2 >> 1] = HEAP32[$7 + 4 >> 2];
             HEAP16[$5 + 4 >> 1] = HEAP32[$7 + 8 >> 2];
             HEAP16[$5 + 6 >> 1] = HEAP32[$7 + 12 >> 2];
             $1 = $1 + 4 | 0;
             $5 = $5 + 8 | 0;
             $8 = $8 + 4 | 0;
             if (($3 | 0) != ($8 | 0)) {
              continue
             }
             break;
            };
           }
           if (!$6) {
            break block26
           }
           while (1) {
            HEAP16[$5 >> 1] = HEAP32[$4 + ($1 << 2) >> 2];
            $1 = $1 + 1 | 0;
            $5 = $5 + 2 | 0;
            $2 = $2 + 1 | 0;
            if (($6 | 0) != ($2 | 0)) {
             continue
            }
            break;
           };
           break block26;
          }
          $3 = $3 & -4;
          $1 = 0;
          while (1) {
           $6 = $1 << 2;
           HEAP16[$5 >> 1] = HEAP32[$6 + $7 >> 2];
           HEAP16[$5 + 2 >> 1] = HEAP32[$6 + $9 >> 2];
           $2 = $6 | 4;
           HEAP16[$5 + 4 >> 1] = HEAP32[$2 + $7 >> 2];
           HEAP16[$5 + 6 >> 1] = HEAP32[$2 + $9 >> 2];
           $2 = $6 | 8;
           HEAP16[$5 + 8 >> 1] = HEAP32[$2 + $7 >> 2];
           HEAP16[$5 + 10 >> 1] = HEAP32[$2 + $9 >> 2];
           $2 = $6 | 12;
           HEAP16[$5 + 12 >> 1] = HEAP32[$2 + $7 >> 2];
           HEAP16[$5 + 14 >> 1] = HEAP32[$2 + $9 >> 2];
           $1 = $1 + 4 | 0;
           $5 = $5 + 16 | 0;
           $10 = $10 + 4 | 0;
           if (($3 | 0) != ($10 | 0)) {
            continue
           }
           break;
          };
         }
         if (!$4) {
          break block26
         }
         while (1) {
          $2 = $1 << 2;
          HEAP16[$5 >> 1] = HEAP32[$2 + $7 >> 2];
          HEAP16[$5 + 2 >> 1] = HEAP32[$2 + $9 >> 2];
          $1 = $1 + 1 | 0;
          $5 = $5 + 4 | 0;
          $8 = $8 + 1 | 0;
          if (($4 | 0) != ($8 | 0)) {
           continue
          }
          break;
         };
         break block26;
        }
        $3 = $3 & -4;
        $1 = 0;
        while (1) {
         $7 = $4 + ($1 << 2) | 0;
         HEAP32[$5 >> 2] = HEAP32[$7 >> 2];
         HEAP32[$5 + 4 >> 2] = HEAP32[$7 + 4 >> 2];
         HEAP32[$5 + 8 >> 2] = HEAP32[$7 + 8 >> 2];
         HEAP32[$5 + 12 >> 2] = HEAP32[$7 + 12 >> 2];
         $1 = $1 + 4 | 0;
         $5 = $5 + 16 | 0;
         $8 = $8 + 4 | 0;
         if (($3 | 0) != ($8 | 0)) {
          continue
         }
         break;
        };
       }
       if (!$6) {
        break block26
       }
       while (1) {
        HEAP32[$5 >> 2] = HEAP32[$4 + ($1 << 2) >> 2];
        $1 = $1 + 1 | 0;
        $5 = $5 + 4 | 0;
        $2 = $2 + 1 | 0;
        if (($6 | 0) != ($2 | 0)) {
         continue
        }
        break;
       };
       break block26;
      }
      $3 = $3 & -4;
      $1 = 0;
      while (1) {
       $6 = $1 << 2;
       HEAP32[$5 >> 2] = HEAP32[$6 + $7 >> 2];
       HEAP32[$5 + 4 >> 2] = HEAP32[$6 + $9 >> 2];
       $2 = $6 | 4;
       HEAP32[$5 + 8 >> 2] = HEAP32[$2 + $7 >> 2];
       HEAP32[$5 + 12 >> 2] = HEAP32[$2 + $9 >> 2];
       $2 = $6 | 8;
       HEAP32[$5 + 16 >> 2] = HEAP32[$2 + $7 >> 2];
       HEAP32[$5 + 20 >> 2] = HEAP32[$2 + $9 >> 2];
       $2 = $6 | 12;
       HEAP32[$5 + 24 >> 2] = HEAP32[$2 + $7 >> 2];
       HEAP32[$5 + 28 >> 2] = HEAP32[$2 + $9 >> 2];
       $1 = $1 + 4 | 0;
       $5 = $5 + 32 | 0;
       $10 = $10 + 4 | 0;
       if (($3 | 0) != ($10 | 0)) {
        continue
       }
       break;
      };
     }
     if (!$4) {
      break block26
     }
     while (1) {
      $2 = $1 << 2;
      HEAP32[$5 >> 2] = HEAP32[$2 + $7 >> 2];
      HEAP32[$5 + 4 >> 2] = HEAP32[$2 + $9 >> 2];
      $1 = $1 + 1 | 0;
      $5 = $5 + 8 | 0;
      $8 = $8 + 1 | 0;
      if (($4 | 0) != ($8 | 0)) {
       continue
      }
      break;
     };
     break block26;
    }
    block41 : {
     switch ($4 - 1 | 0) {
     case 3:
      if (!$2 | !$3) {
       break block26
      }
      $7 = $2 & -4;
      $9 = $2 & 3;
      $6 = $2 - 1 >>> 0 < 3;
      while (1) {
       $2 = 0;
       $11 = 0;
       if (!$6) {
        while (1) {
         $4 = $10 << 2;
         $8 = ($2 << 2) + $1 | 0;
         HEAP32[$5 >> 2] = HEAP32[$4 + HEAP32[$8 >> 2] >> 2];
         HEAP32[$5 + 4 >> 2] = HEAP32[$4 + HEAP32[$8 + 4 >> 2] >> 2];
         HEAP32[$5 + 8 >> 2] = HEAP32[$4 + HEAP32[$8 + 8 >> 2] >> 2];
         HEAP32[$5 + 12 >> 2] = HEAP32[$4 + HEAP32[$8 + 12 >> 2] >> 2];
         $2 = $2 + 4 | 0;
         $5 = $5 + 16 | 0;
         $11 = $11 + 4 | 0;
         if (($7 | 0) != ($11 | 0)) {
          continue
         }
         break;
        }
       }
       $4 = 0;
       if ($9) {
        while (1) {
         HEAP32[$5 >> 2] = HEAP32[HEAP32[($2 << 2) + $1 >> 2] + ($10 << 2) >> 2];
         $2 = $2 + 1 | 0;
         $5 = $5 + 4 | 0;
         $4 = $4 + 1 | 0;
         if (($9 | 0) != ($4 | 0)) {
          continue
         }
         break;
        }
       }
       $10 = $10 + 1 | 0;
       if (($10 | 0) != ($3 | 0)) {
        continue
       }
       break;
      };
      break block26;
     case 2:
      if (!$2 | !$3) {
       break block26
      }
      $8 = $2 & -2;
      $9 = $2 & 1;
      while (1) {
       $4 = 0;
       $10 = 0;
       if (($2 | 0) != 1) {
        while (1) {
         $6 = $13 << 2;
         $7 = ($4 << 2) + $1 | 0;
         $11 = HEAP32[$6 + HEAP32[$7 >> 2] >> 2];
         HEAP8[$5 | 0] = $11;
         HEAP8[$5 + 2 | 0] = $11 >>> 16;
         HEAP8[$5 + 1 | 0] = $11 >>> 8;
         $6 = HEAP32[$6 + HEAP32[$7 + 4 >> 2] >> 2];
         HEAP8[$5 + 3 | 0] = $6;
         HEAP8[$5 + 5 | 0] = $6 >>> 16;
         HEAP8[$5 + 4 | 0] = $6 >>> 8;
         $4 = $4 + 2 | 0;
         $5 = $5 + 6 | 0;
         $10 = $10 + 2 | 0;
         if (($8 | 0) != ($10 | 0)) {
          continue
         }
         break;
        }
       }
       if ($9) {
        $4 = HEAP32[HEAP32[($4 << 2) + $1 >> 2] + ($13 << 2) >> 2];
        HEAP8[$5 | 0] = $4;
        HEAP8[$5 + 2 | 0] = $4 >>> 16;
        HEAP8[$5 + 1 | 0] = $4 >>> 8;
        $5 = $5 + 3 | 0;
       }
       $13 = $13 + 1 | 0;
       if (($13 | 0) != ($3 | 0)) {
        continue
       }
       break;
      };
      break block26;
     case 1:
      if (!$2 | !$3) {
       break block26
      }
      $7 = $2 & -4;
      $9 = $2 & 3;
      $6 = $2 - 1 >>> 0 < 3;
      while (1) {
       $2 = 0;
       $11 = 0;
       if (!$6) {
        while (1) {
         $4 = $10 << 2;
         $8 = ($2 << 2) + $1 | 0;
         HEAP16[$5 >> 1] = HEAP32[$4 + HEAP32[$8 >> 2] >> 2];
         HEAP16[$5 + 2 >> 1] = HEAP32[$4 + HEAP32[$8 + 4 >> 2] >> 2];
         HEAP16[$5 + 4 >> 1] = HEAP32[$4 + HEAP32[$8 + 8 >> 2] >> 2];
         HEAP16[$5 + 6 >> 1] = HEAP32[$4 + HEAP32[$8 + 12 >> 2] >> 2];
         $2 = $2 + 4 | 0;
         $5 = $5 + 8 | 0;
         $11 = $11 + 4 | 0;
         if (($7 | 0) != ($11 | 0)) {
          continue
         }
         break;
        }
       }
       $4 = 0;
       if ($9) {
        while (1) {
         HEAP16[$5 >> 1] = HEAP32[HEAP32[($2 << 2) + $1 >> 2] + ($10 << 2) >> 2];
         $2 = $2 + 1 | 0;
         $5 = $5 + 2 | 0;
         $4 = $4 + 1 | 0;
         if (($9 | 0) != ($4 | 0)) {
          continue
         }
         break;
        }
       }
       $10 = $10 + 1 | 0;
       if (($10 | 0) != ($3 | 0)) {
        continue
       }
       break;
      };
      break block26;
     case 0:
      break block41;
     default:
      break block26;
     };
    }
    if (!$2 | !$3) {
     break block26
    }
    $7 = $2 & -4;
    $9 = $2 & 3;
    $6 = $2 - 1 >>> 0 < 3;
    while (1) {
     $2 = 0;
     $11 = 0;
     if (!$6) {
      while (1) {
       $4 = $10 << 2;
       $8 = ($2 << 2) + $1 | 0;
       HEAP8[$5 | 0] = HEAP32[$4 + HEAP32[$8 >> 2] >> 2];
       HEAP8[$5 + 1 | 0] = HEAP32[$4 + HEAP32[$8 + 4 >> 2] >> 2];
       HEAP8[$5 + 2 | 0] = HEAP32[$4 + HEAP32[$8 + 8 >> 2] >> 2];
       HEAP8[$5 + 3 | 0] = HEAP32[$4 + HEAP32[$8 + 12 >> 2] >> 2];
       $2 = $2 + 4 | 0;
       $5 = $5 + 4 | 0;
       $11 = $11 + 4 | 0;
       if (($7 | 0) != ($11 | 0)) {
        continue
       }
       break;
      }
     }
     $4 = 0;
     if ($9) {
      while (1) {
       HEAP8[$5 | 0] = HEAP32[HEAP32[($2 << 2) + $1 >> 2] + ($10 << 2) >> 2];
       $2 = $2 + 1 | 0;
       $5 = $5 + 1 | 0;
       $4 = $4 + 1 | 0;
       if (($9 | 0) != ($4 | 0)) {
        continue
       }
       break;
      }
     }
     $10 = $10 + 1 | 0;
     if (($10 | 0) != ($3 | 0)) {
      continue
     }
     break;
    };
   }
   $4 = HEAP32[$0 + 80 >> 2];
   $1 = $4 + $12 | 0;
   HEAP32[$0 + 80 >> 2] = $1;
   if ($1 >>> 0 < $4 >>> 0) {
    HEAP32[$0 + 84 >> 2] = HEAP32[$0 + 84 >> 2] + 1
   }
   $3 = HEAP32[$0 + 88 >> 2];
   $2 = $0 - -64 | 0;
   $1 = $2 + ($4 | -64) | 0;
   $4 = 64 - ($4 & 63) | 0;
   block55 : {
    if ($12 >>> 0 < $4 >>> 0) {
     if (!$12) {
      break block55
     }
     wasm2js_memory_copy($1, $3, $12);
     break block55;
    }
    if ($4) {
     wasm2js_memory_copy($1, $3, $4)
    }
    FLAC__MD5Transform($2, $0);
    $5 = $3 + $4 | 0;
    $1 = $12 - $4 | 0;
    if ($1 >>> 0 >= 64) {
     while (1) {
      $4 = HEAPU8[$5 + 4 | 0] | HEAPU8[$5 + 5 | 0] << 8 | (HEAPU8[$5 + 6 | 0] << 16 | HEAPU8[$5 + 7 | 0] << 24);
      $3 = HEAPU8[$5 | 0] | HEAPU8[$5 + 1 | 0] << 8 | (HEAPU8[$5 + 2 | 0] << 16 | HEAPU8[$5 + 3 | 0] << 24);
      HEAP8[$0 | 0] = $3;
      HEAP8[$0 + 1 | 0] = $3 >>> 8;
      HEAP8[$0 + 2 | 0] = $3 >>> 16;
      HEAP8[$0 + 3 | 0] = $3 >>> 24;
      HEAP8[$0 + 4 | 0] = $4;
      HEAP8[$0 + 5 | 0] = $4 >>> 8;
      HEAP8[$0 + 6 | 0] = $4 >>> 16;
      HEAP8[$0 + 7 | 0] = $4 >>> 24;
      $3 = $5 + 56 | 0;
      $4 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
      $6 = $0 + 56 | 0;
      $3 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
      HEAP8[$6 | 0] = $3;
      HEAP8[$6 + 1 | 0] = $3 >>> 8;
      HEAP8[$6 + 2 | 0] = $3 >>> 16;
      HEAP8[$6 + 3 | 0] = $3 >>> 24;
      HEAP8[$6 + 4 | 0] = $4;
      HEAP8[$6 + 5 | 0] = $4 >>> 8;
      HEAP8[$6 + 6 | 0] = $4 >>> 16;
      HEAP8[$6 + 7 | 0] = $4 >>> 24;
      $3 = $5 + 48 | 0;
      $4 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
      $6 = $0 + 48 | 0;
      $3 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
      HEAP8[$6 | 0] = $3;
      HEAP8[$6 + 1 | 0] = $3 >>> 8;
      HEAP8[$6 + 2 | 0] = $3 >>> 16;
      HEAP8[$6 + 3 | 0] = $3 >>> 24;
      HEAP8[$6 + 4 | 0] = $4;
      HEAP8[$6 + 5 | 0] = $4 >>> 8;
      HEAP8[$6 + 6 | 0] = $4 >>> 16;
      HEAP8[$6 + 7 | 0] = $4 >>> 24;
      $3 = $5 + 40 | 0;
      $4 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
      $6 = $0 + 40 | 0;
      $3 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
      HEAP8[$6 | 0] = $3;
      HEAP8[$6 + 1 | 0] = $3 >>> 8;
      HEAP8[$6 + 2 | 0] = $3 >>> 16;
      HEAP8[$6 + 3 | 0] = $3 >>> 24;
      HEAP8[$6 + 4 | 0] = $4;
      HEAP8[$6 + 5 | 0] = $4 >>> 8;
      HEAP8[$6 + 6 | 0] = $4 >>> 16;
      HEAP8[$6 + 7 | 0] = $4 >>> 24;
      $3 = $5 + 32 | 0;
      $4 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
      $6 = $0 + 32 | 0;
      $3 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
      HEAP8[$6 | 0] = $3;
      HEAP8[$6 + 1 | 0] = $3 >>> 8;
      HEAP8[$6 + 2 | 0] = $3 >>> 16;
      HEAP8[$6 + 3 | 0] = $3 >>> 24;
      HEAP8[$6 + 4 | 0] = $4;
      HEAP8[$6 + 5 | 0] = $4 >>> 8;
      HEAP8[$6 + 6 | 0] = $4 >>> 16;
      HEAP8[$6 + 7 | 0] = $4 >>> 24;
      $3 = $5 + 24 | 0;
      $4 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
      $6 = $0 + 24 | 0;
      $3 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
      HEAP8[$6 | 0] = $3;
      HEAP8[$6 + 1 | 0] = $3 >>> 8;
      HEAP8[$6 + 2 | 0] = $3 >>> 16;
      HEAP8[$6 + 3 | 0] = $3 >>> 24;
      HEAP8[$6 + 4 | 0] = $4;
      HEAP8[$6 + 5 | 0] = $4 >>> 8;
      HEAP8[$6 + 6 | 0] = $4 >>> 16;
      HEAP8[$6 + 7 | 0] = $4 >>> 24;
      $3 = $5 + 16 | 0;
      $4 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
      $6 = $0 + 16 | 0;
      $3 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
      HEAP8[$6 | 0] = $3;
      HEAP8[$6 + 1 | 0] = $3 >>> 8;
      HEAP8[$6 + 2 | 0] = $3 >>> 16;
      HEAP8[$6 + 3 | 0] = $3 >>> 24;
      HEAP8[$6 + 4 | 0] = $4;
      HEAP8[$6 + 5 | 0] = $4 >>> 8;
      HEAP8[$6 + 6 | 0] = $4 >>> 16;
      HEAP8[$6 + 7 | 0] = $4 >>> 24;
      $3 = $5 + 8 | 0;
      $4 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
      $6 = $0 + 8 | 0;
      $3 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
      HEAP8[$6 | 0] = $3;
      HEAP8[$6 + 1 | 0] = $3 >>> 8;
      HEAP8[$6 + 2 | 0] = $3 >>> 16;
      HEAP8[$6 + 3 | 0] = $3 >>> 24;
      HEAP8[$6 + 4 | 0] = $4;
      HEAP8[$6 + 5 | 0] = $4 >>> 8;
      HEAP8[$6 + 6 | 0] = $4 >>> 16;
      HEAP8[$6 + 7 | 0] = $4 >>> 24;
      FLAC__MD5Transform($2, $0);
      $5 = $5 - -64 | 0;
      $1 = $1 + -64 | 0;
      if ($1 >>> 0 > 63) {
       continue
      }
      break;
     }
    }
    if (!$1) {
     break block55
    }
    wasm2js_memory_copy($0, $5, $1);
   }
   $5 = 1;
  }
  return $5;
 }
 
 function __wasi_syscall_ret($0) {
  if (!$0) {
   return 0
  }
  HEAP32[4484] = $0;
  return -1;
 }
 
 function __stdio_close($0) {
  $0 = $0 | 0;
  return __wasi_syscall_ret(__wasi_fd_close(HEAP32[$0 + 60 >> 2]) | 0) | 0;
 }
 
 function __stdio_read($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $4 = __stack_pointer - 32 | 0;
  __stack_pointer = $4;
  HEAP32[$4 + 16 >> 2] = $1;
  $3 = HEAP32[$0 + 48 >> 2];
  HEAP32[$4 + 20 >> 2] = $2 - (($3 | 0) != 0);
  $6 = HEAP32[$0 + 44 >> 2];
  HEAP32[$4 + 28 >> 2] = $3;
  HEAP32[$4 + 24 >> 2] = $6;
  $3 = 32;
  block2 : {
   block1 : {
    if (!__wasi_syscall_ret(__wasi_fd_read(HEAP32[$0 + 60 >> 2], $4 + 16 | 0, 2, $4 + 12 | 0) | 0)) {
     $3 = HEAP32[$4 + 12 >> 2];
     if (($3 | 0) > 0) {
      break block1
     }
     $3 = $3 ? 32 : 16;
    }
    HEAP32[$0 >> 2] = $3 | HEAP32[$0 >> 2];
    break block2;
   }
   $5 = $3;
   $6 = HEAP32[$4 + 20 >> 2];
   if ($6 >>> 0 >= $3 >>> 0) {
    break block2
   }
   $5 = HEAP32[$0 + 44 >> 2];
   HEAP32[$0 + 4 >> 2] = $5;
   HEAP32[$0 + 8 >> 2] = $5 + ($3 - $6 | 0);
   if (HEAP32[$0 + 48 >> 2]) {
    HEAP32[$0 + 4 >> 2] = $5 + 1;
    HEAP8[($1 + $2 | 0) - 1 | 0] = HEAPU8[$5 | 0];
   }
   $5 = $2;
  }
  __stack_pointer = $4 + 32 | 0;
  return $5 | 0;
 }
 
 function __stdio_seek($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  $0 = __wasi_syscall_ret(legalimport$__wasi_fd_seek(HEAP32[$0 + 60 >> 2], $1 | 0, $2 | 0, $3 & 255, $4 + 8 | 0) | 0);
  __stack_pointer = $4 + 16 | 0;
  i64toi32_i32$HIGH_BITS = $0 ? -1 : HEAP32[$4 + 12 >> 2];
  return ($0 ? -1 : HEAP32[$4 + 8 >> 2]) | 0;
 }
 
 function fflush($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  if (!$0) {
   if (HEAP32[4380]) {
    $1 = fflush(HEAP32[4380])
   }
   if (HEAP32[4611]) {
    $1 = fflush(HEAP32[4611]) | $1
   }
   $0 = HEAP32[4610];
   if ($0) {
    while (1) {
     if (HEAP32[$0 + 20 >> 2] != HEAP32[$0 + 28 >> 2]) {
      $1 = fflush($0) | $1
     }
     $0 = HEAP32[$0 + 56 >> 2];
     if ($0) {
      continue
     }
     break;
    }
   }
   return $1;
  }
  $3 = HEAP32[$0 + 76 >> 2] < 0;
  block12 : {
   block10 : {
    if (HEAP32[$0 + 20 >> 2] == HEAP32[$0 + 28 >> 2]) {
     break block10
    }
    FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]]($0, 0, 0) | 0;
    if (HEAP32[$0 + 20 >> 2]) {
     break block10
    }
    $1 = -1;
    break block12;
   }
   $1 = HEAP32[$0 + 8 >> 2];
   $2 = HEAP32[$0 + 4 >> 2];
   if (($1 | 0) != ($2 | 0)) {
    $1 = $2 - $1 | 0;
    FUNCTION_TABLE[HEAP32[$0 + 40 >> 2]]($0, $1, $1 >> 31, 1) | 0;
   }
   $1 = 0;
   HEAP32[$0 + 28 >> 2] = 0;
   HEAP32[$0 + 16 >> 2] = 0;
   HEAP32[$0 + 20 >> 2] = 0;
   HEAP32[$0 + 4 >> 2] = 0;
   HEAP32[$0 + 8 >> 2] = 0;
   if ($3) {
    break block12
   }
  }
  return $1;
 }
 
 function fclose($0) {
  var $1 = 0, $2 = 0;
  fflush($0);
  FUNCTION_TABLE[HEAP32[$0 + 12 >> 2]]($0) | 0;
  if (!(HEAP8[$0 | 0] & 1)) {
   $1 = HEAP32[$0 + 56 >> 2];
   $2 = HEAP32[$0 + 52 >> 2];
   if ($2) {
    HEAP32[$2 + 56 >> 2] = $1
   }
   if ($1) {
    HEAP32[$1 + 52 >> 2] = $2
   }
   if (($0 | 0) == HEAP32[4610]) {
    HEAP32[4610] = $1
   }
   emscripten_builtin_free(HEAP32[$0 + 96 >> 2]);
   emscripten_builtin_free($0);
  }
 }
 
 function memcmp($0, $1, $2) {
  var $3 = 0, $4 = 0;
  block2 : {
   block1 : {
    if ($2 >>> 0 >= 4) {
     if (($0 | $1) & 3) {
      break block1
     }
     while (1) {
      if (HEAP32[$0 >> 2] != HEAP32[$1 >> 2]) {
       break block1
      }
      $1 = $1 + 4 | 0;
      $0 = $0 + 4 | 0;
      $2 = $2 - 4 | 0;
      if ($2 >>> 0 > 3) {
       continue
      }
      break;
     };
    }
    if (!$2) {
     break block2
    }
   }
   while (1) {
    $3 = HEAPU8[$0 | 0];
    $4 = HEAPU8[$1 | 0];
    if (($3 | 0) == ($4 | 0)) {
     $1 = $1 + 1 | 0;
     $0 = $0 + 1 | 0;
     $2 = $2 - 1 | 0;
     if ($2) {
      continue
     }
     break block2;
    }
    break;
   };
   return $3 - $4 | 0;
  }
  return 0;
 }
 
 function FLAC__cpu_info($0) {
  var $1 = 0;
  HEAP32[$0 + 8 >> 2] = 0;
  HEAP32[$0 + 12 >> 2] = 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 3;
  $1 = $0 + 56 | 0;
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = 0;
  $1 = $0 + 48 | 0;
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = 0;
  $1 = $0 + 40 | 0;
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = 0;
  $1 = $0 + 32 | 0;
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = 0;
  $1 = $0 + 24 | 0;
  HEAP32[$1 >> 2] = 0;
  HEAP32[$1 + 4 >> 2] = 0;
  $0 = $0 + 16 | 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
 }
 
 function lround($0) {
  var $1 = 0.0, $2 = 0, $3 = 0;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $3 = $2 >>> 20 & 2047;
  __inlined_func$round$34 : {
   if ($3 >>> 0 <= 1074) {
    $1 = $0 * 0.0;
    if ($3 >>> 0 <= 1021) {
     break __inlined_func$round$34
    }
    $0 = Math_abs($0);
    $1 = $0 + 4503599627370496.0 + -4503599627370496.0 - $0;
    block3 : {
     if ($1 > .5) {
      $0 = $0 + $1 + -1.0;
      break block3;
     }
     $0 = $0 + $1;
     if (!($1 <= -.5)) {
      break block3
     }
     $0 = $0 + 1.0;
    }
    $0 = ($2 | 0) < 0 ? -$0 : $0;
   }
   $1 = $0;
  }
  $0 = $1;
  if (Math_abs($0) < 2147483647.0) {
   $2 = ~~$0
  } else {
   $2 = -2147483648
  }
  return $2;
 }
 
 function fp_barrier($0) {
  var $1 = 0;
  $1 = __stack_pointer - 16 | 0;
  HEAPF64[$1 + 8 >> 3] = $0;
  return HEAPF64[$1 + 8 >> 3];
 }
 
 function log($0) {
  var $1 = 0, $2 = 0.0, $3 = 0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0, $8 = 0.0, $9 = 0.0, $10 = 0;
  wasm2js_scratch_store_f64(+$0);
  $3 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $1 = $3 >>> 16 | 0;
  wasm2js_scratch_store_f64(+$0);
  $3 = wasm2js_scratch_load_i32(1) | 0;
  $7 = wasm2js_scratch_load_i32(0) | 0;
  if ($3 - 1072562176 >>> 0 <= 198911) {
   if (!(($7 | 0) != 0 | ($3 | 0) != 1072693248)) {
    return 0.0
   }
   $0 = $0 + -1.0;
   $2 = $0 * 134217728.0;
   $2 = $0 + $2 - $2;
   $6 = HEAPF64[987];
   $8 = $2 * $2 * $6;
   $9 = $0 + $8;
   $4 = $0 * $0;
   $5 = $0 * $4;
   return $9 + ($5 * ($5 * ($5 * ($5 * HEAPF64[997] + ($4 * HEAPF64[996] + ($0 * HEAPF64[995] + HEAPF64[994]))) + ($4 * HEAPF64[993] + ($0 * HEAPF64[992] + HEAPF64[991]))) + ($4 * HEAPF64[990] + ($0 * HEAPF64[989] + HEAPF64[988]))) + (($0 - $2) * $6 * ($0 + $2) + ($8 + ($0 - $9))));
  }
  block4 : {
   if ($1 - 32752 >>> 0 <= 4294934559) {
    if ($0 == 0.0) {
     return fp_barrier(-1.0) / 0.0
    }
    if (!$7 & ($3 | 0) == 2146435072) {
     break block4
    }
    if (!(($1 & 32752) != 32752 & $1 >>> 0 <= 32767)) {
     $0 = $0 - $0;
     return $0 / $0;
    }
    wasm2js_scratch_store_f64(+($0 * 4503599627370496.0));
    $3 = wasm2js_scratch_load_i32(1) | 0;
    $7 = wasm2js_scratch_load_i32(0) | 0;
    $3 = $3 - 54525952 | 0;
   }
   $1 = $3 - 1072037888 | 0;
   $10 = $1;
   $4 = +($1 >> 20);
   $1 = ($1 >>> 13 & 127) << 4;
   $5 = $4 * HEAPF64[980] + HEAPF64[$1 + 7992 >> 3];
   $0 = HEAPF64[$1 + 7984 >> 3];
   wasm2js_scratch_store_i32(0, $7 | 0);
   wasm2js_scratch_store_i32(1, $3 - ($10 & -1048576) | 0);
   $0 = $0 * (+wasm2js_scratch_load_f64() - HEAPF64[$1 + 10032 >> 3] - HEAPF64[$1 + 10040 >> 3]);
   $6 = $5 + $0;
   $2 = $0 * $0;
   $0 = $6 + ($0 * $2 * ($2 * ($0 * HEAPF64[986] + HEAPF64[985]) + ($0 * HEAPF64[984] + HEAPF64[983])) + ($2 * HEAPF64[982] + ($4 * HEAPF64[981] + ($0 + ($5 - $6)))));
  }
  return $0;
 }
 
 function FLAC__lpc_compute_autocorrelation($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = Math_fround(0), $11 = 0, $12 = 0, $13 = 0;
  block4 : {
   if ($2) {
    $4 = $2 << 2;
    if ($4) {
     wasm2js_memory_fill($3, 0, $4)
    }
    $12 = $1 - $2 | 0;
    $13 = $2 & -2;
    $9 = $2 & 1;
    while (1) {
     $6 = ($8 << 2) + $0 | 0;
     $10 = HEAPF32[$6 >> 2];
     $4 = 0;
     $5 = 0;
     if (($2 | 0) != 1) {
      while (1) {
       $7 = $4 << 2;
       $11 = $7 + $3 | 0;
       HEAPF32[$11 >> 2] = Math_fround($10 * HEAPF32[$6 + $7 >> 2]) + HEAPF32[$11 >> 2];
       $7 = $7 | 4;
       $11 = $7 + $3 | 0;
       HEAPF32[$11 >> 2] = Math_fround($10 * HEAPF32[$6 + $7 >> 2]) + HEAPF32[$11 >> 2];
       $4 = $4 + 2 | 0;
       $5 = $5 + 2 | 0;
       if (($13 | 0) != ($5 | 0)) {
        continue
       }
       break;
      }
     }
     if ($9) {
      $4 = $4 << 2;
      $5 = $4 + $3 | 0;
      HEAPF32[$5 >> 2] = Math_fround($10 * HEAPF32[$4 + $6 >> 2]) + HEAPF32[$5 >> 2];
     }
     $4 = $8 >>> 0 < $12 >>> 0;
     $6 = $8 + 1 | 0;
     $8 = $6;
     if ($4) {
      continue
     }
     break;
    };
    break block4;
   }
   $2 = $1 + 1 | 0;
   $6 = $2 >>> 0 <= 1 ? 1 : $2;
  }
  if ($1 >>> 0 > $6 >>> 0) {
   $8 = $1 - $6 | 0;
   while (1) {
    $5 = $8 >>> 0 <= 1 ? 1 : $8;
    $12 = $5 & 1;
    $2 = ($6 << 2) + $0 | 0;
    $10 = HEAPF32[$2 >> 2];
    $4 = 0;
    if ($8 >>> 0 >= 2) {
     $13 = $5 & -2;
     $5 = 0;
     while (1) {
      $7 = $4 << 2;
      $9 = $7 + $3 | 0;
      HEAPF32[$9 >> 2] = Math_fround($10 * HEAPF32[$2 + $7 >> 2]) + HEAPF32[$9 >> 2];
      $7 = $7 | 4;
      $9 = $7 + $3 | 0;
      HEAPF32[$9 >> 2] = Math_fround($10 * HEAPF32[$2 + $7 >> 2]) + HEAPF32[$9 >> 2];
      $4 = $4 + 2 | 0;
      $5 = $5 + 2 | 0;
      if (($13 | 0) != ($5 | 0)) {
       continue
      }
      break;
     };
    }
    if ($12) {
     $4 = $4 << 2;
     $5 = $4 + $3 | 0;
     HEAPF32[$5 >> 2] = Math_fround($10 * HEAPF32[$2 + $4 >> 2]) + HEAPF32[$5 >> 2];
    }
    $8 = $8 - 1 | 0;
    $6 = $6 + 1 | 0;
    if (($6 | 0) != ($1 | 0)) {
     continue
    }
    break;
   };
  }
 }
 
 function FLAC__lpc_compute_residual_from_qlp_coefficients($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0;
  block1 : {
   if ($3 >>> 0 >= 13) {
    if (($1 | 0) <= 0) {
     break block1
    }
    $7 = $0 - 56 | 0;
    $8 = $0 - 60 | 0;
    $9 = $0 + -64 | 0;
    $10 = $0 - 68 | 0;
    $11 = $0 - 72 | 0;
    $12 = $0 - 76 | 0;
    $13 = $0 - 80 | 0;
    $14 = $0 - 84 | 0;
    $15 = $0 - 88 | 0;
    $16 = $0 - 92 | 0;
    $17 = $0 - 96 | 0;
    $18 = $0 - 100 | 0;
    $20 = $0 - 104 | 0;
    $21 = $0 - 108 | 0;
    $22 = $0 - 112 | 0;
    $23 = $0 - 116 | 0;
    $24 = $0 - 120 | 0;
    $25 = $0 - 124 | 0;
    $26 = $0 - 128 | 0;
    $27 = $3 - 13 | 0;
    while (1) {
     $3 = 0;
     block22 : {
      switch ($27 | 0) {
      case 19:
       $3 = Math_imul(HEAP32[($6 << 2) + $26 >> 2], HEAP32[$2 + 124 >> 2]);
      case 18:
       $3 = Math_imul(HEAP32[($6 << 2) + $25 >> 2], HEAP32[$2 + 120 >> 2]) + $3 | 0;
      case 17:
       $3 = Math_imul(HEAP32[($6 << 2) + $24 >> 2], HEAP32[$2 + 116 >> 2]) + $3 | 0;
      case 16:
       $3 = Math_imul(HEAP32[($6 << 2) + $23 >> 2], HEAP32[$2 + 112 >> 2]) + $3 | 0;
      case 15:
       $3 = Math_imul(HEAP32[($6 << 2) + $22 >> 2], HEAP32[$2 + 108 >> 2]) + $3 | 0;
      case 14:
       $3 = Math_imul(HEAP32[($6 << 2) + $21 >> 2], HEAP32[$2 + 104 >> 2]) + $3 | 0;
      case 13:
       $3 = Math_imul(HEAP32[($6 << 2) + $20 >> 2], HEAP32[$2 + 100 >> 2]) + $3 | 0;
      case 12:
       $3 = Math_imul(HEAP32[($6 << 2) + $18 >> 2], HEAP32[$2 + 96 >> 2]) + $3 | 0;
      case 11:
       $3 = Math_imul(HEAP32[($6 << 2) + $17 >> 2], HEAP32[$2 + 92 >> 2]) + $3 | 0;
      case 10:
       $3 = Math_imul(HEAP32[($6 << 2) + $16 >> 2], HEAP32[$2 + 88 >> 2]) + $3 | 0;
      case 9:
       $3 = Math_imul(HEAP32[($6 << 2) + $15 >> 2], HEAP32[$2 + 84 >> 2]) + $3 | 0;
      case 8:
       $3 = Math_imul(HEAP32[($6 << 2) + $14 >> 2], HEAP32[$2 + 80 >> 2]) + $3 | 0;
      case 7:
       $3 = Math_imul(HEAP32[($6 << 2) + $13 >> 2], HEAP32[$2 + 76 >> 2]) + $3 | 0;
      case 6:
       $3 = Math_imul(HEAP32[($6 << 2) + $12 >> 2], HEAP32[$2 + 72 >> 2]) + $3 | 0;
      case 5:
       $3 = Math_imul(HEAP32[($6 << 2) + $11 >> 2], HEAP32[$2 + 68 >> 2]) + $3 | 0;
      case 4:
       $3 = Math_imul(HEAP32[($6 << 2) + $10 >> 2], HEAP32[$2 + 64 >> 2]) + $3 | 0;
      case 3:
       $3 = Math_imul(HEAP32[($6 << 2) + $9 >> 2], HEAP32[$2 + 60 >> 2]) + $3 | 0;
      case 2:
       $3 = Math_imul(HEAP32[($6 << 2) + $8 >> 2], HEAP32[$2 + 56 >> 2]) + $3 | 0;
      case 1:
       $3 = Math_imul(HEAP32[($6 << 2) + $7 >> 2], HEAP32[$2 + 52 >> 2]) + $3 | 0;
      case 0:
       $19 = $3;
       $3 = ($6 << 2) + $0 | 0;
       $3 = (((((((((((($19 + Math_imul(HEAP32[$3 - 52 >> 2], HEAP32[$2 + 48 >> 2]) | 0) + Math_imul(HEAP32[$3 - 48 >> 2], HEAP32[$2 + 44 >> 2]) | 0) + Math_imul(HEAP32[$3 - 44 >> 2], HEAP32[$2 + 40 >> 2]) | 0) + Math_imul(HEAP32[$3 - 40 >> 2], HEAP32[$2 + 36 >> 2]) | 0) + Math_imul(HEAP32[$3 - 36 >> 2], HEAP32[$2 + 32 >> 2]) | 0) + Math_imul(HEAP32[$3 - 32 >> 2], HEAP32[$2 + 28 >> 2]) | 0) + Math_imul(HEAP32[$3 - 28 >> 2], HEAP32[$2 + 24 >> 2]) | 0) + Math_imul(HEAP32[$3 - 24 >> 2], HEAP32[$2 + 20 >> 2]) | 0) + Math_imul(HEAP32[$3 - 20 >> 2], HEAP32[$2 + 16 >> 2]) | 0) + Math_imul(HEAP32[$3 - 16 >> 2], HEAP32[$2 + 12 >> 2]) | 0) + Math_imul(HEAP32[$3 - 12 >> 2], HEAP32[$2 + 8 >> 2]) | 0) + Math_imul(HEAP32[$3 - 8 >> 2], HEAP32[$2 + 4 >> 2]) | 0) + Math_imul(HEAP32[$3 - 4 >> 2], HEAP32[$2 >> 2]) | 0;
       break;
      default:
       break block22;
      };
     }
     $19 = $6 << 2;
     HEAP32[$19 + $5 >> 2] = HEAP32[$0 + $19 >> 2] - ($3 >> $4);
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if ($3 >>> 0 >= 9) {
    if ($3 >>> 0 >= 11) {
     if (($3 | 0) != 12) {
      if (($1 | 0) <= 0) {
       break block1
      }
      $3 = HEAP32[$2 >> 2];
      $7 = HEAP32[$2 + 4 >> 2];
      $8 = HEAP32[$2 + 8 >> 2];
      $9 = HEAP32[$2 + 12 >> 2];
      $10 = HEAP32[$2 + 16 >> 2];
      $11 = HEAP32[$2 + 20 >> 2];
      $12 = HEAP32[$2 + 24 >> 2];
      $13 = HEAP32[$2 + 28 >> 2];
      $14 = HEAP32[$2 + 32 >> 2];
      $15 = HEAP32[$2 + 36 >> 2];
      $16 = HEAP32[$2 + 40 >> 2];
      while (1) {
       $17 = $6 << 2;
       $2 = $17 + $0 | 0;
       HEAP32[$5 + $17 >> 2] = HEAP32[$2 >> 2] - ((((((((((Math_imul($15, HEAP32[$2 - 40 >> 2]) + Math_imul($16, HEAP32[$2 - 44 >> 2]) | 0) + Math_imul($14, HEAP32[$2 - 36 >> 2]) | 0) + Math_imul($13, HEAP32[$2 - 32 >> 2]) | 0) + Math_imul($12, HEAP32[$2 - 28 >> 2]) | 0) + Math_imul($11, HEAP32[$2 - 24 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($7, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, HEAP32[$2 - 4 >> 2]) >> $4);
       $6 = $6 + 1 | 0;
       if (($6 | 0) != ($1 | 0)) {
        continue
       }
       break;
      };
      break block1;
     }
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$2 >> 2];
     $7 = HEAP32[$2 + 4 >> 2];
     $8 = HEAP32[$2 + 8 >> 2];
     $9 = HEAP32[$2 + 12 >> 2];
     $10 = HEAP32[$2 + 16 >> 2];
     $11 = HEAP32[$2 + 20 >> 2];
     $12 = HEAP32[$2 + 24 >> 2];
     $13 = HEAP32[$2 + 28 >> 2];
     $14 = HEAP32[$2 + 32 >> 2];
     $15 = HEAP32[$2 + 36 >> 2];
     $16 = HEAP32[$2 + 40 >> 2];
     $17 = HEAP32[$2 + 44 >> 2];
     while (1) {
      $18 = $6 << 2;
      $2 = $18 + $0 | 0;
      HEAP32[$5 + $18 >> 2] = HEAP32[$2 >> 2] - (((((((((((Math_imul($16, HEAP32[$2 - 44 >> 2]) + Math_imul($17, HEAP32[$2 - 48 >> 2]) | 0) + Math_imul($15, HEAP32[$2 - 40 >> 2]) | 0) + Math_imul($14, HEAP32[$2 - 36 >> 2]) | 0) + Math_imul($13, HEAP32[$2 - 32 >> 2]) | 0) + Math_imul($12, HEAP32[$2 - 28 >> 2]) | 0) + Math_imul($11, HEAP32[$2 - 24 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($7, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, HEAP32[$2 - 4 >> 2]) >> $4);
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($3 | 0) != 10) {
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$2 >> 2];
     $7 = HEAP32[$2 + 4 >> 2];
     $8 = HEAP32[$2 + 8 >> 2];
     $9 = HEAP32[$2 + 12 >> 2];
     $10 = HEAP32[$2 + 16 >> 2];
     $11 = HEAP32[$2 + 20 >> 2];
     $12 = HEAP32[$2 + 24 >> 2];
     $13 = HEAP32[$2 + 28 >> 2];
     $14 = HEAP32[$2 + 32 >> 2];
     while (1) {
      $15 = $6 << 2;
      $2 = $15 + $0 | 0;
      HEAP32[$5 + $15 >> 2] = HEAP32[$2 >> 2] - ((((((((Math_imul($13, HEAP32[$2 - 32 >> 2]) + Math_imul($14, HEAP32[$2 - 36 >> 2]) | 0) + Math_imul($12, HEAP32[$2 - 28 >> 2]) | 0) + Math_imul($11, HEAP32[$2 - 24 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($7, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, HEAP32[$2 - 4 >> 2]) >> $4);
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($1 | 0) <= 0) {
     break block1
    }
    $3 = HEAP32[$2 >> 2];
    $7 = HEAP32[$2 + 4 >> 2];
    $8 = HEAP32[$2 + 8 >> 2];
    $9 = HEAP32[$2 + 12 >> 2];
    $10 = HEAP32[$2 + 16 >> 2];
    $11 = HEAP32[$2 + 20 >> 2];
    $12 = HEAP32[$2 + 24 >> 2];
    $13 = HEAP32[$2 + 28 >> 2];
    $14 = HEAP32[$2 + 32 >> 2];
    $15 = HEAP32[$2 + 36 >> 2];
    while (1) {
     $16 = $6 << 2;
     $2 = $16 + $0 | 0;
     HEAP32[$5 + $16 >> 2] = HEAP32[$2 >> 2] - (((((((((Math_imul($14, HEAP32[$2 - 36 >> 2]) + Math_imul($15, HEAP32[$2 - 40 >> 2]) | 0) + Math_imul($13, HEAP32[$2 - 32 >> 2]) | 0) + Math_imul($12, HEAP32[$2 - 28 >> 2]) | 0) + Math_imul($11, HEAP32[$2 - 24 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($7, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, HEAP32[$2 - 4 >> 2]) >> $4);
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if ($3 >>> 0 >= 5) {
    if ($3 >>> 0 >= 7) {
     if (($3 | 0) != 8) {
      if (($1 | 0) <= 0) {
       break block1
      }
      $3 = HEAP32[$2 >> 2];
      $7 = HEAP32[$2 + 4 >> 2];
      $8 = HEAP32[$2 + 8 >> 2];
      $9 = HEAP32[$2 + 12 >> 2];
      $10 = HEAP32[$2 + 16 >> 2];
      $11 = HEAP32[$2 + 20 >> 2];
      $12 = HEAP32[$2 + 24 >> 2];
      while (1) {
       $13 = $6 << 2;
       $2 = $13 + $0 | 0;
       HEAP32[$5 + $13 >> 2] = HEAP32[$2 >> 2] - ((((((Math_imul($11, HEAP32[$2 - 24 >> 2]) + Math_imul($12, HEAP32[$2 - 28 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($7, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, HEAP32[$2 - 4 >> 2]) >> $4);
       $6 = $6 + 1 | 0;
       if (($6 | 0) != ($1 | 0)) {
        continue
       }
       break;
      };
      break block1;
     }
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$2 >> 2];
     $7 = HEAP32[$2 + 4 >> 2];
     $8 = HEAP32[$2 + 8 >> 2];
     $9 = HEAP32[$2 + 12 >> 2];
     $10 = HEAP32[$2 + 16 >> 2];
     $11 = HEAP32[$2 + 20 >> 2];
     $12 = HEAP32[$2 + 24 >> 2];
     $13 = HEAP32[$2 + 28 >> 2];
     while (1) {
      $14 = $6 << 2;
      $2 = $14 + $0 | 0;
      HEAP32[$5 + $14 >> 2] = HEAP32[$2 >> 2] - (((((((Math_imul($12, HEAP32[$2 - 28 >> 2]) + Math_imul($13, HEAP32[$2 - 32 >> 2]) | 0) + Math_imul($11, HEAP32[$2 - 24 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($7, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, HEAP32[$2 - 4 >> 2]) >> $4);
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($3 | 0) != 6) {
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$2 >> 2];
     $7 = HEAP32[$2 + 4 >> 2];
     $8 = HEAP32[$2 + 8 >> 2];
     $9 = HEAP32[$2 + 12 >> 2];
     $10 = HEAP32[$2 + 16 >> 2];
     while (1) {
      $11 = $6 << 2;
      $2 = $11 + $0 | 0;
      HEAP32[$5 + $11 >> 2] = HEAP32[$2 >> 2] - ((((Math_imul($9, HEAP32[$2 - 16 >> 2]) + Math_imul($10, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($7, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, HEAP32[$2 - 4 >> 2]) >> $4);
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($1 | 0) <= 0) {
     break block1
    }
    $3 = HEAP32[$2 >> 2];
    $7 = HEAP32[$2 + 4 >> 2];
    $8 = HEAP32[$2 + 8 >> 2];
    $9 = HEAP32[$2 + 12 >> 2];
    $10 = HEAP32[$2 + 16 >> 2];
    $11 = HEAP32[$2 + 20 >> 2];
    while (1) {
     $12 = $6 << 2;
     $2 = $12 + $0 | 0;
     HEAP32[$5 + $12 >> 2] = HEAP32[$2 >> 2] - (((((Math_imul($10, HEAP32[$2 - 20 >> 2]) + Math_imul($11, HEAP32[$2 - 24 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($7, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, HEAP32[$2 - 4 >> 2]) >> $4);
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if ($3 >>> 0 >= 3) {
    if (($3 | 0) != 4) {
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$2 >> 2];
     $7 = HEAP32[$2 + 4 >> 2];
     $8 = HEAP32[$2 + 8 >> 2];
     while (1) {
      $9 = $6 << 2;
      $2 = $9 + $0 | 0;
      HEAP32[$5 + $9 >> 2] = HEAP32[$2 >> 2] - ((Math_imul($7, HEAP32[$2 - 8 >> 2]) + Math_imul($8, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($3, HEAP32[$2 - 4 >> 2]) >> $4);
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($1 | 0) <= 0) {
     break block1
    }
    $3 = HEAP32[$2 >> 2];
    $7 = HEAP32[$2 + 4 >> 2];
    $8 = HEAP32[$2 + 8 >> 2];
    $9 = HEAP32[$2 + 12 >> 2];
    while (1) {
     $10 = $6 << 2;
     $2 = $10 + $0 | 0;
     HEAP32[$5 + $10 >> 2] = HEAP32[$2 >> 2] - (((Math_imul($8, HEAP32[$2 - 12 >> 2]) + Math_imul($9, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($7, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, HEAP32[$2 - 4 >> 2]) >> $4);
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if (($3 | 0) != 2) {
    if (($1 | 0) <= 0) {
     break block1
    }
    $8 = $1 & 1;
    $6 = HEAP32[$2 >> 2];
    $2 = 0;
    if (($1 | 0) != 1) {
     $9 = $1 & 2147483646;
     $3 = 0;
     while (1) {
      $1 = $2 << 2;
      $10 = $1 + $0 | 0;
      $7 = HEAP32[$10 >> 2];
      HEAP32[$1 + $5 >> 2] = $7 - (Math_imul($6, HEAP32[$10 - 4 >> 2]) >> $4);
      $1 = $1 | 4;
      HEAP32[$1 + $5 >> 2] = HEAP32[$0 + $1 >> 2] - (Math_imul($6, $7) >> $4);
      $2 = $2 + 2 | 0;
      $3 = $3 + 2 | 0;
      if (($9 | 0) != ($3 | 0)) {
       continue
      }
      break;
     };
    }
    if (!$8) {
     break block1
    }
    $1 = $2 << 2;
    $0 = $1 + $0 | 0;
    HEAP32[$1 + $5 >> 2] = HEAP32[$0 >> 2] - (Math_imul($6, HEAP32[$0 - 4 >> 2]) >> $4);
    return;
   }
   if (($1 | 0) <= 0) {
    break block1
   }
   $10 = $1 & 1;
   $6 = HEAP32[$2 >> 2];
   $7 = HEAP32[$2 + 4 >> 2];
   $2 = 0;
   if (($1 | 0) != 1) {
    $11 = $1 & 2147483646;
    $3 = 0;
    while (1) {
     $1 = $2 << 2;
     $8 = $1 + $0 | 0;
     $9 = HEAP32[$8 >> 2];
     $12 = HEAP32[$8 - 4 >> 2];
     HEAP32[$1 + $5 >> 2] = $9 - (Math_imul($12, $6) + Math_imul($7, HEAP32[$8 - 8 >> 2]) >> $4);
     $1 = $1 | 4;
     HEAP32[$1 + $5 >> 2] = HEAP32[$0 + $1 >> 2] - (Math_imul($6, $9) + Math_imul($7, $12) >> $4);
     $2 = $2 + 2 | 0;
     $3 = $3 + 2 | 0;
     if (($11 | 0) != ($3 | 0)) {
      continue
     }
     break;
    };
   }
   if (!$10) {
    break block1
   }
   $1 = $2 << 2;
   $0 = $1 + $0 | 0;
   HEAP32[$1 + $5 >> 2] = HEAP32[$0 >> 2] - (Math_imul($6, HEAP32[$0 - 4 >> 2]) + Math_imul($7, HEAP32[$0 - 8 >> 2]) >> $4);
  }
 }
 
 function FLAC__lpc_compute_residual_from_qlp_coefficients_wide($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0;
  block1 : {
   if ($3 >>> 0 >= 13) {
    if (($1 | 0) <= 0) {
     break block1
    }
    $31 = $0 - 56 | 0;
    $23 = $0 - 60 | 0;
    $30 = $0 + -64 | 0;
    $24 = $0 - 68 | 0;
    $29 = $0 - 72 | 0;
    $25 = $0 - 76 | 0;
    $28 = $0 - 80 | 0;
    $26 = $0 - 84 | 0;
    $27 = $0 - 88 | 0;
    $22 = $0 - 92 | 0;
    $11 = $0 - 96 | 0;
    $10 = $0 - 100 | 0;
    $13 = $0 - 104 | 0;
    $12 = $0 - 108 | 0;
    $14 = $0 - 112 | 0;
    $15 = $0 - 116 | 0;
    $17 = $0 - 120 | 0;
    $16 = $0 - 124 | 0;
    $18 = $0 - 128 | 0;
    $20 = $4;
    $4 = 0;
    $21 = $3 - 13 | 0;
    while (1) {
     $7 = 0;
     $3 = 0;
     block22 : {
      switch ($21 | 0) {
      case 19:
       $3 = HEAP32[($4 << 2) + $18 >> 2];
       $7 = $3;
       $6 = $3 >> 31;
       $3 = HEAP32[$2 + 124 >> 2];
       $7 = __wasm_i64_mul($7, $6, $3, $3 >> 31);
       $3 = i64toi32_i32$HIGH_BITS;
      case 18:
       $6 = HEAP32[($4 << 2) + $16 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 120 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 17:
       $6 = HEAP32[($4 << 2) + $17 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 116 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 16:
       $6 = HEAP32[($4 << 2) + $15 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 112 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 15:
       $6 = HEAP32[($4 << 2) + $14 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 108 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 14:
       $6 = HEAP32[($4 << 2) + $12 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 104 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 13:
       $6 = HEAP32[($4 << 2) + $13 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 100 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 12:
       $6 = HEAP32[($4 << 2) + $10 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 96 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 11:
       $6 = HEAP32[($4 << 2) + $11 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 92 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 10:
       $6 = HEAP32[($4 << 2) + $22 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 88 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 9:
       $6 = HEAP32[($4 << 2) + $27 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 84 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 8:
       $6 = HEAP32[($4 << 2) + $26 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 80 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 7:
       $6 = HEAP32[($4 << 2) + $28 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 76 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 6:
       $6 = HEAP32[($4 << 2) + $25 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 72 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 5:
       $6 = HEAP32[($4 << 2) + $29 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 68 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 4:
       $6 = HEAP32[($4 << 2) + $24 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 64 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 3:
       $6 = HEAP32[($4 << 2) + $30 >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 60 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 2:
       $6 = HEAP32[$23 + ($4 << 2) >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 56 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 1:
       $6 = HEAP32[$31 + ($4 << 2) >> 2];
       $8 = $6;
       $9 = $6 >> 31;
       $6 = HEAP32[$2 + 52 >> 2];
       $6 = __wasm_i64_mul($8, $9, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $8 = $7;
       $7 = $6 + $7 | 0;
       $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
      case 0:
       $8 = ($4 << 2) + $0 | 0;
       $6 = HEAP32[$8 - 52 >> 2];
       $9 = $6;
       $19 = $6 >> 31;
       $6 = HEAP32[$2 + 48 >> 2];
       $6 = __wasm_i64_mul($9, $19, $6, $6 >> 31);
       $3 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $9 = $7;
       $7 = $6 + $7 | 0;
       $3 = $9 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
       $6 = $7;
       $7 = HEAP32[$8 - 48 >> 2];
       $9 = $7;
       $19 = $7 >> 31;
       $7 = HEAP32[$2 + 44 >> 2];
       $7 = __wasm_i64_mul($9, $19, $7, $7 >> 31);
       $6 = $6 + $7 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $6 >>> 0 < $7 >>> 0 ? $3 + 1 | 0 : $3;
       $7 = HEAP32[$8 - 44 >> 2];
       $9 = $7;
       $19 = $7 >> 31;
       $7 = HEAP32[$2 + 40 >> 2];
       $7 = __wasm_i64_mul($9, $19, $7, $7 >> 31);
       $6 = $7 + $6 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $6 >>> 0 < $7 >>> 0 ? $3 + 1 | 0 : $3;
       $7 = HEAP32[$8 - 40 >> 2];
       $9 = $7;
       $19 = $7 >> 31;
       $7 = HEAP32[$2 + 36 >> 2];
       $7 = __wasm_i64_mul($9, $19, $7, $7 >> 31);
       $6 = $7 + $6 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $6 >>> 0 < $7 >>> 0 ? $3 + 1 | 0 : $3;
       $7 = HEAP32[$8 - 36 >> 2];
       $9 = $7;
       $19 = $7 >> 31;
       $7 = HEAP32[$2 + 32 >> 2];
       $7 = __wasm_i64_mul($9, $19, $7, $7 >> 31);
       $6 = $7 + $6 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $6 >>> 0 < $7 >>> 0 ? $3 + 1 | 0 : $3;
       $7 = HEAP32[$8 - 32 >> 2];
       $9 = $7;
       $19 = $7 >> 31;
       $7 = HEAP32[$2 + 28 >> 2];
       $7 = __wasm_i64_mul($9, $19, $7, $7 >> 31);
       $6 = $7 + $6 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $6 >>> 0 < $7 >>> 0 ? $3 + 1 | 0 : $3;
       $7 = HEAP32[$8 - 28 >> 2];
       $9 = $7;
       $19 = $7 >> 31;
       $7 = HEAP32[$2 + 24 >> 2];
       $7 = __wasm_i64_mul($9, $19, $7, $7 >> 31);
       $6 = $7 + $6 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $6 >>> 0 < $7 >>> 0 ? $3 + 1 | 0 : $3;
       $7 = HEAP32[$8 - 24 >> 2];
       $9 = $7;
       $19 = $7 >> 31;
       $7 = HEAP32[$2 + 20 >> 2];
       $7 = __wasm_i64_mul($9, $19, $7, $7 >> 31);
       $6 = $7 + $6 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $6 >>> 0 < $7 >>> 0 ? $3 + 1 | 0 : $3;
       $7 = HEAP32[$8 - 20 >> 2];
       $9 = $7;
       $19 = $7 >> 31;
       $7 = HEAP32[$2 + 16 >> 2];
       $7 = __wasm_i64_mul($9, $19, $7, $7 >> 31);
       $6 = $7 + $6 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $6 >>> 0 < $7 >>> 0 ? $3 + 1 | 0 : $3;
       $7 = HEAP32[$8 - 16 >> 2];
       $9 = $7;
       $19 = $7 >> 31;
       $7 = HEAP32[$2 + 12 >> 2];
       $7 = __wasm_i64_mul($9, $19, $7, $7 >> 31);
       $6 = $7 + $6 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $6 >>> 0 < $7 >>> 0 ? $3 + 1 | 0 : $3;
       $7 = HEAP32[$8 - 12 >> 2];
       $9 = $7;
       $19 = $7 >> 31;
       $7 = HEAP32[$2 + 8 >> 2];
       $7 = __wasm_i64_mul($9, $19, $7, $7 >> 31);
       $6 = $7 + $6 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $6 >>> 0 < $7 >>> 0 ? $3 + 1 | 0 : $3;
       $7 = HEAP32[$8 - 8 >> 2];
       $9 = $7;
       $19 = $7 >> 31;
       $7 = HEAP32[$2 + 4 >> 2];
       $7 = __wasm_i64_mul($9, $19, $7, $7 >> 31);
       $6 = $7 + $6 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $6 >>> 0 < $7 >>> 0 ? $3 + 1 | 0 : $3;
       $9 = $6;
       $7 = HEAP32[$8 - 4 >> 2];
       $6 = $7;
       $8 = $7 >> 31;
       $7 = HEAP32[$2 >> 2];
       $6 = __wasm_i64_mul($6, $8, $7, $7 >> 31);
       $7 = $9 + $6 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $6 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
       break;
      default:
       break block22;
      };
     }
     $6 = $4 << 2;
     $8 = $6 + $5 | 0;
     $9 = HEAP32[$0 + $6 >> 2];
     $6 = $20 & 31;
     if (($20 & 63) >>> 0 >= 32) {
      $3 = $3 >> $6
     } else {
      $3 = ((1 << $6) - 1 & $3) << 32 - $6 | $7 >>> $6
     }
     HEAP32[$8 >> 2] = $9 - $3;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if ($3 >>> 0 >= 9) {
    if ($3 >>> 0 >= 11) {
     if (($3 | 0) != 12) {
      if (($1 | 0) <= 0) {
       break block1
      }
      $13 = $4;
      $12 = HEAP32[$2 >> 2];
      $32 = $12 >> 31;
      $14 = HEAP32[$2 + 4 >> 2];
      $8 = $14 >> 31;
      $15 = HEAP32[$2 + 8 >> 2];
      $31 = $15 >> 31;
      $17 = HEAP32[$2 + 12 >> 2];
      $23 = $17 >> 31;
      $16 = HEAP32[$2 + 16 >> 2];
      $30 = $16 >> 31;
      $18 = HEAP32[$2 + 20 >> 2];
      $24 = $18 >> 31;
      $21 = HEAP32[$2 + 24 >> 2];
      $29 = $21 >> 31;
      $6 = HEAP32[$2 + 28 >> 2];
      $25 = $6 >> 31;
      $20 = HEAP32[$2 + 32 >> 2];
      $28 = $20 >> 31;
      $7 = HEAP32[$2 + 36 >> 2];
      $26 = $7 >> 31;
      $2 = HEAP32[$2 + 40 >> 2];
      $27 = $2 >> 31;
      $4 = 0;
      while (1) {
       $3 = $4 << 2;
       $22 = $3 + $5 | 0;
       $33 = $0 + $3 | 0;
       $11 = HEAP32[$33 >> 2];
       $3 = HEAP32[$33 - 40 >> 2];
       $10 = __wasm_i64_mul($3, $3 >> 31, $7, $26);
       $3 = i64toi32_i32$HIGH_BITS;
       $9 = $10;
       $19 = HEAP32[$33 - 44 >> 2];
       $10 = __wasm_i64_mul($19, $19 >> 31, $2, $27);
       $19 = $9 + $10 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $10 >>> 0 > $19 >>> 0 ? $3 + 1 | 0 : $3;
       $10 = HEAP32[$33 - 36 >> 2];
       $10 = __wasm_i64_mul($10, $10 >> 31, $20, $28);
       $19 = $10 + $19 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $10 >>> 0 > $19 >>> 0 ? $3 + 1 | 0 : $3;
       $10 = HEAP32[$33 - 32 >> 2];
       $10 = __wasm_i64_mul($10, $10 >> 31, $6, $25);
       $19 = $10 + $19 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $10 >>> 0 > $19 >>> 0 ? $3 + 1 | 0 : $3;
       $10 = HEAP32[$33 - 28 >> 2];
       $10 = __wasm_i64_mul($10, $10 >> 31, $21, $29);
       $19 = $10 + $19 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $10 >>> 0 > $19 >>> 0 ? $3 + 1 | 0 : $3;
       $10 = HEAP32[$33 - 24 >> 2];
       $10 = __wasm_i64_mul($10, $10 >> 31, $18, $24);
       $19 = $10 + $19 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $10 >>> 0 > $19 >>> 0 ? $3 + 1 | 0 : $3;
       $10 = HEAP32[$33 - 20 >> 2];
       $10 = __wasm_i64_mul($10, $10 >> 31, $16, $30);
       $19 = $10 + $19 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $10 >>> 0 > $19 >>> 0 ? $3 + 1 | 0 : $3;
       $10 = HEAP32[$33 - 16 >> 2];
       $10 = __wasm_i64_mul($10, $10 >> 31, $17, $23);
       $19 = $10 + $19 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $10 >>> 0 > $19 >>> 0 ? $3 + 1 | 0 : $3;
       $10 = HEAP32[$33 - 12 >> 2];
       $10 = __wasm_i64_mul($10, $10 >> 31, $15, $31);
       $19 = $10 + $19 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $10 >>> 0 > $19 >>> 0 ? $3 + 1 | 0 : $3;
       $10 = HEAP32[$33 - 8 >> 2];
       $10 = __wasm_i64_mul($10, $10 >> 31, $14, $8);
       $19 = $10 + $19 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $10 >>> 0 > $19 >>> 0 ? $3 + 1 | 0 : $3;
       $10 = HEAP32[$33 - 4 >> 2];
       $10 = __wasm_i64_mul($10, $10 >> 31, $12, $32);
       $19 = $10 + $19 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $10 >>> 0 > $19 >>> 0 ? $3 + 1 | 0 : $3;
       $9 = $11;
       $10 = $19;
       $11 = $13 & 31;
       if (($13 & 63) >>> 0 >= 32) {
        $3 = $3 >> $11
       } else {
        $3 = ((1 << $11) - 1 & $3) << 32 - $11 | $10 >>> $11
       }
       HEAP32[$22 >> 2] = $9 - $3;
       $4 = $4 + 1 | 0;
       if (($4 | 0) != ($1 | 0)) {
        continue
       }
       break;
      };
      break block1;
     }
     if (($1 | 0) <= 0) {
      break block1
     }
     $10 = $4;
     $13 = HEAP32[$2 >> 2];
     $33 = $13 >> 31;
     $12 = HEAP32[$2 + 4 >> 2];
     $19 = $12 >> 31;
     $14 = HEAP32[$2 + 8 >> 2];
     $32 = $14 >> 31;
     $15 = HEAP32[$2 + 12 >> 2];
     $8 = $15 >> 31;
     $17 = HEAP32[$2 + 16 >> 2];
     $31 = $17 >> 31;
     $16 = HEAP32[$2 + 20 >> 2];
     $23 = $16 >> 31;
     $18 = HEAP32[$2 + 24 >> 2];
     $30 = $18 >> 31;
     $21 = HEAP32[$2 + 28 >> 2];
     $24 = $21 >> 31;
     $6 = HEAP32[$2 + 32 >> 2];
     $29 = $6 >> 31;
     $20 = HEAP32[$2 + 36 >> 2];
     $25 = $20 >> 31;
     $7 = HEAP32[$2 + 40 >> 2];
     $28 = $7 >> 31;
     $2 = HEAP32[$2 + 44 >> 2];
     $26 = $2 >> 31;
     $4 = 0;
     while (1) {
      $3 = $4 << 2;
      $27 = $3 + $5 | 0;
      $34 = $0 + $3 | 0;
      $22 = HEAP32[$34 >> 2];
      $3 = HEAP32[$34 - 44 >> 2];
      $11 = __wasm_i64_mul($3, $3 >> 31, $7, $28);
      $3 = i64toi32_i32$HIGH_BITS;
      $35 = $11;
      $9 = HEAP32[$34 - 48 >> 2];
      $11 = __wasm_i64_mul($9, $9 >> 31, $2, $26);
      $9 = $35 + $11 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $11 >>> 0 > $9 >>> 0 ? $3 + 1 | 0 : $3;
      $11 = HEAP32[$34 - 40 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $20, $25);
      $9 = $11 + $9 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $11 >>> 0 > $9 >>> 0 ? $3 + 1 | 0 : $3;
      $11 = HEAP32[$34 - 36 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $6, $29);
      $9 = $11 + $9 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $11 >>> 0 > $9 >>> 0 ? $3 + 1 | 0 : $3;
      $11 = HEAP32[$34 - 32 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $21, $24);
      $9 = $11 + $9 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $11 >>> 0 > $9 >>> 0 ? $3 + 1 | 0 : $3;
      $11 = HEAP32[$34 - 28 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $18, $30);
      $9 = $11 + $9 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $11 >>> 0 > $9 >>> 0 ? $3 + 1 | 0 : $3;
      $11 = HEAP32[$34 - 24 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $16, $23);
      $9 = $11 + $9 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $11 >>> 0 > $9 >>> 0 ? $3 + 1 | 0 : $3;
      $11 = HEAP32[$34 - 20 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $17, $31);
      $9 = $11 + $9 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $11 >>> 0 > $9 >>> 0 ? $3 + 1 | 0 : $3;
      $11 = HEAP32[$34 - 16 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $15, $8);
      $9 = $11 + $9 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $11 >>> 0 > $9 >>> 0 ? $3 + 1 | 0 : $3;
      $11 = HEAP32[$34 - 12 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $14, $32);
      $9 = $11 + $9 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $11 >>> 0 > $9 >>> 0 ? $3 + 1 | 0 : $3;
      $11 = HEAP32[$34 - 8 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $12, $19);
      $9 = $11 + $9 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $11 >>> 0 > $9 >>> 0 ? $3 + 1 | 0 : $3;
      $11 = HEAP32[$34 - 4 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $13, $33);
      $9 = $11 + $9 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $11 >>> 0 > $9 >>> 0 ? $3 + 1 | 0 : $3;
      $35 = $22;
      $11 = $9;
      $22 = $10 & 31;
      if (($10 & 63) >>> 0 >= 32) {
       $3 = $3 >> $22
      } else {
       $3 = ((1 << $22) - 1 & $3) << 32 - $22 | $11 >>> $22
      }
      HEAP32[$27 >> 2] = $35 - $3;
      $4 = $4 + 1 | 0;
      if (($4 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($3 | 0) != 10) {
     if (($1 | 0) <= 0) {
      break block1
     }
     $14 = $4;
     $15 = HEAP32[$2 >> 2];
     $30 = $15 >> 31;
     $17 = HEAP32[$2 + 4 >> 2];
     $24 = $17 >> 31;
     $16 = HEAP32[$2 + 8 >> 2];
     $29 = $16 >> 31;
     $18 = HEAP32[$2 + 12 >> 2];
     $25 = $18 >> 31;
     $21 = HEAP32[$2 + 16 >> 2];
     $28 = $21 >> 31;
     $6 = HEAP32[$2 + 20 >> 2];
     $26 = $6 >> 31;
     $20 = HEAP32[$2 + 24 >> 2];
     $27 = $20 >> 31;
     $7 = HEAP32[$2 + 28 >> 2];
     $22 = $7 >> 31;
     $2 = HEAP32[$2 + 32 >> 2];
     $11 = $2 >> 31;
     $4 = 0;
     while (1) {
      $3 = $4 << 2;
      $10 = $3 + $5 | 0;
      $31 = $0 + $3 | 0;
      $13 = HEAP32[$31 >> 2];
      $3 = HEAP32[$31 - 32 >> 2];
      $12 = __wasm_i64_mul($3, $3 >> 31, $7, $22);
      $3 = i64toi32_i32$HIGH_BITS;
      $8 = $12;
      $23 = HEAP32[$31 - 36 >> 2];
      $12 = __wasm_i64_mul($23, $23 >> 31, $2, $11);
      $23 = $8 + $12 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $12 >>> 0 > $23 >>> 0 ? $3 + 1 | 0 : $3;
      $12 = HEAP32[$31 - 28 >> 2];
      $12 = __wasm_i64_mul($12, $12 >> 31, $20, $27);
      $23 = $12 + $23 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $12 >>> 0 > $23 >>> 0 ? $3 + 1 | 0 : $3;
      $12 = HEAP32[$31 - 24 >> 2];
      $12 = __wasm_i64_mul($12, $12 >> 31, $6, $26);
      $23 = $12 + $23 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $12 >>> 0 > $23 >>> 0 ? $3 + 1 | 0 : $3;
      $12 = HEAP32[$31 - 20 >> 2];
      $12 = __wasm_i64_mul($12, $12 >> 31, $21, $28);
      $23 = $12 + $23 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $12 >>> 0 > $23 >>> 0 ? $3 + 1 | 0 : $3;
      $12 = HEAP32[$31 - 16 >> 2];
      $12 = __wasm_i64_mul($12, $12 >> 31, $18, $25);
      $23 = $12 + $23 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $12 >>> 0 > $23 >>> 0 ? $3 + 1 | 0 : $3;
      $12 = HEAP32[$31 - 12 >> 2];
      $12 = __wasm_i64_mul($12, $12 >> 31, $16, $29);
      $23 = $12 + $23 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $12 >>> 0 > $23 >>> 0 ? $3 + 1 | 0 : $3;
      $12 = HEAP32[$31 - 8 >> 2];
      $12 = __wasm_i64_mul($12, $12 >> 31, $17, $24);
      $23 = $12 + $23 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $12 >>> 0 > $23 >>> 0 ? $3 + 1 | 0 : $3;
      $12 = HEAP32[$31 - 4 >> 2];
      $12 = __wasm_i64_mul($12, $12 >> 31, $15, $30);
      $23 = $12 + $23 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $12 >>> 0 > $23 >>> 0 ? $3 + 1 | 0 : $3;
      $8 = $13;
      $12 = $23;
      $13 = $14 & 31;
      if (($14 & 63) >>> 0 >= 32) {
       $3 = $3 >> $13
      } else {
       $3 = ((1 << $13) - 1 & $3) << 32 - $13 | $12 >>> $13
      }
      HEAP32[$10 >> 2] = $8 - $3;
      $4 = $4 + 1 | 0;
      if (($4 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($1 | 0) <= 0) {
     break block1
    }
    $12 = $4;
    $14 = HEAP32[$2 >> 2];
    $31 = $14 >> 31;
    $15 = HEAP32[$2 + 4 >> 2];
    $23 = $15 >> 31;
    $17 = HEAP32[$2 + 8 >> 2];
    $30 = $17 >> 31;
    $16 = HEAP32[$2 + 12 >> 2];
    $24 = $16 >> 31;
    $18 = HEAP32[$2 + 16 >> 2];
    $29 = $18 >> 31;
    $21 = HEAP32[$2 + 20 >> 2];
    $25 = $21 >> 31;
    $6 = HEAP32[$2 + 24 >> 2];
    $28 = $6 >> 31;
    $20 = HEAP32[$2 + 28 >> 2];
    $26 = $20 >> 31;
    $7 = HEAP32[$2 + 32 >> 2];
    $27 = $7 >> 31;
    $2 = HEAP32[$2 + 36 >> 2];
    $22 = $2 >> 31;
    $4 = 0;
    while (1) {
     $3 = $4 << 2;
     $11 = $3 + $5 | 0;
     $32 = $0 + $3 | 0;
     $10 = HEAP32[$32 >> 2];
     $3 = HEAP32[$32 - 36 >> 2];
     $13 = __wasm_i64_mul($3, $3 >> 31, $7, $27);
     $3 = i64toi32_i32$HIGH_BITS;
     $9 = $13;
     $8 = HEAP32[$32 - 40 >> 2];
     $13 = __wasm_i64_mul($8, $8 >> 31, $2, $22);
     $8 = $9 + $13 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $13 >>> 0 > $8 >>> 0 ? $3 + 1 | 0 : $3;
     $13 = HEAP32[$32 - 32 >> 2];
     $13 = __wasm_i64_mul($13, $13 >> 31, $20, $26);
     $8 = $13 + $8 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $13 >>> 0 > $8 >>> 0 ? $3 + 1 | 0 : $3;
     $13 = HEAP32[$32 - 28 >> 2];
     $13 = __wasm_i64_mul($13, $13 >> 31, $6, $28);
     $8 = $13 + $8 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $13 >>> 0 > $8 >>> 0 ? $3 + 1 | 0 : $3;
     $13 = HEAP32[$32 - 24 >> 2];
     $13 = __wasm_i64_mul($13, $13 >> 31, $21, $25);
     $8 = $13 + $8 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $13 >>> 0 > $8 >>> 0 ? $3 + 1 | 0 : $3;
     $13 = HEAP32[$32 - 20 >> 2];
     $13 = __wasm_i64_mul($13, $13 >> 31, $18, $29);
     $8 = $13 + $8 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $13 >>> 0 > $8 >>> 0 ? $3 + 1 | 0 : $3;
     $13 = HEAP32[$32 - 16 >> 2];
     $13 = __wasm_i64_mul($13, $13 >> 31, $16, $24);
     $8 = $13 + $8 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $13 >>> 0 > $8 >>> 0 ? $3 + 1 | 0 : $3;
     $13 = HEAP32[$32 - 12 >> 2];
     $13 = __wasm_i64_mul($13, $13 >> 31, $17, $30);
     $8 = $13 + $8 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $13 >>> 0 > $8 >>> 0 ? $3 + 1 | 0 : $3;
     $13 = HEAP32[$32 - 8 >> 2];
     $13 = __wasm_i64_mul($13, $13 >> 31, $15, $23);
     $8 = $13 + $8 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $13 >>> 0 > $8 >>> 0 ? $3 + 1 | 0 : $3;
     $13 = HEAP32[$32 - 4 >> 2];
     $13 = __wasm_i64_mul($13, $13 >> 31, $14, $31);
     $8 = $13 + $8 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $13 >>> 0 > $8 >>> 0 ? $3 + 1 | 0 : $3;
     $9 = $10;
     $13 = $8;
     $10 = $12 & 31;
     if (($12 & 63) >>> 0 >= 32) {
      $3 = $3 >> $10
     } else {
      $3 = ((1 << $10) - 1 & $3) << 32 - $10 | $13 >>> $10
     }
     HEAP32[$11 >> 2] = $9 - $3;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if ($3 >>> 0 >= 5) {
    if ($3 >>> 0 >= 7) {
     if (($3 | 0) != 8) {
      if (($1 | 0) <= 0) {
       break block1
      }
      $17 = $4;
      $16 = HEAP32[$2 >> 2];
      $28 = $16 >> 31;
      $18 = HEAP32[$2 + 4 >> 2];
      $26 = $18 >> 31;
      $21 = HEAP32[$2 + 8 >> 2];
      $27 = $21 >> 31;
      $6 = HEAP32[$2 + 12 >> 2];
      $22 = $6 >> 31;
      $20 = HEAP32[$2 + 16 >> 2];
      $11 = $20 >> 31;
      $7 = HEAP32[$2 + 20 >> 2];
      $10 = $7 >> 31;
      $2 = HEAP32[$2 + 24 >> 2];
      $13 = $2 >> 31;
      $4 = 0;
      while (1) {
       $3 = $4 << 2;
       $12 = $3 + $5 | 0;
       $29 = $0 + $3 | 0;
       $14 = HEAP32[$29 >> 2];
       $3 = HEAP32[$29 - 24 >> 2];
       $15 = __wasm_i64_mul($3, $3 >> 31, $7, $10);
       $3 = i64toi32_i32$HIGH_BITS;
       $8 = $15;
       $25 = HEAP32[$29 - 28 >> 2];
       $15 = __wasm_i64_mul($25, $25 >> 31, $2, $13);
       $25 = $8 + $15 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $15 >>> 0 > $25 >>> 0 ? $3 + 1 | 0 : $3;
       $15 = HEAP32[$29 - 20 >> 2];
       $15 = __wasm_i64_mul($15, $15 >> 31, $20, $11);
       $25 = $15 + $25 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $15 >>> 0 > $25 >>> 0 ? $3 + 1 | 0 : $3;
       $15 = HEAP32[$29 - 16 >> 2];
       $15 = __wasm_i64_mul($15, $15 >> 31, $6, $22);
       $25 = $15 + $25 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $15 >>> 0 > $25 >>> 0 ? $3 + 1 | 0 : $3;
       $15 = HEAP32[$29 - 12 >> 2];
       $15 = __wasm_i64_mul($15, $15 >> 31, $21, $27);
       $25 = $15 + $25 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $15 >>> 0 > $25 >>> 0 ? $3 + 1 | 0 : $3;
       $15 = HEAP32[$29 - 8 >> 2];
       $15 = __wasm_i64_mul($15, $15 >> 31, $18, $26);
       $25 = $15 + $25 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $15 >>> 0 > $25 >>> 0 ? $3 + 1 | 0 : $3;
       $15 = HEAP32[$29 - 4 >> 2];
       $15 = __wasm_i64_mul($15, $15 >> 31, $16, $28);
       $25 = $15 + $25 | 0;
       $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
       $3 = $15 >>> 0 > $25 >>> 0 ? $3 + 1 | 0 : $3;
       $8 = $14;
       $15 = $25;
       $14 = $17 & 31;
       if (($17 & 63) >>> 0 >= 32) {
        $3 = $3 >> $14
       } else {
        $3 = ((1 << $14) - 1 & $3) << 32 - $14 | $15 >>> $14
       }
       HEAP32[$12 >> 2] = $8 - $3;
       $4 = $4 + 1 | 0;
       if (($4 | 0) != ($1 | 0)) {
        continue
       }
       break;
      };
      break block1;
     }
     if (($1 | 0) <= 0) {
      break block1
     }
     $15 = $4;
     $17 = HEAP32[$2 >> 2];
     $29 = $17 >> 31;
     $16 = HEAP32[$2 + 4 >> 2];
     $25 = $16 >> 31;
     $18 = HEAP32[$2 + 8 >> 2];
     $28 = $18 >> 31;
     $21 = HEAP32[$2 + 12 >> 2];
     $26 = $21 >> 31;
     $6 = HEAP32[$2 + 16 >> 2];
     $27 = $6 >> 31;
     $20 = HEAP32[$2 + 20 >> 2];
     $22 = $20 >> 31;
     $7 = HEAP32[$2 + 24 >> 2];
     $11 = $7 >> 31;
     $2 = HEAP32[$2 + 28 >> 2];
     $10 = $2 >> 31;
     $4 = 0;
     while (1) {
      $3 = $4 << 2;
      $13 = $3 + $5 | 0;
      $30 = $0 + $3 | 0;
      $12 = HEAP32[$30 >> 2];
      $3 = HEAP32[$30 - 28 >> 2];
      $14 = __wasm_i64_mul($3, $3 >> 31, $7, $11);
      $3 = i64toi32_i32$HIGH_BITS;
      $8 = $14;
      $24 = HEAP32[$30 - 32 >> 2];
      $14 = __wasm_i64_mul($24, $24 >> 31, $2, $10);
      $24 = $8 + $14 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $14 >>> 0 > $24 >>> 0 ? $3 + 1 | 0 : $3;
      $14 = HEAP32[$30 - 24 >> 2];
      $14 = __wasm_i64_mul($14, $14 >> 31, $20, $22);
      $24 = $14 + $24 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $14 >>> 0 > $24 >>> 0 ? $3 + 1 | 0 : $3;
      $14 = HEAP32[$30 - 20 >> 2];
      $14 = __wasm_i64_mul($14, $14 >> 31, $6, $27);
      $24 = $14 + $24 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $14 >>> 0 > $24 >>> 0 ? $3 + 1 | 0 : $3;
      $14 = HEAP32[$30 - 16 >> 2];
      $14 = __wasm_i64_mul($14, $14 >> 31, $21, $26);
      $24 = $14 + $24 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $14 >>> 0 > $24 >>> 0 ? $3 + 1 | 0 : $3;
      $14 = HEAP32[$30 - 12 >> 2];
      $14 = __wasm_i64_mul($14, $14 >> 31, $18, $28);
      $24 = $14 + $24 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $14 >>> 0 > $24 >>> 0 ? $3 + 1 | 0 : $3;
      $14 = HEAP32[$30 - 8 >> 2];
      $14 = __wasm_i64_mul($14, $14 >> 31, $16, $25);
      $24 = $14 + $24 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $14 >>> 0 > $24 >>> 0 ? $3 + 1 | 0 : $3;
      $14 = HEAP32[$30 - 4 >> 2];
      $14 = __wasm_i64_mul($14, $14 >> 31, $17, $29);
      $24 = $14 + $24 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $14 >>> 0 > $24 >>> 0 ? $3 + 1 | 0 : $3;
      $8 = $12;
      $14 = $24;
      $12 = $15 & 31;
      if (($15 & 63) >>> 0 >= 32) {
       $3 = $3 >> $12
      } else {
       $3 = ((1 << $12) - 1 & $3) << 32 - $12 | $14 >>> $12
      }
      HEAP32[$13 >> 2] = $8 - $3;
      $4 = $4 + 1 | 0;
      if (($4 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($3 | 0) != 6) {
     if (($1 | 0) <= 0) {
      break block1
     }
     $18 = $4;
     $21 = HEAP32[$2 >> 2];
     $11 = $21 >> 31;
     $6 = HEAP32[$2 + 4 >> 2];
     $10 = $6 >> 31;
     $20 = HEAP32[$2 + 8 >> 2];
     $13 = $20 >> 31;
     $7 = HEAP32[$2 + 12 >> 2];
     $12 = $7 >> 31;
     $2 = HEAP32[$2 + 16 >> 2];
     $14 = $2 >> 31;
     $4 = 0;
     while (1) {
      $3 = $4 << 2;
      $15 = $3 + $5 | 0;
      $27 = $0 + $3 | 0;
      $17 = HEAP32[$27 >> 2];
      $3 = HEAP32[$27 - 16 >> 2];
      $16 = __wasm_i64_mul($3, $3 >> 31, $7, $12);
      $3 = i64toi32_i32$HIGH_BITS;
      $8 = $16;
      $22 = HEAP32[$27 - 20 >> 2];
      $16 = __wasm_i64_mul($22, $22 >> 31, $2, $14);
      $22 = $8 + $16 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $16 >>> 0 > $22 >>> 0 ? $3 + 1 | 0 : $3;
      $16 = HEAP32[$27 - 12 >> 2];
      $16 = __wasm_i64_mul($16, $16 >> 31, $20, $13);
      $22 = $16 + $22 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $16 >>> 0 > $22 >>> 0 ? $3 + 1 | 0 : $3;
      $16 = HEAP32[$27 - 8 >> 2];
      $16 = __wasm_i64_mul($16, $16 >> 31, $6, $10);
      $22 = $16 + $22 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $16 >>> 0 > $22 >>> 0 ? $3 + 1 | 0 : $3;
      $16 = HEAP32[$27 - 4 >> 2];
      $16 = __wasm_i64_mul($16, $16 >> 31, $21, $11);
      $22 = $16 + $22 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $16 >>> 0 > $22 >>> 0 ? $3 + 1 | 0 : $3;
      $8 = $17;
      $16 = $22;
      $17 = $18 & 31;
      if (($18 & 63) >>> 0 >= 32) {
       $3 = $3 >> $17
      } else {
       $3 = ((1 << $17) - 1 & $3) << 32 - $17 | $16 >>> $17
      }
      HEAP32[$15 >> 2] = $8 - $3;
      $4 = $4 + 1 | 0;
      if (($4 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($1 | 0) <= 0) {
     break block1
    }
    $16 = $4;
    $18 = HEAP32[$2 >> 2];
    $27 = $18 >> 31;
    $21 = HEAP32[$2 + 4 >> 2];
    $22 = $21 >> 31;
    $6 = HEAP32[$2 + 8 >> 2];
    $11 = $6 >> 31;
    $20 = HEAP32[$2 + 12 >> 2];
    $10 = $20 >> 31;
    $7 = HEAP32[$2 + 16 >> 2];
    $13 = $7 >> 31;
    $2 = HEAP32[$2 + 20 >> 2];
    $12 = $2 >> 31;
    $4 = 0;
    while (1) {
     $3 = $4 << 2;
     $14 = $3 + $5 | 0;
     $28 = $0 + $3 | 0;
     $15 = HEAP32[$28 >> 2];
     $3 = HEAP32[$28 - 20 >> 2];
     $17 = __wasm_i64_mul($3, $3 >> 31, $7, $13);
     $3 = i64toi32_i32$HIGH_BITS;
     $8 = $17;
     $26 = HEAP32[$28 - 24 >> 2];
     $17 = __wasm_i64_mul($26, $26 >> 31, $2, $12);
     $26 = $8 + $17 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $17 >>> 0 > $26 >>> 0 ? $3 + 1 | 0 : $3;
     $17 = HEAP32[$28 - 16 >> 2];
     $17 = __wasm_i64_mul($17, $17 >> 31, $20, $10);
     $26 = $17 + $26 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $17 >>> 0 > $26 >>> 0 ? $3 + 1 | 0 : $3;
     $17 = HEAP32[$28 - 12 >> 2];
     $17 = __wasm_i64_mul($17, $17 >> 31, $6, $11);
     $26 = $17 + $26 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $17 >>> 0 > $26 >>> 0 ? $3 + 1 | 0 : $3;
     $17 = HEAP32[$28 - 8 >> 2];
     $17 = __wasm_i64_mul($17, $17 >> 31, $21, $22);
     $26 = $17 + $26 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $17 >>> 0 > $26 >>> 0 ? $3 + 1 | 0 : $3;
     $17 = HEAP32[$28 - 4 >> 2];
     $17 = __wasm_i64_mul($17, $17 >> 31, $18, $27);
     $26 = $17 + $26 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $17 >>> 0 > $26 >>> 0 ? $3 + 1 | 0 : $3;
     $8 = $15;
     $17 = $26;
     $15 = $16 & 31;
     if (($16 & 63) >>> 0 >= 32) {
      $3 = $3 >> $15
     } else {
      $3 = ((1 << $15) - 1 & $3) << 32 - $15 | $17 >>> $15
     }
     HEAP32[$14 >> 2] = $8 - $3;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if ($3 >>> 0 >= 3) {
    if (($3 | 0) != 4) {
     if (($1 | 0) <= 0) {
      break block1
     }
     $6 = $4;
     $20 = HEAP32[$2 >> 2];
     $14 = $20 >> 31;
     $7 = HEAP32[$2 + 4 >> 2];
     $15 = $7 >> 31;
     $2 = HEAP32[$2 + 8 >> 2];
     $17 = $2 >> 31;
     $4 = 0;
     while (1) {
      $3 = $4 << 2;
      $16 = $3 + $5 | 0;
      $13 = $0 + $3 | 0;
      $18 = HEAP32[$13 >> 2];
      $3 = HEAP32[$13 - 8 >> 2];
      $21 = __wasm_i64_mul($3, $3 >> 31, $7, $15);
      $3 = i64toi32_i32$HIGH_BITS;
      $10 = $21;
      $12 = HEAP32[$13 - 12 >> 2];
      $21 = __wasm_i64_mul($12, $12 >> 31, $2, $17);
      $12 = $10 + $21 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $12 >>> 0 < $21 >>> 0 ? $3 + 1 | 0 : $3;
      $21 = HEAP32[$13 - 4 >> 2];
      $21 = __wasm_i64_mul($21, $21 >> 31, $20, $14);
      $12 = $21 + $12 | 0;
      $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
      $3 = $12 >>> 0 < $21 >>> 0 ? $3 + 1 | 0 : $3;
      $10 = $18;
      $21 = $12;
      $18 = $6 & 31;
      if (($6 & 63) >>> 0 >= 32) {
       $3 = $3 >> $18
      } else {
       $3 = ((1 << $18) - 1 & $3) << 32 - $18 | $21 >>> $18
      }
      HEAP32[$16 >> 2] = $10 - $3;
      $4 = $4 + 1 | 0;
      if (($4 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($1 | 0) <= 0) {
     break block1
    }
    $21 = $4;
    $6 = HEAP32[$2 >> 2];
    $13 = $6 >> 31;
    $20 = HEAP32[$2 + 4 >> 2];
    $12 = $20 >> 31;
    $7 = HEAP32[$2 + 8 >> 2];
    $14 = $7 >> 31;
    $2 = HEAP32[$2 + 12 >> 2];
    $15 = $2 >> 31;
    $4 = 0;
    while (1) {
     $3 = $4 << 2;
     $17 = $3 + $5 | 0;
     $11 = $0 + $3 | 0;
     $16 = HEAP32[$11 >> 2];
     $3 = HEAP32[$11 - 12 >> 2];
     $18 = __wasm_i64_mul($3, $3 >> 31, $7, $14);
     $3 = i64toi32_i32$HIGH_BITS;
     $22 = $18;
     $10 = HEAP32[$11 - 16 >> 2];
     $18 = __wasm_i64_mul($10, $10 >> 31, $2, $15);
     $10 = $22 + $18 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $10 >>> 0 < $18 >>> 0 ? $3 + 1 | 0 : $3;
     $18 = HEAP32[$11 - 8 >> 2];
     $18 = __wasm_i64_mul($18, $18 >> 31, $20, $12);
     $10 = $18 + $10 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $10 >>> 0 < $18 >>> 0 ? $3 + 1 | 0 : $3;
     $18 = HEAP32[$11 - 4 >> 2];
     $18 = __wasm_i64_mul($18, $18 >> 31, $6, $13);
     $10 = $18 + $10 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $10 >>> 0 < $18 >>> 0 ? $3 + 1 | 0 : $3;
     $11 = $16;
     $18 = $10;
     $16 = $21 & 31;
     if (($21 & 63) >>> 0 >= 32) {
      $3 = $3 >> $16
     } else {
      $3 = ((1 << $16) - 1 & $3) << 32 - $16 | $18 >>> $16
     }
     HEAP32[$17 >> 2] = $11 - $3;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if (($3 | 0) != 2) {
    if (($1 | 0) <= 0) {
     break block1
    }
    $18 = $1 & 1;
    $7 = $4;
    $4 = HEAP32[$2 >> 2];
    $17 = $4 >> 31;
    $2 = 0;
    if (($1 | 0) != 1) {
     $21 = $1 & 2147483646;
     $3 = 0;
     while (1) {
      $16 = $2 << 2;
      $6 = $16 + $5 | 0;
      $20 = $0 + $16 | 0;
      $1 = HEAP32[$20 >> 2];
      $20 = HEAP32[$20 - 4 >> 2];
      $20 = __wasm_i64_mul($20, $20 >> 31, $4, $17);
      $12 = $6;
      $6 = i64toi32_i32$HIGH_BITS;
      $15 = $7 & 31;
      if (($7 & 63) >>> 0 >= 32) {
       $6 = $6 >> $15
      } else {
       $6 = ((1 << $15) - 1 & $6) << 32 - $15 | $20 >>> $15
      }
      HEAP32[$12 >> 2] = $1 - $6;
      $20 = $16 | 4;
      $6 = $20 + $5 | 0;
      $20 = HEAP32[$0 + $20 >> 2];
      $1 = __wasm_i64_mul($1, $1 >> 31, $4, $17);
      $12 = $6;
      $16 = $20;
      $20 = i64toi32_i32$HIGH_BITS;
      $6 = $7 & 31;
      if (($7 & 63) >>> 0 >= 32) {
       $1 = $20 >> $6
      } else {
       $1 = ((1 << $6) - 1 & $20) << 32 - $6 | $1 >>> $6
      }
      HEAP32[$12 >> 2] = $16 - $1;
      $2 = $2 + 2 | 0;
      $3 = $3 + 2 | 0;
      if (($21 | 0) != ($3 | 0)) {
       continue
      }
      break;
     };
    }
    if (!$18) {
     break block1
    }
    $1 = $2 << 2;
    $2 = $1 + $5 | 0;
    $0 = $0 + $1 | 0;
    $1 = HEAP32[$0 >> 2];
    $0 = HEAP32[$0 - 4 >> 2];
    $0 = __wasm_i64_mul($0, $0 >> 31, $4, $17);
    $3 = $2;
    $4 = $1;
    $1 = i64toi32_i32$HIGH_BITS;
    $2 = $7 & 31;
    if (($7 & 63) >>> 0 >= 32) {
     $0 = $1 >> $2
    } else {
     $0 = ((1 << $2) - 1 & $1) << 32 - $2 | $0 >>> $2
    }
    HEAP32[$3 >> 2] = $4 - $0;
    return;
   }
   if (($1 | 0) <= 0) {
    break block1
   }
   $14 = $1 & 1;
   $21 = $4;
   $6 = HEAP32[$2 >> 2];
   $11 = $6 >> 31;
   $20 = HEAP32[$2 + 4 >> 2];
   $10 = $20 >> 31;
   $2 = 0;
   if (($1 | 0) != 1) {
    $15 = $1 & 2147483646;
    $1 = 0;
    while (1) {
     $13 = $2 << 2;
     $16 = $13 + $5 | 0;
     $12 = $0 + $13 | 0;
     $7 = HEAP32[$12 >> 2];
     $4 = HEAP32[$12 - 4 >> 2];
     $17 = $4 >> 31;
     $18 = __wasm_i64_mul($4, $17, $6, $11);
     $3 = i64toi32_i32$HIGH_BITS;
     $22 = $18;
     $12 = HEAP32[$12 - 8 >> 2];
     $18 = __wasm_i64_mul($12, $12 >> 31, $20, $10);
     $12 = $22 + $18 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $12 >>> 0 < $18 >>> 0 ? $3 + 1 | 0 : $3;
     $22 = $16;
     $18 = $12;
     $16 = $21 & 31;
     if (($21 & 63) >>> 0 >= 32) {
      $3 = $3 >> $16
     } else {
      $3 = ((1 << $16) - 1 & $3) << 32 - $16 | $18 >>> $16
     }
     HEAP32[$22 >> 2] = $7 - $3;
     $3 = $13 | 4;
     $16 = $3 + $5 | 0;
     $18 = HEAP32[$0 + $3 >> 2];
     $7 = __wasm_i64_mul($7, $7 >> 31, $6, $11);
     $3 = i64toi32_i32$HIGH_BITS;
     $4 = __wasm_i64_mul($4, $17, $20, $10);
     $7 = $4 + $7 | 0;
     $3 = i64toi32_i32$HIGH_BITS + $3 | 0;
     $3 = $4 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
     $4 = $7;
     $7 = $21 & 31;
     if (($21 & 63) >>> 0 >= 32) {
      $3 = $3 >> $7
     } else {
      $3 = ((1 << $7) - 1 & $3) << 32 - $7 | $4 >>> $7
     }
     HEAP32[$16 >> 2] = $18 - $3;
     $2 = $2 + 2 | 0;
     $1 = $1 + 2 | 0;
     if (($15 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
   }
   if (!$14) {
    break block1
   }
   $1 = $2 << 2;
   $4 = $1 + $5 | 0;
   $3 = $0 + $1 | 0;
   $2 = HEAP32[$3 >> 2];
   $0 = HEAP32[$3 - 4 >> 2];
   $0 = __wasm_i64_mul($0, $0 >> 31, $6, $11);
   $1 = i64toi32_i32$HIGH_BITS;
   $5 = $0;
   $3 = HEAP32[$3 - 8 >> 2];
   $0 = __wasm_i64_mul($3, $3 >> 31, $20, $10);
   $5 = $5 + $0 | 0;
   $3 = i64toi32_i32$HIGH_BITS + $1 | 0;
   $3 = $0 >>> 0 > $5 >>> 0 ? $3 + 1 | 0 : $3;
   $0 = $5;
   $1 = $21 & 31;
   if (($21 & 63) >>> 0 >= 32) {
    $0 = $3 >> $1
   } else {
    $0 = ((1 << $1) - 1 & $3) << 32 - $1 | $0 >>> $1
   }
   HEAP32[$4 >> 2] = $2 - $0;
  }
 }
 
 function FLAC__lpc_restore_signal($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0;
  block1 : {
   if ($3 >>> 0 >= 13) {
    if (($1 | 0) <= 0) {
     break block1
    }
    $8 = $5 - 56 | 0;
    $10 = $5 - 60 | 0;
    $11 = $5 + -64 | 0;
    $9 = $5 - 68 | 0;
    $12 = $5 - 72 | 0;
    $13 = $5 - 76 | 0;
    $14 = $5 - 80 | 0;
    $15 = $5 - 84 | 0;
    $16 = $5 - 88 | 0;
    $17 = $5 - 92 | 0;
    $18 = $5 - 96 | 0;
    $19 = $5 - 100 | 0;
    $20 = $5 - 104 | 0;
    $21 = $5 - 108 | 0;
    $22 = $5 - 112 | 0;
    $23 = $5 - 116 | 0;
    $24 = $5 - 120 | 0;
    $25 = $5 - 124 | 0;
    $26 = $5 - 128 | 0;
    $27 = $3 - 13 | 0;
    while (1) {
     $7 = 0;
     $3 = 0;
     block22 : {
      switch ($27 | 0) {
      case 19:
       $3 = Math_imul(HEAP32[($6 << 2) + $26 >> 2], HEAP32[$2 + 124 >> 2]);
      case 18:
       $3 = Math_imul(HEAP32[($6 << 2) + $25 >> 2], HEAP32[$2 + 120 >> 2]) + $3 | 0;
      case 17:
       $3 = Math_imul(HEAP32[($6 << 2) + $24 >> 2], HEAP32[$2 + 116 >> 2]) + $3 | 0;
      case 16:
       $3 = Math_imul(HEAP32[($6 << 2) + $23 >> 2], HEAP32[$2 + 112 >> 2]) + $3 | 0;
      case 15:
       $3 = Math_imul(HEAP32[($6 << 2) + $22 >> 2], HEAP32[$2 + 108 >> 2]) + $3 | 0;
      case 14:
       $3 = Math_imul(HEAP32[($6 << 2) + $21 >> 2], HEAP32[$2 + 104 >> 2]) + $3 | 0;
      case 13:
       $3 = Math_imul(HEAP32[($6 << 2) + $20 >> 2], HEAP32[$2 + 100 >> 2]) + $3 | 0;
      case 12:
       $3 = Math_imul(HEAP32[($6 << 2) + $19 >> 2], HEAP32[$2 + 96 >> 2]) + $3 | 0;
      case 11:
       $3 = Math_imul(HEAP32[($6 << 2) + $18 >> 2], HEAP32[$2 + 92 >> 2]) + $3 | 0;
      case 10:
       $3 = Math_imul(HEAP32[($6 << 2) + $17 >> 2], HEAP32[$2 + 88 >> 2]) + $3 | 0;
      case 9:
       $3 = Math_imul(HEAP32[($6 << 2) + $16 >> 2], HEAP32[$2 + 84 >> 2]) + $3 | 0;
      case 8:
       $3 = Math_imul(HEAP32[($6 << 2) + $15 >> 2], HEAP32[$2 + 80 >> 2]) + $3 | 0;
      case 7:
       $3 = Math_imul(HEAP32[($6 << 2) + $14 >> 2], HEAP32[$2 + 76 >> 2]) + $3 | 0;
      case 6:
       $3 = Math_imul(HEAP32[($6 << 2) + $13 >> 2], HEAP32[$2 + 72 >> 2]) + $3 | 0;
      case 5:
       $3 = Math_imul(HEAP32[($6 << 2) + $12 >> 2], HEAP32[$2 + 68 >> 2]) + $3 | 0;
      case 4:
       $3 = Math_imul(HEAP32[($6 << 2) + $9 >> 2], HEAP32[$2 + 64 >> 2]) + $3 | 0;
      case 3:
       $7 = Math_imul(HEAP32[($6 << 2) + $11 >> 2], HEAP32[$2 + 60 >> 2]) + $3 | 0;
      case 2:
       $7 = Math_imul(HEAP32[($6 << 2) + $10 >> 2], HEAP32[$2 + 56 >> 2]) + $7 | 0;
      case 1:
       $3 = Math_imul(HEAP32[($6 << 2) + $8 >> 2], HEAP32[$2 + 52 >> 2]) + $7 | 0;
      case 0:
       $7 = $3;
       $3 = ($6 << 2) + $5 | 0;
       $3 = (((((((((((($7 + Math_imul(HEAP32[$3 - 52 >> 2], HEAP32[$2 + 48 >> 2]) | 0) + Math_imul(HEAP32[$3 - 48 >> 2], HEAP32[$2 + 44 >> 2]) | 0) + Math_imul(HEAP32[$3 - 44 >> 2], HEAP32[$2 + 40 >> 2]) | 0) + Math_imul(HEAP32[$3 - 40 >> 2], HEAP32[$2 + 36 >> 2]) | 0) + Math_imul(HEAP32[$3 - 36 >> 2], HEAP32[$2 + 32 >> 2]) | 0) + Math_imul(HEAP32[$3 - 32 >> 2], HEAP32[$2 + 28 >> 2]) | 0) + Math_imul(HEAP32[$3 - 28 >> 2], HEAP32[$2 + 24 >> 2]) | 0) + Math_imul(HEAP32[$3 - 24 >> 2], HEAP32[$2 + 20 >> 2]) | 0) + Math_imul(HEAP32[$3 - 20 >> 2], HEAP32[$2 + 16 >> 2]) | 0) + Math_imul(HEAP32[$3 - 16 >> 2], HEAP32[$2 + 12 >> 2]) | 0) + Math_imul(HEAP32[$3 - 12 >> 2], HEAP32[$2 + 8 >> 2]) | 0) + Math_imul(HEAP32[$3 - 8 >> 2], HEAP32[$2 + 4 >> 2]) | 0) + Math_imul(HEAP32[$3 - 4 >> 2], HEAP32[$2 >> 2]) | 0;
       break;
      default:
       break block22;
      };
     }
     $7 = $6 << 2;
     HEAP32[$7 + $5 >> 2] = HEAP32[$0 + $7 >> 2] + ($3 >> $4);
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if ($3 >>> 0 >= 9) {
    if ($3 >>> 0 >= 11) {
     if (($3 | 0) != 12) {
      if (($1 | 0) <= 0) {
       break block1
      }
      $3 = HEAP32[$5 - 4 >> 2];
      $7 = HEAP32[$2 >> 2];
      $8 = HEAP32[$2 + 4 >> 2];
      $10 = HEAP32[$2 + 8 >> 2];
      $11 = HEAP32[$2 + 12 >> 2];
      $9 = HEAP32[$2 + 16 >> 2];
      $12 = HEAP32[$2 + 20 >> 2];
      $13 = HEAP32[$2 + 24 >> 2];
      $14 = HEAP32[$2 + 28 >> 2];
      $15 = HEAP32[$2 + 32 >> 2];
      $16 = HEAP32[$2 + 36 >> 2];
      $17 = HEAP32[$2 + 40 >> 2];
      while (1) {
       $18 = $6 << 2;
       $2 = $18 + $5 | 0;
       $3 = ((((((((((Math_imul($16, HEAP32[$2 - 40 >> 2]) + Math_imul($17, HEAP32[$2 - 44 >> 2]) | 0) + Math_imul($15, HEAP32[$2 - 36 >> 2]) | 0) + Math_imul($14, HEAP32[$2 - 32 >> 2]) | 0) + Math_imul($13, HEAP32[$2 - 28 >> 2]) | 0) + Math_imul($12, HEAP32[$2 - 24 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($11, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, $7) >> $4) + HEAP32[$0 + $18 >> 2] | 0;
       HEAP32[$2 >> 2] = $3;
       $6 = $6 + 1 | 0;
       if (($6 | 0) != ($1 | 0)) {
        continue
       }
       break;
      };
      break block1;
     }
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$5 - 4 >> 2];
     $7 = HEAP32[$2 >> 2];
     $8 = HEAP32[$2 + 4 >> 2];
     $10 = HEAP32[$2 + 8 >> 2];
     $11 = HEAP32[$2 + 12 >> 2];
     $9 = HEAP32[$2 + 16 >> 2];
     $12 = HEAP32[$2 + 20 >> 2];
     $13 = HEAP32[$2 + 24 >> 2];
     $14 = HEAP32[$2 + 28 >> 2];
     $15 = HEAP32[$2 + 32 >> 2];
     $16 = HEAP32[$2 + 36 >> 2];
     $17 = HEAP32[$2 + 40 >> 2];
     $18 = HEAP32[$2 + 44 >> 2];
     while (1) {
      $19 = $6 << 2;
      $2 = $19 + $5 | 0;
      $3 = (((((((((((Math_imul($17, HEAP32[$2 - 44 >> 2]) + Math_imul($18, HEAP32[$2 - 48 >> 2]) | 0) + Math_imul($16, HEAP32[$2 - 40 >> 2]) | 0) + Math_imul($15, HEAP32[$2 - 36 >> 2]) | 0) + Math_imul($14, HEAP32[$2 - 32 >> 2]) | 0) + Math_imul($13, HEAP32[$2 - 28 >> 2]) | 0) + Math_imul($12, HEAP32[$2 - 24 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($11, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, $7) >> $4) + HEAP32[$0 + $19 >> 2] | 0;
      HEAP32[$2 >> 2] = $3;
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($3 | 0) != 10) {
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$5 - 4 >> 2];
     $7 = HEAP32[$2 >> 2];
     $8 = HEAP32[$2 + 4 >> 2];
     $10 = HEAP32[$2 + 8 >> 2];
     $11 = HEAP32[$2 + 12 >> 2];
     $9 = HEAP32[$2 + 16 >> 2];
     $12 = HEAP32[$2 + 20 >> 2];
     $13 = HEAP32[$2 + 24 >> 2];
     $14 = HEAP32[$2 + 28 >> 2];
     $15 = HEAP32[$2 + 32 >> 2];
     while (1) {
      $16 = $6 << 2;
      $2 = $16 + $5 | 0;
      $3 = ((((((((Math_imul($14, HEAP32[$2 - 32 >> 2]) + Math_imul($15, HEAP32[$2 - 36 >> 2]) | 0) + Math_imul($13, HEAP32[$2 - 28 >> 2]) | 0) + Math_imul($12, HEAP32[$2 - 24 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($11, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, $7) >> $4) + HEAP32[$0 + $16 >> 2] | 0;
      HEAP32[$2 >> 2] = $3;
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($1 | 0) <= 0) {
     break block1
    }
    $3 = HEAP32[$5 - 4 >> 2];
    $7 = HEAP32[$2 >> 2];
    $8 = HEAP32[$2 + 4 >> 2];
    $10 = HEAP32[$2 + 8 >> 2];
    $11 = HEAP32[$2 + 12 >> 2];
    $9 = HEAP32[$2 + 16 >> 2];
    $12 = HEAP32[$2 + 20 >> 2];
    $13 = HEAP32[$2 + 24 >> 2];
    $14 = HEAP32[$2 + 28 >> 2];
    $15 = HEAP32[$2 + 32 >> 2];
    $16 = HEAP32[$2 + 36 >> 2];
    while (1) {
     $17 = $6 << 2;
     $2 = $17 + $5 | 0;
     $3 = (((((((((Math_imul($15, HEAP32[$2 - 36 >> 2]) + Math_imul($16, HEAP32[$2 - 40 >> 2]) | 0) + Math_imul($14, HEAP32[$2 - 32 >> 2]) | 0) + Math_imul($13, HEAP32[$2 - 28 >> 2]) | 0) + Math_imul($12, HEAP32[$2 - 24 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($11, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, $7) >> $4) + HEAP32[$0 + $17 >> 2] | 0;
     HEAP32[$2 >> 2] = $3;
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if ($3 >>> 0 >= 5) {
    if ($3 >>> 0 >= 7) {
     if (($3 | 0) != 8) {
      if (($1 | 0) <= 0) {
       break block1
      }
      $3 = HEAP32[$5 - 4 >> 2];
      $7 = HEAP32[$2 >> 2];
      $8 = HEAP32[$2 + 4 >> 2];
      $10 = HEAP32[$2 + 8 >> 2];
      $11 = HEAP32[$2 + 12 >> 2];
      $9 = HEAP32[$2 + 16 >> 2];
      $12 = HEAP32[$2 + 20 >> 2];
      $13 = HEAP32[$2 + 24 >> 2];
      while (1) {
       $14 = $6 << 2;
       $2 = $14 + $5 | 0;
       $3 = ((((((Math_imul($12, HEAP32[$2 - 24 >> 2]) + Math_imul($13, HEAP32[$2 - 28 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($11, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, $7) >> $4) + HEAP32[$0 + $14 >> 2] | 0;
       HEAP32[$2 >> 2] = $3;
       $6 = $6 + 1 | 0;
       if (($6 | 0) != ($1 | 0)) {
        continue
       }
       break;
      };
      break block1;
     }
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$5 - 4 >> 2];
     $7 = HEAP32[$2 >> 2];
     $8 = HEAP32[$2 + 4 >> 2];
     $10 = HEAP32[$2 + 8 >> 2];
     $11 = HEAP32[$2 + 12 >> 2];
     $9 = HEAP32[$2 + 16 >> 2];
     $12 = HEAP32[$2 + 20 >> 2];
     $13 = HEAP32[$2 + 24 >> 2];
     $14 = HEAP32[$2 + 28 >> 2];
     while (1) {
      $15 = $6 << 2;
      $2 = $15 + $5 | 0;
      $3 = (((((((Math_imul($13, HEAP32[$2 - 28 >> 2]) + Math_imul($14, HEAP32[$2 - 32 >> 2]) | 0) + Math_imul($12, HEAP32[$2 - 24 >> 2]) | 0) + Math_imul($9, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($11, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, $7) >> $4) + HEAP32[$0 + $15 >> 2] | 0;
      HEAP32[$2 >> 2] = $3;
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($3 | 0) != 6) {
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$5 - 4 >> 2];
     $7 = HEAP32[$2 >> 2];
     $8 = HEAP32[$2 + 4 >> 2];
     $10 = HEAP32[$2 + 8 >> 2];
     $11 = HEAP32[$2 + 12 >> 2];
     $9 = HEAP32[$2 + 16 >> 2];
     while (1) {
      $12 = $6 << 2;
      $2 = $12 + $5 | 0;
      $3 = ((((Math_imul($11, HEAP32[$2 - 16 >> 2]) + Math_imul($9, HEAP32[$2 - 20 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, $7) >> $4) + HEAP32[$0 + $12 >> 2] | 0;
      HEAP32[$2 >> 2] = $3;
      $6 = $6 + 1 | 0;
      if (($6 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($1 | 0) <= 0) {
     break block1
    }
    $3 = HEAP32[$5 - 4 >> 2];
    $7 = HEAP32[$2 >> 2];
    $8 = HEAP32[$2 + 4 >> 2];
    $10 = HEAP32[$2 + 8 >> 2];
    $11 = HEAP32[$2 + 12 >> 2];
    $9 = HEAP32[$2 + 16 >> 2];
    $12 = HEAP32[$2 + 20 >> 2];
    while (1) {
     $13 = $6 << 2;
     $2 = $13 + $5 | 0;
     $3 = (((((Math_imul($9, HEAP32[$2 - 20 >> 2]) + Math_imul($12, HEAP32[$2 - 24 >> 2]) | 0) + Math_imul($11, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($10, HEAP32[$2 - 12 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, $7) >> $4) + HEAP32[$0 + $13 >> 2] | 0;
     HEAP32[$2 >> 2] = $3;
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if ($3 >>> 0 >= 3) {
    if (($3 | 0) != 4) {
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$5 - 4 >> 2];
     $7 = HEAP32[$2 >> 2];
     $8 = HEAP32[$2 + 4 >> 2];
     $10 = HEAP32[$2 + 8 >> 2];
     $2 = 0;
     while (1) {
      $11 = $2 << 2;
      $6 = $11 + $5 | 0;
      $3 = ((Math_imul($8, HEAP32[$6 - 8 >> 2]) + Math_imul($10, HEAP32[$6 - 12 >> 2]) | 0) + Math_imul($3, $7) >> $4) + HEAP32[$0 + $11 >> 2] | 0;
      HEAP32[$6 >> 2] = $3;
      $2 = $2 + 1 | 0;
      if (($2 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($1 | 0) <= 0) {
     break block1
    }
    $3 = HEAP32[$5 - 4 >> 2];
    $7 = HEAP32[$2 >> 2];
    $8 = HEAP32[$2 + 4 >> 2];
    $10 = HEAP32[$2 + 8 >> 2];
    $11 = HEAP32[$2 + 12 >> 2];
    while (1) {
     $9 = $6 << 2;
     $2 = $9 + $5 | 0;
     $3 = (((Math_imul($10, HEAP32[$2 - 12 >> 2]) + Math_imul($11, HEAP32[$2 - 16 >> 2]) | 0) + Math_imul($8, HEAP32[$2 - 8 >> 2]) | 0) + Math_imul($3, $7) >> $4) + HEAP32[$0 + $9 >> 2] | 0;
     HEAP32[$2 >> 2] = $3;
     $6 = $6 + 1 | 0;
     if (($6 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if (($3 | 0) != 2) {
    if (($1 | 0) <= 0) {
     break block1
    }
    $8 = $1 & 1;
    $3 = HEAP32[$5 - 4 >> 2];
    $6 = HEAP32[$2 >> 2];
    $2 = 0;
    if (($1 | 0) != 1) {
     $10 = $1 & 2147483646;
     while (1) {
      $1 = $2 << 2;
      $3 = HEAP32[$1 + $0 >> 2] + (Math_imul($3, $6) >> $4) | 0;
      HEAP32[$1 + $5 >> 2] = $3;
      $1 = $1 | 4;
      $3 = HEAP32[$1 + $0 >> 2] + (Math_imul($3, $6) >> $4) | 0;
      HEAP32[$1 + $5 >> 2] = $3;
      $2 = $2 + 2 | 0;
      $7 = $7 + 2 | 0;
      if (($10 | 0) != ($7 | 0)) {
       continue
      }
      break;
     };
    }
    if (!$8) {
     break block1
    }
    $1 = $2 << 2;
    HEAP32[$1 + $5 >> 2] = HEAP32[$0 + $1 >> 2] + (Math_imul($3, $6) >> $4);
    return;
   }
   if (($1 | 0) <= 0) {
    break block1
   }
   $10 = $1 & 1;
   $3 = HEAP32[$5 - 4 >> 2];
   $6 = HEAP32[$2 >> 2];
   $8 = HEAP32[$2 + 4 >> 2];
   $2 = 0;
   if (($1 | 0) != 1) {
    $11 = $1 & 2147483646;
    while (1) {
     $1 = $2 << 2;
     $9 = $1 + $5 | 0;
     $3 = (Math_imul($3, $6) + Math_imul($8, HEAP32[$9 - 8 >> 2]) >> $4) + HEAP32[$0 + $1 >> 2] | 0;
     HEAP32[$9 >> 2] = $3;
     $1 = $1 | 4;
     $9 = $1 + $5 | 0;
     $3 = (Math_imul($3, $6) + Math_imul($8, HEAP32[$9 - 8 >> 2]) >> $4) + HEAP32[$0 + $1 >> 2] | 0;
     HEAP32[$9 >> 2] = $3;
     $2 = $2 + 2 | 0;
     $7 = $7 + 2 | 0;
     if (($11 | 0) != ($7 | 0)) {
      continue
     }
     break;
    };
   }
   if (!$10) {
    break block1
   }
   $1 = $2 << 2;
   $2 = $1 + $5 | 0;
   HEAP32[$2 >> 2] = HEAP32[$0 + $1 >> 2] + (Math_imul($3, $6) + Math_imul($8, HEAP32[$2 - 8 >> 2]) >> $4);
  }
 }
 
 function FLAC__lpc_restore_signal_wide($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0;
  block1 : {
   if ($3 >>> 0 >= 13) {
    if (($1 | 0) <= 0) {
     break block1
    }
    $33 = $5 - 56 | 0;
    $24 = $5 - 60 | 0;
    $32 = $5 + -64 | 0;
    $26 = $5 - 68 | 0;
    $31 = $5 - 72 | 0;
    $27 = $5 - 76 | 0;
    $30 = $5 - 80 | 0;
    $28 = $5 - 84 | 0;
    $29 = $5 - 88 | 0;
    $22 = $5 - 92 | 0;
    $10 = $5 - 96 | 0;
    $9 = $5 - 100 | 0;
    $12 = $5 - 104 | 0;
    $11 = $5 - 108 | 0;
    $14 = $5 - 112 | 0;
    $16 = $5 - 116 | 0;
    $15 = $5 - 120 | 0;
    $17 = $5 - 124 | 0;
    $19 = $5 - 128 | 0;
    $18 = $4;
    $4 = 0;
    $20 = $3 - 13 | 0;
    while (1) {
     $7 = 0;
     $3 = 0;
     block22 : {
      switch ($20 | 0) {
      case 19:
       $3 = HEAP32[($4 << 2) + $19 >> 2];
       $6 = $3;
       $7 = $3 >> 31;
       $3 = HEAP32[$2 + 124 >> 2];
       $7 = __wasm_i64_mul($6, $7, $3, $3 >> 31);
       $3 = i64toi32_i32$HIGH_BITS;
      case 18:
       $6 = HEAP32[($4 << 2) + $17 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 120 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 17:
       $6 = HEAP32[($4 << 2) + $15 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 116 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 16:
       $6 = HEAP32[($4 << 2) + $16 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 112 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 15:
       $6 = HEAP32[($4 << 2) + $14 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 108 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 14:
       $6 = HEAP32[($4 << 2) + $11 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 104 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 13:
       $6 = HEAP32[($4 << 2) + $12 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 100 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 12:
       $6 = HEAP32[($4 << 2) + $9 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 96 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 11:
       $6 = HEAP32[($4 << 2) + $10 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 92 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 10:
       $6 = HEAP32[($4 << 2) + $22 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 88 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 9:
       $6 = HEAP32[($4 << 2) + $29 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 84 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 8:
       $6 = HEAP32[($4 << 2) + $28 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 80 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 7:
       $6 = HEAP32[($4 << 2) + $30 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 76 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 6:
       $6 = HEAP32[($4 << 2) + $27 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 72 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 5:
       $6 = HEAP32[($4 << 2) + $31 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 68 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 4:
       $6 = HEAP32[($4 << 2) + $26 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 64 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 3:
       $6 = HEAP32[($4 << 2) + $32 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 60 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 2:
       $6 = HEAP32[$24 + ($4 << 2) >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 56 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 1:
       $6 = HEAP32[$33 + ($4 << 2) >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 52 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7;
       $7 = $7 + $8 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
      case 0:
       $21 = ($4 << 2) + $5 | 0;
       $6 = HEAP32[$21 - 52 >> 2];
       $8 = $6;
       $13 = $6 >> 31;
       $6 = HEAP32[$2 + 48 >> 2];
       $8 = __wasm_i64_mul($8, $13, $6, $6 >> 31);
       $6 = $3 + i64toi32_i32$HIGH_BITS | 0;
       $3 = $7 + $8 | 0;
       $6 = $3 >>> 0 < $7 >>> 0 ? $6 + 1 | 0 : $6;
       $7 = $3;
       $3 = HEAP32[$21 - 48 >> 2];
       $8 = $3;
       $13 = $3 >> 31;
       $3 = HEAP32[$2 + 44 >> 2];
       $3 = __wasm_i64_mul($8, $13, $3, $3 >> 31);
       $7 = $7 + $3 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = HEAP32[$21 - 44 >> 2];
       $8 = $3;
       $13 = $3 >> 31;
       $3 = HEAP32[$2 + 40 >> 2];
       $3 = __wasm_i64_mul($8, $13, $3, $3 >> 31);
       $7 = $3 + $7 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = HEAP32[$21 - 40 >> 2];
       $8 = $3;
       $13 = $3 >> 31;
       $3 = HEAP32[$2 + 36 >> 2];
       $3 = __wasm_i64_mul($8, $13, $3, $3 >> 31);
       $7 = $3 + $7 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = HEAP32[$21 - 36 >> 2];
       $8 = $3;
       $13 = $3 >> 31;
       $3 = HEAP32[$2 + 32 >> 2];
       $3 = __wasm_i64_mul($8, $13, $3, $3 >> 31);
       $7 = $3 + $7 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = HEAP32[$21 - 32 >> 2];
       $8 = $3;
       $13 = $3 >> 31;
       $3 = HEAP32[$2 + 28 >> 2];
       $3 = __wasm_i64_mul($8, $13, $3, $3 >> 31);
       $7 = $3 + $7 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = HEAP32[$21 - 28 >> 2];
       $8 = $3;
       $13 = $3 >> 31;
       $3 = HEAP32[$2 + 24 >> 2];
       $3 = __wasm_i64_mul($8, $13, $3, $3 >> 31);
       $7 = $3 + $7 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = HEAP32[$21 - 24 >> 2];
       $8 = $3;
       $13 = $3 >> 31;
       $3 = HEAP32[$2 + 20 >> 2];
       $3 = __wasm_i64_mul($8, $13, $3, $3 >> 31);
       $7 = $3 + $7 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = HEAP32[$21 - 20 >> 2];
       $8 = $3;
       $13 = $3 >> 31;
       $3 = HEAP32[$2 + 16 >> 2];
       $3 = __wasm_i64_mul($8, $13, $3, $3 >> 31);
       $7 = $3 + $7 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = HEAP32[$21 - 16 >> 2];
       $8 = $3;
       $13 = $3 >> 31;
       $3 = HEAP32[$2 + 12 >> 2];
       $3 = __wasm_i64_mul($8, $13, $3, $3 >> 31);
       $7 = $3 + $7 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = HEAP32[$21 - 12 >> 2];
       $8 = $3;
       $13 = $3 >> 31;
       $3 = HEAP32[$2 + 8 >> 2];
       $3 = __wasm_i64_mul($8, $13, $3, $3 >> 31);
       $7 = $3 + $7 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = HEAP32[$21 - 8 >> 2];
       $8 = $3;
       $13 = $3 >> 31;
       $3 = HEAP32[$2 + 4 >> 2];
       $3 = __wasm_i64_mul($8, $13, $3, $3 >> 31);
       $7 = $3 + $7 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = HEAP32[$21 - 4 >> 2];
       $8 = $3;
       $13 = $3 >> 31;
       $3 = HEAP32[$2 >> 2];
       $3 = __wasm_i64_mul($8, $13, $3, $3 >> 31);
       $7 = $3 + $7 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $3 = $3 >>> 0 > $7 >>> 0 ? $6 + 1 | 0 : $6;
       break;
      default:
       break block22;
      };
     }
     $6 = $4 << 2;
     $8 = $6 + $5 | 0;
     $13 = HEAP32[$0 + $6 >> 2];
     $6 = $18 & 31;
     if (($18 & 63) >>> 0 >= 32) {
      $3 = $3 >> $6
     } else {
      $3 = ((1 << $6) - 1 & $3) << 32 - $6 | $7 >>> $6
     }
     HEAP32[$8 >> 2] = $13 + $3;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if ($3 >>> 0 >= 9) {
    if ($3 >>> 0 >= 11) {
     if (($3 | 0) != 12) {
      if (($1 | 0) <= 0) {
       break block1
      }
      $3 = HEAP32[$5 - 4 >> 2];
      $12 = $4;
      $11 = HEAP32[$2 >> 2];
      $34 = $11 >> 31;
      $14 = HEAP32[$2 + 4 >> 2];
      $21 = $14 >> 31;
      $16 = HEAP32[$2 + 8 >> 2];
      $33 = $16 >> 31;
      $15 = HEAP32[$2 + 12 >> 2];
      $24 = $15 >> 31;
      $17 = HEAP32[$2 + 16 >> 2];
      $32 = $17 >> 31;
      $19 = HEAP32[$2 + 20 >> 2];
      $26 = $19 >> 31;
      $20 = HEAP32[$2 + 24 >> 2];
      $31 = $20 >> 31;
      $8 = HEAP32[$2 + 28 >> 2];
      $27 = $8 >> 31;
      $18 = HEAP32[$2 + 32 >> 2];
      $30 = $18 >> 31;
      $7 = HEAP32[$2 + 36 >> 2];
      $28 = $7 >> 31;
      $2 = HEAP32[$2 + 40 >> 2];
      $29 = $2 >> 31;
      $4 = 0;
      while (1) {
       $6 = $4 << 2;
       $22 = $6 + $5 | 0;
       $10 = HEAP32[$0 + $6 >> 2];
       $6 = HEAP32[$22 - 40 >> 2];
       $9 = __wasm_i64_mul($6, $6 >> 31, $7, $28);
       $6 = i64toi32_i32$HIGH_BITS;
       $13 = $9;
       $25 = HEAP32[$22 - 44 >> 2];
       $9 = __wasm_i64_mul($25, $25 >> 31, $2, $29);
       $25 = $13 + $9 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $9 >>> 0 > $25 >>> 0 ? $6 + 1 | 0 : $6;
       $9 = HEAP32[$22 - 36 >> 2];
       $9 = __wasm_i64_mul($9, $9 >> 31, $18, $30);
       $25 = $9 + $25 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $9 >>> 0 > $25 >>> 0 ? $6 + 1 | 0 : $6;
       $9 = HEAP32[$22 - 32 >> 2];
       $9 = __wasm_i64_mul($9, $9 >> 31, $8, $27);
       $25 = $9 + $25 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $9 >>> 0 > $25 >>> 0 ? $6 + 1 | 0 : $6;
       $9 = HEAP32[$22 - 28 >> 2];
       $9 = __wasm_i64_mul($9, $9 >> 31, $20, $31);
       $25 = $9 + $25 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $9 >>> 0 > $25 >>> 0 ? $6 + 1 | 0 : $6;
       $9 = HEAP32[$22 - 24 >> 2];
       $9 = __wasm_i64_mul($9, $9 >> 31, $19, $26);
       $25 = $9 + $25 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $9 >>> 0 > $25 >>> 0 ? $6 + 1 | 0 : $6;
       $9 = HEAP32[$22 - 20 >> 2];
       $9 = __wasm_i64_mul($9, $9 >> 31, $17, $32);
       $25 = $9 + $25 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $9 >>> 0 > $25 >>> 0 ? $6 + 1 | 0 : $6;
       $9 = HEAP32[$22 - 16 >> 2];
       $9 = __wasm_i64_mul($9, $9 >> 31, $15, $24);
       $25 = $9 + $25 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $9 >>> 0 > $25 >>> 0 ? $6 + 1 | 0 : $6;
       $9 = HEAP32[$22 - 12 >> 2];
       $9 = __wasm_i64_mul($9, $9 >> 31, $16, $33);
       $25 = $9 + $25 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $9 >>> 0 > $25 >>> 0 ? $6 + 1 | 0 : $6;
       $9 = HEAP32[$22 - 8 >> 2];
       $9 = __wasm_i64_mul($9, $9 >> 31, $14, $21);
       $25 = $9 + $25 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $9 >>> 0 > $25 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = __wasm_i64_mul($3, $3 >> 31, $11, $34);
       $9 = $3 + $25 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $9 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = $9;
       $9 = $12 & 31;
       if (($12 & 63) >>> 0 >= 32) {
        $3 = $6 >> $9
       } else {
        $3 = ((1 << $9) - 1 & $6) << 32 - $9 | $3 >>> $9
       }
       $3 = $3 + $10 | 0;
       HEAP32[$22 >> 2] = $3;
       $4 = $4 + 1 | 0;
       if (($4 | 0) != ($1 | 0)) {
        continue
       }
       break;
      };
      break block1;
     }
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$5 - 4 >> 2];
     $9 = $4;
     $12 = HEAP32[$2 >> 2];
     $35 = $12 >> 31;
     $11 = HEAP32[$2 + 4 >> 2];
     $25 = $11 >> 31;
     $14 = HEAP32[$2 + 8 >> 2];
     $34 = $14 >> 31;
     $16 = HEAP32[$2 + 12 >> 2];
     $21 = $16 >> 31;
     $15 = HEAP32[$2 + 16 >> 2];
     $33 = $15 >> 31;
     $17 = HEAP32[$2 + 20 >> 2];
     $24 = $17 >> 31;
     $19 = HEAP32[$2 + 24 >> 2];
     $32 = $19 >> 31;
     $20 = HEAP32[$2 + 28 >> 2];
     $26 = $20 >> 31;
     $8 = HEAP32[$2 + 32 >> 2];
     $31 = $8 >> 31;
     $18 = HEAP32[$2 + 36 >> 2];
     $27 = $18 >> 31;
     $7 = HEAP32[$2 + 40 >> 2];
     $30 = $7 >> 31;
     $2 = HEAP32[$2 + 44 >> 2];
     $28 = $2 >> 31;
     $4 = 0;
     while (1) {
      $6 = $4 << 2;
      $29 = $6 + $5 | 0;
      $22 = HEAP32[$0 + $6 >> 2];
      $6 = HEAP32[$29 - 44 >> 2];
      $10 = __wasm_i64_mul($6, $6 >> 31, $7, $30);
      $6 = i64toi32_i32$HIGH_BITS;
      $13 = $10;
      $23 = HEAP32[$29 - 48 >> 2];
      $10 = __wasm_i64_mul($23, $23 >> 31, $2, $28);
      $23 = $13 + $10 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $10 >>> 0 > $23 >>> 0 ? $6 + 1 | 0 : $6;
      $10 = HEAP32[$29 - 40 >> 2];
      $10 = __wasm_i64_mul($10, $10 >> 31, $18, $27);
      $23 = $10 + $23 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $10 >>> 0 > $23 >>> 0 ? $6 + 1 | 0 : $6;
      $10 = HEAP32[$29 - 36 >> 2];
      $10 = __wasm_i64_mul($10, $10 >> 31, $8, $31);
      $23 = $10 + $23 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $10 >>> 0 > $23 >>> 0 ? $6 + 1 | 0 : $6;
      $10 = HEAP32[$29 - 32 >> 2];
      $10 = __wasm_i64_mul($10, $10 >> 31, $20, $26);
      $23 = $10 + $23 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $10 >>> 0 > $23 >>> 0 ? $6 + 1 | 0 : $6;
      $10 = HEAP32[$29 - 28 >> 2];
      $10 = __wasm_i64_mul($10, $10 >> 31, $19, $32);
      $23 = $10 + $23 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $10 >>> 0 > $23 >>> 0 ? $6 + 1 | 0 : $6;
      $10 = HEAP32[$29 - 24 >> 2];
      $10 = __wasm_i64_mul($10, $10 >> 31, $17, $24);
      $23 = $10 + $23 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $10 >>> 0 > $23 >>> 0 ? $6 + 1 | 0 : $6;
      $10 = HEAP32[$29 - 20 >> 2];
      $10 = __wasm_i64_mul($10, $10 >> 31, $15, $33);
      $23 = $10 + $23 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $10 >>> 0 > $23 >>> 0 ? $6 + 1 | 0 : $6;
      $10 = HEAP32[$29 - 16 >> 2];
      $10 = __wasm_i64_mul($10, $10 >> 31, $16, $21);
      $23 = $10 + $23 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $10 >>> 0 > $23 >>> 0 ? $6 + 1 | 0 : $6;
      $10 = HEAP32[$29 - 12 >> 2];
      $10 = __wasm_i64_mul($10, $10 >> 31, $14, $34);
      $23 = $10 + $23 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $10 >>> 0 > $23 >>> 0 ? $6 + 1 | 0 : $6;
      $10 = HEAP32[$29 - 8 >> 2];
      $10 = __wasm_i64_mul($10, $10 >> 31, $11, $25);
      $23 = $10 + $23 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $10 >>> 0 > $23 >>> 0 ? $6 + 1 | 0 : $6;
      $3 = __wasm_i64_mul($3, $3 >> 31, $12, $35);
      $10 = $3 + $23 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $3 >>> 0 > $10 >>> 0 ? $6 + 1 | 0 : $6;
      $3 = $10;
      $10 = $9 & 31;
      if (($9 & 63) >>> 0 >= 32) {
       $3 = $6 >> $10
      } else {
       $3 = ((1 << $10) - 1 & $6) << 32 - $10 | $3 >>> $10
      }
      $3 = $3 + $22 | 0;
      HEAP32[$29 >> 2] = $3;
      $4 = $4 + 1 | 0;
      if (($4 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($3 | 0) != 10) {
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$5 - 4 >> 2];
     $14 = $4;
     $16 = HEAP32[$2 >> 2];
     $32 = $16 >> 31;
     $15 = HEAP32[$2 + 4 >> 2];
     $26 = $15 >> 31;
     $17 = HEAP32[$2 + 8 >> 2];
     $31 = $17 >> 31;
     $19 = HEAP32[$2 + 12 >> 2];
     $27 = $19 >> 31;
     $20 = HEAP32[$2 + 16 >> 2];
     $30 = $20 >> 31;
     $8 = HEAP32[$2 + 20 >> 2];
     $28 = $8 >> 31;
     $18 = HEAP32[$2 + 24 >> 2];
     $29 = $18 >> 31;
     $7 = HEAP32[$2 + 28 >> 2];
     $22 = $7 >> 31;
     $2 = HEAP32[$2 + 32 >> 2];
     $10 = $2 >> 31;
     $4 = 0;
     while (1) {
      $6 = $4 << 2;
      $9 = $6 + $5 | 0;
      $12 = HEAP32[$0 + $6 >> 2];
      $6 = HEAP32[$9 - 32 >> 2];
      $11 = __wasm_i64_mul($6, $6 >> 31, $7, $22);
      $6 = i64toi32_i32$HIGH_BITS;
      $13 = $11;
      $24 = HEAP32[$9 - 36 >> 2];
      $11 = __wasm_i64_mul($24, $24 >> 31, $2, $10);
      $24 = $13 + $11 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $11 >>> 0 > $24 >>> 0 ? $6 + 1 | 0 : $6;
      $11 = HEAP32[$9 - 28 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $18, $29);
      $24 = $11 + $24 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $11 >>> 0 > $24 >>> 0 ? $6 + 1 | 0 : $6;
      $11 = HEAP32[$9 - 24 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $8, $28);
      $24 = $11 + $24 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $11 >>> 0 > $24 >>> 0 ? $6 + 1 | 0 : $6;
      $11 = HEAP32[$9 - 20 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $20, $30);
      $24 = $11 + $24 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $11 >>> 0 > $24 >>> 0 ? $6 + 1 | 0 : $6;
      $11 = HEAP32[$9 - 16 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $19, $27);
      $24 = $11 + $24 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $11 >>> 0 > $24 >>> 0 ? $6 + 1 | 0 : $6;
      $11 = HEAP32[$9 - 12 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $17, $31);
      $24 = $11 + $24 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $11 >>> 0 > $24 >>> 0 ? $6 + 1 | 0 : $6;
      $11 = HEAP32[$9 - 8 >> 2];
      $11 = __wasm_i64_mul($11, $11 >> 31, $15, $26);
      $24 = $11 + $24 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $11 >>> 0 > $24 >>> 0 ? $6 + 1 | 0 : $6;
      $3 = __wasm_i64_mul($3, $3 >> 31, $16, $32);
      $11 = $3 + $24 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $3 >>> 0 > $11 >>> 0 ? $6 + 1 | 0 : $6;
      $3 = $11;
      $11 = $14 & 31;
      if (($14 & 63) >>> 0 >= 32) {
       $3 = $6 >> $11
      } else {
       $3 = ((1 << $11) - 1 & $6) << 32 - $11 | $3 >>> $11
      }
      $3 = $3 + $12 | 0;
      HEAP32[$9 >> 2] = $3;
      $4 = $4 + 1 | 0;
      if (($4 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($1 | 0) <= 0) {
     break block1
    }
    $3 = HEAP32[$5 - 4 >> 2];
    $11 = $4;
    $14 = HEAP32[$2 >> 2];
    $33 = $14 >> 31;
    $16 = HEAP32[$2 + 4 >> 2];
    $24 = $16 >> 31;
    $15 = HEAP32[$2 + 8 >> 2];
    $32 = $15 >> 31;
    $17 = HEAP32[$2 + 12 >> 2];
    $26 = $17 >> 31;
    $19 = HEAP32[$2 + 16 >> 2];
    $31 = $19 >> 31;
    $20 = HEAP32[$2 + 20 >> 2];
    $27 = $20 >> 31;
    $8 = HEAP32[$2 + 24 >> 2];
    $30 = $8 >> 31;
    $18 = HEAP32[$2 + 28 >> 2];
    $28 = $18 >> 31;
    $7 = HEAP32[$2 + 32 >> 2];
    $29 = $7 >> 31;
    $2 = HEAP32[$2 + 36 >> 2];
    $22 = $2 >> 31;
    $4 = 0;
    while (1) {
     $6 = $4 << 2;
     $10 = $6 + $5 | 0;
     $9 = HEAP32[$0 + $6 >> 2];
     $6 = HEAP32[$10 - 36 >> 2];
     $12 = __wasm_i64_mul($6, $6 >> 31, $7, $29);
     $6 = i64toi32_i32$HIGH_BITS;
     $13 = $12;
     $21 = HEAP32[$10 - 40 >> 2];
     $12 = __wasm_i64_mul($21, $21 >> 31, $2, $22);
     $21 = $13 + $12 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $12 >>> 0 > $21 >>> 0 ? $6 + 1 | 0 : $6;
     $12 = HEAP32[$10 - 32 >> 2];
     $12 = __wasm_i64_mul($12, $12 >> 31, $18, $28);
     $21 = $12 + $21 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $12 >>> 0 > $21 >>> 0 ? $6 + 1 | 0 : $6;
     $12 = HEAP32[$10 - 28 >> 2];
     $12 = __wasm_i64_mul($12, $12 >> 31, $8, $30);
     $21 = $12 + $21 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $12 >>> 0 > $21 >>> 0 ? $6 + 1 | 0 : $6;
     $12 = HEAP32[$10 - 24 >> 2];
     $12 = __wasm_i64_mul($12, $12 >> 31, $20, $27);
     $21 = $12 + $21 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $12 >>> 0 > $21 >>> 0 ? $6 + 1 | 0 : $6;
     $12 = HEAP32[$10 - 20 >> 2];
     $12 = __wasm_i64_mul($12, $12 >> 31, $19, $31);
     $21 = $12 + $21 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $12 >>> 0 > $21 >>> 0 ? $6 + 1 | 0 : $6;
     $12 = HEAP32[$10 - 16 >> 2];
     $12 = __wasm_i64_mul($12, $12 >> 31, $17, $26);
     $21 = $12 + $21 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $12 >>> 0 > $21 >>> 0 ? $6 + 1 | 0 : $6;
     $12 = HEAP32[$10 - 12 >> 2];
     $12 = __wasm_i64_mul($12, $12 >> 31, $15, $32);
     $21 = $12 + $21 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $12 >>> 0 > $21 >>> 0 ? $6 + 1 | 0 : $6;
     $12 = HEAP32[$10 - 8 >> 2];
     $12 = __wasm_i64_mul($12, $12 >> 31, $16, $24);
     $21 = $12 + $21 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $12 >>> 0 > $21 >>> 0 ? $6 + 1 | 0 : $6;
     $3 = __wasm_i64_mul($3, $3 >> 31, $14, $33);
     $12 = $3 + $21 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $3 >>> 0 > $12 >>> 0 ? $6 + 1 | 0 : $6;
     $3 = $12;
     $12 = $11 & 31;
     if (($11 & 63) >>> 0 >= 32) {
      $3 = $6 >> $12
     } else {
      $3 = ((1 << $12) - 1 & $6) << 32 - $12 | $3 >>> $12
     }
     $3 = $3 + $9 | 0;
     HEAP32[$10 >> 2] = $3;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if ($3 >>> 0 >= 5) {
    if ($3 >>> 0 >= 7) {
     if (($3 | 0) != 8) {
      if (($1 | 0) <= 0) {
       break block1
      }
      $3 = HEAP32[$5 - 4 >> 2];
      $15 = $4;
      $17 = HEAP32[$2 >> 2];
      $30 = $17 >> 31;
      $19 = HEAP32[$2 + 4 >> 2];
      $28 = $19 >> 31;
      $20 = HEAP32[$2 + 8 >> 2];
      $29 = $20 >> 31;
      $8 = HEAP32[$2 + 12 >> 2];
      $22 = $8 >> 31;
      $18 = HEAP32[$2 + 16 >> 2];
      $10 = $18 >> 31;
      $7 = HEAP32[$2 + 20 >> 2];
      $9 = $7 >> 31;
      $2 = HEAP32[$2 + 24 >> 2];
      $12 = $2 >> 31;
      $4 = 0;
      while (1) {
       $6 = $4 << 2;
       $11 = $6 + $5 | 0;
       $14 = HEAP32[$0 + $6 >> 2];
       $6 = HEAP32[$11 - 24 >> 2];
       $16 = __wasm_i64_mul($6, $6 >> 31, $7, $9);
       $6 = i64toi32_i32$HIGH_BITS;
       $13 = $16;
       $27 = HEAP32[$11 - 28 >> 2];
       $16 = __wasm_i64_mul($27, $27 >> 31, $2, $12);
       $27 = $13 + $16 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $16 >>> 0 > $27 >>> 0 ? $6 + 1 | 0 : $6;
       $16 = HEAP32[$11 - 20 >> 2];
       $16 = __wasm_i64_mul($16, $16 >> 31, $18, $10);
       $27 = $16 + $27 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $16 >>> 0 > $27 >>> 0 ? $6 + 1 | 0 : $6;
       $16 = HEAP32[$11 - 16 >> 2];
       $16 = __wasm_i64_mul($16, $16 >> 31, $8, $22);
       $27 = $16 + $27 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $16 >>> 0 > $27 >>> 0 ? $6 + 1 | 0 : $6;
       $16 = HEAP32[$11 - 12 >> 2];
       $16 = __wasm_i64_mul($16, $16 >> 31, $20, $29);
       $27 = $16 + $27 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $16 >>> 0 > $27 >>> 0 ? $6 + 1 | 0 : $6;
       $16 = HEAP32[$11 - 8 >> 2];
       $16 = __wasm_i64_mul($16, $16 >> 31, $19, $28);
       $27 = $16 + $27 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $16 >>> 0 > $27 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = __wasm_i64_mul($3, $3 >> 31, $17, $30);
       $16 = $3 + $27 | 0;
       $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
       $6 = $3 >>> 0 > $16 >>> 0 ? $6 + 1 | 0 : $6;
       $3 = $16;
       $16 = $15 & 31;
       if (($15 & 63) >>> 0 >= 32) {
        $3 = $6 >> $16
       } else {
        $3 = ((1 << $16) - 1 & $6) << 32 - $16 | $3 >>> $16
       }
       $3 = $3 + $14 | 0;
       HEAP32[$11 >> 2] = $3;
       $4 = $4 + 1 | 0;
       if (($4 | 0) != ($1 | 0)) {
        continue
       }
       break;
      };
      break block1;
     }
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$5 - 4 >> 2];
     $16 = $4;
     $15 = HEAP32[$2 >> 2];
     $31 = $15 >> 31;
     $17 = HEAP32[$2 + 4 >> 2];
     $27 = $17 >> 31;
     $19 = HEAP32[$2 + 8 >> 2];
     $30 = $19 >> 31;
     $20 = HEAP32[$2 + 12 >> 2];
     $28 = $20 >> 31;
     $8 = HEAP32[$2 + 16 >> 2];
     $29 = $8 >> 31;
     $18 = HEAP32[$2 + 20 >> 2];
     $22 = $18 >> 31;
     $7 = HEAP32[$2 + 24 >> 2];
     $10 = $7 >> 31;
     $2 = HEAP32[$2 + 28 >> 2];
     $9 = $2 >> 31;
     $4 = 0;
     while (1) {
      $6 = $4 << 2;
      $12 = $6 + $5 | 0;
      $11 = HEAP32[$0 + $6 >> 2];
      $6 = HEAP32[$12 - 28 >> 2];
      $14 = __wasm_i64_mul($6, $6 >> 31, $7, $10);
      $6 = i64toi32_i32$HIGH_BITS;
      $13 = $14;
      $26 = HEAP32[$12 - 32 >> 2];
      $14 = __wasm_i64_mul($26, $26 >> 31, $2, $9);
      $26 = $13 + $14 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $14 >>> 0 > $26 >>> 0 ? $6 + 1 | 0 : $6;
      $14 = HEAP32[$12 - 24 >> 2];
      $14 = __wasm_i64_mul($14, $14 >> 31, $18, $22);
      $26 = $14 + $26 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $14 >>> 0 > $26 >>> 0 ? $6 + 1 | 0 : $6;
      $14 = HEAP32[$12 - 20 >> 2];
      $14 = __wasm_i64_mul($14, $14 >> 31, $8, $29);
      $26 = $14 + $26 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $14 >>> 0 > $26 >>> 0 ? $6 + 1 | 0 : $6;
      $14 = HEAP32[$12 - 16 >> 2];
      $14 = __wasm_i64_mul($14, $14 >> 31, $20, $28);
      $26 = $14 + $26 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $14 >>> 0 > $26 >>> 0 ? $6 + 1 | 0 : $6;
      $14 = HEAP32[$12 - 12 >> 2];
      $14 = __wasm_i64_mul($14, $14 >> 31, $19, $30);
      $26 = $14 + $26 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $14 >>> 0 > $26 >>> 0 ? $6 + 1 | 0 : $6;
      $14 = HEAP32[$12 - 8 >> 2];
      $14 = __wasm_i64_mul($14, $14 >> 31, $17, $27);
      $26 = $14 + $26 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $14 >>> 0 > $26 >>> 0 ? $6 + 1 | 0 : $6;
      $3 = __wasm_i64_mul($3, $3 >> 31, $15, $31);
      $14 = $3 + $26 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $3 >>> 0 > $14 >>> 0 ? $6 + 1 | 0 : $6;
      $3 = $14;
      $14 = $16 & 31;
      if (($16 & 63) >>> 0 >= 32) {
       $3 = $6 >> $14
      } else {
       $3 = ((1 << $14) - 1 & $6) << 32 - $14 | $3 >>> $14
      }
      $3 = $3 + $11 | 0;
      HEAP32[$12 >> 2] = $3;
      $4 = $4 + 1 | 0;
      if (($4 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($3 | 0) != 6) {
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$5 - 4 >> 2];
     $19 = $4;
     $20 = HEAP32[$2 >> 2];
     $10 = $20 >> 31;
     $8 = HEAP32[$2 + 4 >> 2];
     $9 = $8 >> 31;
     $18 = HEAP32[$2 + 8 >> 2];
     $12 = $18 >> 31;
     $7 = HEAP32[$2 + 12 >> 2];
     $11 = $7 >> 31;
     $2 = HEAP32[$2 + 16 >> 2];
     $14 = $2 >> 31;
     $4 = 0;
     while (1) {
      $6 = $4 << 2;
      $16 = $6 + $5 | 0;
      $15 = HEAP32[$0 + $6 >> 2];
      $6 = HEAP32[$16 - 16 >> 2];
      $17 = __wasm_i64_mul($6, $6 >> 31, $7, $11);
      $6 = i64toi32_i32$HIGH_BITS;
      $29 = $17;
      $22 = HEAP32[$16 - 20 >> 2];
      $17 = __wasm_i64_mul($22, $22 >> 31, $2, $14);
      $22 = $29 + $17 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $17 >>> 0 > $22 >>> 0 ? $6 + 1 | 0 : $6;
      $17 = HEAP32[$16 - 12 >> 2];
      $17 = __wasm_i64_mul($17, $17 >> 31, $18, $12);
      $22 = $17 + $22 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $17 >>> 0 > $22 >>> 0 ? $6 + 1 | 0 : $6;
      $17 = HEAP32[$16 - 8 >> 2];
      $17 = __wasm_i64_mul($17, $17 >> 31, $8, $9);
      $22 = $17 + $22 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $17 >>> 0 > $22 >>> 0 ? $6 + 1 | 0 : $6;
      $3 = __wasm_i64_mul($3, $3 >> 31, $20, $10);
      $17 = $3 + $22 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $3 >>> 0 > $17 >>> 0 ? $6 + 1 | 0 : $6;
      $3 = $17;
      $17 = $19 & 31;
      if (($19 & 63) >>> 0 >= 32) {
       $3 = $6 >> $17
      } else {
       $3 = ((1 << $17) - 1 & $6) << 32 - $17 | $3 >>> $17
      }
      $3 = $3 + $15 | 0;
      HEAP32[$16 >> 2] = $3;
      $4 = $4 + 1 | 0;
      if (($4 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($1 | 0) <= 0) {
     break block1
    }
    $3 = HEAP32[$5 - 4 >> 2];
    $17 = $4;
    $19 = HEAP32[$2 >> 2];
    $29 = $19 >> 31;
    $20 = HEAP32[$2 + 4 >> 2];
    $22 = $20 >> 31;
    $8 = HEAP32[$2 + 8 >> 2];
    $10 = $8 >> 31;
    $18 = HEAP32[$2 + 12 >> 2];
    $9 = $18 >> 31;
    $7 = HEAP32[$2 + 16 >> 2];
    $12 = $7 >> 31;
    $2 = HEAP32[$2 + 20 >> 2];
    $11 = $2 >> 31;
    $4 = 0;
    while (1) {
     $6 = $4 << 2;
     $14 = $6 + $5 | 0;
     $16 = HEAP32[$0 + $6 >> 2];
     $6 = HEAP32[$14 - 20 >> 2];
     $15 = __wasm_i64_mul($6, $6 >> 31, $7, $12);
     $6 = i64toi32_i32$HIGH_BITS;
     $13 = $15;
     $28 = HEAP32[$14 - 24 >> 2];
     $15 = __wasm_i64_mul($28, $28 >> 31, $2, $11);
     $28 = $13 + $15 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $15 >>> 0 > $28 >>> 0 ? $6 + 1 | 0 : $6;
     $15 = HEAP32[$14 - 16 >> 2];
     $15 = __wasm_i64_mul($15, $15 >> 31, $18, $9);
     $28 = $15 + $28 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $15 >>> 0 > $28 >>> 0 ? $6 + 1 | 0 : $6;
     $15 = HEAP32[$14 - 12 >> 2];
     $15 = __wasm_i64_mul($15, $15 >> 31, $8, $10);
     $28 = $15 + $28 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $15 >>> 0 > $28 >>> 0 ? $6 + 1 | 0 : $6;
     $15 = HEAP32[$14 - 8 >> 2];
     $15 = __wasm_i64_mul($15, $15 >> 31, $20, $22);
     $28 = $15 + $28 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $15 >>> 0 > $28 >>> 0 ? $6 + 1 | 0 : $6;
     $3 = __wasm_i64_mul($3, $3 >> 31, $19, $29);
     $15 = $3 + $28 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $3 >>> 0 > $15 >>> 0 ? $6 + 1 | 0 : $6;
     $3 = $15;
     $15 = $17 & 31;
     if (($17 & 63) >>> 0 >= 32) {
      $3 = $6 >> $15
     } else {
      $3 = ((1 << $15) - 1 & $6) << 32 - $15 | $3 >>> $15
     }
     $3 = $3 + $16 | 0;
     HEAP32[$14 >> 2] = $3;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if ($3 >>> 0 >= 3) {
    if (($3 | 0) != 4) {
     if (($1 | 0) <= 0) {
      break block1
     }
     $3 = HEAP32[$5 - 4 >> 2];
     $8 = $4;
     $18 = HEAP32[$2 >> 2];
     $14 = $18 >> 31;
     $7 = HEAP32[$2 + 4 >> 2];
     $16 = $7 >> 31;
     $4 = HEAP32[$2 + 8 >> 2];
     $15 = $4 >> 31;
     $2 = 0;
     while (1) {
      $6 = $2 << 2;
      $17 = $6 + $5 | 0;
      $19 = HEAP32[$0 + $6 >> 2];
      $6 = HEAP32[$17 - 8 >> 2];
      $20 = __wasm_i64_mul($6, $6 >> 31, $7, $16);
      $6 = i64toi32_i32$HIGH_BITS;
      $9 = $20;
      $11 = HEAP32[$17 - 12 >> 2];
      $20 = __wasm_i64_mul($11, $11 >> 31, $4, $15);
      $11 = $9 + $20 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $11 >>> 0 < $20 >>> 0 ? $6 + 1 | 0 : $6;
      $3 = __wasm_i64_mul($3, $3 >> 31, $18, $14);
      $20 = $3 + $11 | 0;
      $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
      $6 = $3 >>> 0 > $20 >>> 0 ? $6 + 1 | 0 : $6;
      $3 = $20;
      $20 = $8 & 31;
      if (($8 & 63) >>> 0 >= 32) {
       $3 = $6 >> $20
      } else {
       $3 = ((1 << $20) - 1 & $6) << 32 - $20 | $3 >>> $20
      }
      $3 = $3 + $19 | 0;
      HEAP32[$17 >> 2] = $3;
      $2 = $2 + 1 | 0;
      if (($2 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
     break block1;
    }
    if (($1 | 0) <= 0) {
     break block1
    }
    $3 = HEAP32[$5 - 4 >> 2];
    $20 = $4;
    $8 = HEAP32[$2 >> 2];
    $12 = $8 >> 31;
    $18 = HEAP32[$2 + 4 >> 2];
    $11 = $18 >> 31;
    $7 = HEAP32[$2 + 8 >> 2];
    $14 = $7 >> 31;
    $2 = HEAP32[$2 + 12 >> 2];
    $16 = $2 >> 31;
    $4 = 0;
    while (1) {
     $6 = $4 << 2;
     $15 = $6 + $5 | 0;
     $17 = HEAP32[$0 + $6 >> 2];
     $6 = HEAP32[$15 - 12 >> 2];
     $19 = __wasm_i64_mul($6, $6 >> 31, $7, $14);
     $6 = i64toi32_i32$HIGH_BITS;
     $10 = $19;
     $9 = HEAP32[$15 - 16 >> 2];
     $19 = __wasm_i64_mul($9, $9 >> 31, $2, $16);
     $9 = $10 + $19 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $9 >>> 0 < $19 >>> 0 ? $6 + 1 | 0 : $6;
     $19 = HEAP32[$15 - 8 >> 2];
     $19 = __wasm_i64_mul($19, $19 >> 31, $18, $11);
     $9 = $19 + $9 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $9 >>> 0 < $19 >>> 0 ? $6 + 1 | 0 : $6;
     $3 = __wasm_i64_mul($3, $3 >> 31, $8, $12);
     $19 = $3 + $9 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $3 >>> 0 > $19 >>> 0 ? $6 + 1 | 0 : $6;
     $3 = $19;
     $19 = $20 & 31;
     if (($20 & 63) >>> 0 >= 32) {
      $3 = $6 >> $19
     } else {
      $3 = ((1 << $19) - 1 & $6) << 32 - $19 | $3 >>> $19
     }
     $3 = $3 + $17 | 0;
     HEAP32[$15 >> 2] = $3;
     $4 = $4 + 1 | 0;
     if (($4 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
    break block1;
   }
   if (($3 | 0) != 2) {
    if (($1 | 0) <= 0) {
     break block1
    }
    $20 = $1 & 1;
    $3 = HEAP32[$5 - 4 >> 2];
    $7 = $4;
    $4 = HEAP32[$2 >> 2];
    $17 = $4 >> 31;
    $2 = 0;
    if (($1 | 0) != 1) {
     $8 = $1 & 2147483646;
     $1 = 0;
     while (1) {
      $19 = $2 << 2;
      $18 = $19 + $5 | 0;
      $6 = HEAP32[$0 + $19 >> 2];
      $3 = __wasm_i64_mul($3, $3 >> 31, $4, $17);
      $15 = $18;
      $9 = $6;
      $6 = i64toi32_i32$HIGH_BITS;
      $18 = $7 & 31;
      if (($7 & 63) >>> 0 >= 32) {
       $3 = $6 >> $18
      } else {
       $3 = ((1 << $18) - 1 & $6) << 32 - $18 | $3 >>> $18
      }
      $3 = $9 + $3 | 0;
      HEAP32[$15 >> 2] = $3;
      $6 = $19 | 4;
      $18 = $6 + $5 | 0;
      $6 = HEAP32[$0 + $6 >> 2];
      $3 = __wasm_i64_mul($3, $3 >> 31, $4, $17);
      $15 = $18;
      $9 = $6;
      $6 = i64toi32_i32$HIGH_BITS;
      $18 = $7 & 31;
      if (($7 & 63) >>> 0 >= 32) {
       $3 = $6 >> $18
      } else {
       $3 = ((1 << $18) - 1 & $6) << 32 - $18 | $3 >>> $18
      }
      $3 = $9 + $3 | 0;
      HEAP32[$15 >> 2] = $3;
      $2 = $2 + 2 | 0;
      $1 = $1 + 2 | 0;
      if (($8 | 0) != ($1 | 0)) {
       continue
      }
      break;
     };
    }
    if (!$20) {
     break block1
    }
    $1 = $2 << 2;
    $2 = $1 + $5 | 0;
    $1 = HEAP32[$0 + $1 >> 2];
    $0 = __wasm_i64_mul($3, $3 >> 31, $4, $17);
    $3 = $2;
    $4 = $1;
    $1 = i64toi32_i32$HIGH_BITS;
    $2 = $7 & 31;
    if (($7 & 63) >>> 0 >= 32) {
     $0 = $1 >> $2
    } else {
     $0 = ((1 << $2) - 1 & $1) << 32 - $2 | $0 >>> $2
    }
    HEAP32[$3 >> 2] = $4 + $0;
    return;
   }
   if (($1 | 0) <= 0) {
    break block1
   }
   $17 = $1 & 1;
   $3 = HEAP32[$5 - 4 >> 2];
   $18 = $4;
   $7 = HEAP32[$2 >> 2];
   $11 = $7 >> 31;
   $4 = HEAP32[$2 + 4 >> 2];
   $14 = $4 >> 31;
   $2 = 0;
   if (($1 | 0) != 1) {
    $19 = $1 & 2147483646;
    $1 = 0;
    while (1) {
     $16 = $2 << 2;
     $20 = $16 + $5 | 0;
     $8 = HEAP32[$0 + $16 >> 2];
     $3 = __wasm_i64_mul($3, $3 >> 31, $7, $11);
     $6 = i64toi32_i32$HIGH_BITS;
     $9 = $3;
     $15 = HEAP32[$20 - 8 >> 2];
     $3 = __wasm_i64_mul($15, $15 >> 31, $4, $14);
     $15 = $9 + $3 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $3 >>> 0 > $15 >>> 0 ? $6 + 1 | 0 : $6;
     $9 = $8;
     $3 = $15;
     $8 = $18 & 31;
     if (($18 & 63) >>> 0 >= 32) {
      $3 = $6 >> $8
     } else {
      $3 = ((1 << $8) - 1 & $6) << 32 - $8 | $3 >>> $8
     }
     $3 = $9 + $3 | 0;
     HEAP32[$20 >> 2] = $3;
     $6 = $16 | 4;
     $20 = $6 + $5 | 0;
     $8 = HEAP32[$0 + $6 >> 2];
     $3 = __wasm_i64_mul($3, $3 >> 31, $7, $11);
     $6 = i64toi32_i32$HIGH_BITS;
     $9 = $3;
     $15 = HEAP32[$20 - 8 >> 2];
     $3 = __wasm_i64_mul($15, $15 >> 31, $4, $14);
     $15 = $9 + $3 | 0;
     $6 = i64toi32_i32$HIGH_BITS + $6 | 0;
     $6 = $3 >>> 0 > $15 >>> 0 ? $6 + 1 | 0 : $6;
     $9 = $8;
     $3 = $15;
     $8 = $18 & 31;
     if (($18 & 63) >>> 0 >= 32) {
      $3 = $6 >> $8
     } else {
      $3 = ((1 << $8) - 1 & $6) << 32 - $8 | $3 >>> $8
     }
     $3 = $9 + $3 | 0;
     HEAP32[$20 >> 2] = $3;
     $2 = $2 + 2 | 0;
     $1 = $1 + 2 | 0;
     if (($19 | 0) != ($1 | 0)) {
      continue
     }
     break;
    };
   }
   if (!$17) {
    break block1
   }
   $1 = $2 << 2;
   $5 = $1 + $5 | 0;
   $2 = HEAP32[$0 + $1 >> 2];
   $0 = __wasm_i64_mul($3, $3 >> 31, $7, $11);
   $1 = i64toi32_i32$HIGH_BITS;
   $6 = $0;
   $3 = HEAP32[$5 - 8 >> 2];
   $0 = __wasm_i64_mul($3, $3 >> 31, $4, $14);
   $3 = $6 + $0 | 0;
   $6 = i64toi32_i32$HIGH_BITS + $1 | 0;
   $6 = $0 >>> 0 > $3 >>> 0 ? $6 + 1 | 0 : $6;
   $0 = $3;
   $1 = $18 & 31;
   if (($18 & 63) >>> 0 >= 32) {
    $0 = $6 >> $1
   } else {
    $0 = ((1 << $1) - 1 & $6) << 32 - $1 | $0 >>> $1
   }
   HEAP32[$5 >> 2] = $0 + $2;
  }
 }
 
 function strlen($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  block2 : {
   block : {
    $1 = $0;
    if (!($1 & 3)) {
     break block
    }
    if (!HEAPU8[$1 | 0]) {
     return 0
    }
    while (1) {
     $1 = $1 + 1 | 0;
     if (!($1 & 3)) {
      break block
     }
     if (HEAPU8[$1 | 0]) {
      continue
     }
     break;
    };
    break block2;
   }
   while (1) {
    $2 = $1;
    $1 = $1 + 4 | 0;
    $3 = HEAP32[$2 >> 2];
    if ((($3 | 16843008 - $3) & -2139062144) == -2139062144) {
     continue
    }
    break;
   };
   while (1) {
    $1 = $2;
    $2 = $1 + 1 | 0;
    if (HEAPU8[$1 | 0]) {
     continue
    }
    break;
   };
  }
  return $1 - $0 | 0;
 }
 
 function strchr($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  __inlined_func$__strchrnul$38 : {
   block2 : {
    block4 : {
     block3 : {
      $3 = $1 & 255;
      if ($3) {
       if ($0 & 3) {
        while (1) {
         $2 = HEAPU8[$0 | 0];
         if (!$2 | ($2 | 0) == ($3 | 0)) {
          break block2
         }
         $0 = $0 + 1 | 0;
         if ($0 & 3) {
          continue
         }
         break;
        }
       }
       $2 = HEAP32[$0 >> 2];
       if ((($2 | 16843008 - $2) & -2139062144) != -2139062144) {
        break block3
       }
       $4 = Math_imul($3, 16843009);
       while (1) {
        $3 = $2 ^ $4;
        if (((16843008 - $3 | $3) & -2139062144) != -2139062144) {
         break block3
        }
        $2 = HEAP32[$0 + 4 >> 2];
        $3 = $0 + 4 | 0;
        $0 = $3;
        if (((16843008 - $2 | $2) & -2139062144) == -2139062144) {
         continue
        }
        break;
       };
       break block4;
      }
      $0 = strlen($0) + $0 | 0;
      break __inlined_func$__strchrnul$38;
     }
     $3 = $0;
    }
    while (1) {
     $0 = $3;
     $2 = HEAPU8[$0 | 0];
     if (!$2) {
      break block2
     }
     $3 = $0 + 1 | 0;
     if (($2 | 0) != ($1 & 255)) {
      continue
     }
     break;
    };
   }
  }
  return HEAPU8[$0 | 0] == ($1 & 255) ? $0 : 0;
 }
 
 function __stdio_write($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  $3 = __stack_pointer - 32 | 0;
  __stack_pointer = $3;
  $4 = HEAP32[$0 + 28 >> 2];
  HEAP32[$3 + 16 >> 2] = $4;
  $5 = HEAP32[$0 + 20 >> 2];
  HEAP32[$3 + 28 >> 2] = $2;
  HEAP32[$3 + 24 >> 2] = $1;
  $1 = $5 - $4 | 0;
  HEAP32[$3 + 20 >> 2] = $1;
  $5 = $1 + $2 | 0;
  $1 = $3 + 16 | 0;
  $8 = 2;
  block5 : {
   block4 : {
    block2 : {
     block1 : {
      if (__wasi_syscall_ret(__wasi_fd_write(HEAP32[$0 + 60 >> 2], $1 | 0, 2, $3 + 12 | 0) | 0)) {
       $4 = $1;
       break block1;
      }
      while (1) {
       $6 = HEAP32[$3 + 12 >> 2];
       if (($6 | 0) == ($5 | 0)) {
        break block2
       }
       if (($6 | 0) < 0) {
        $4 = $1;
        break block4;
       }
       $7 = HEAP32[$1 + 4 >> 2];
       $9 = $7 >>> 0 < $6 >>> 0;
       $4 = ($9 << 3) + $1 | 0;
       $7 = $6 - ($9 ? $7 : 0) | 0;
       HEAP32[$4 >> 2] = $7 + HEAP32[$4 >> 2];
       $1 = ($9 ? 12 : 4) + $1 | 0;
       HEAP32[$1 >> 2] = HEAP32[$1 >> 2] - $7;
       $5 = $5 - $6 | 0;
       $1 = $4;
       $8 = $8 - $9 | 0;
       if (!__wasi_syscall_ret(__wasi_fd_write(HEAP32[$0 + 60 >> 2], $1 | 0, $8 | 0, $3 + 12 | 0) | 0)) {
        continue
       }
       break;
      };
     }
     if (($5 | 0) != -1) {
      break block4
     }
    }
    $1 = HEAP32[$0 + 44 >> 2];
    HEAP32[$0 + 28 >> 2] = $1;
    HEAP32[$0 + 20 >> 2] = $1;
    HEAP32[$0 + 16 >> 2] = $1 + HEAP32[$0 + 48 >> 2];
    $1 = $2;
    break block5;
   }
   HEAP32[$0 + 28 >> 2] = 0;
   HEAP32[$0 + 16 >> 2] = 0;
   HEAP32[$0 + 20 >> 2] = 0;
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | 32;
   $1 = 0;
   if (($8 | 0) == 2) {
    break block5
   }
   $1 = $2 - HEAP32[$4 + 4 >> 2] | 0;
  }
  __stack_pointer = $3 + 32 | 0;
  return $1 | 0;
 }
 
 function FLAC__memory_alloc_aligned_int32_array($0, $1, $2) {
  var $3 = 0;
  block : {
   if ($0 >>> 0 > 1073741823) {
    break block
   }
   $0 = $0 << 2;
   $0 = emscripten_builtin_malloc($0 >>> 0 <= 1 ? 1 : $0);
   if (!$0) {
    break block
   }
   $3 = HEAP32[$1 >> 2];
   if ($3) {
    emscripten_builtin_free($3)
   }
   HEAP32[$1 >> 2] = $0;
   HEAP32[$2 >> 2] = $0;
   $3 = 1;
  }
  return $3;
 }
 
 function safe_malloc_mul_2op_p($0, $1) {
  var $2 = 0;
  $2 = 1;
  block1 : {
   if (!(!$0 | !$1)) {
    __wasm_i64_mul($1, 0, $0, 0);
    $2 = 0;
    if (i64toi32_i32$HIGH_BITS) {
     break block1
    }
    $2 = Math_imul($0, $1);
   }
   $2 = emscripten_builtin_malloc($2);
  }
  return $2;
 }
 
 function FLAC__fixed_compute_best_predictor($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = Math_fround(0), $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = Math_fround(0), $17 = 0, $18 = 0, wasm2js_i32$0 = 0, wasm2js_f32$0 = Math_fround(0);
  if ($1) {
   $3 = HEAP32[$0 - 4 >> 2];
   $7 = HEAP32[$0 - 8 >> 2];
   $12 = $3 - $7 | 0;
   $4 = HEAP32[$0 - 12 >> 2];
   $8 = $12 + ($4 - $7 | 0) | 0;
   $18 = $8 + (($4 << 1) - ($7 + HEAP32[$0 - 16 >> 2] | 0) | 0) | 0;
   while (1) {
    $7 = HEAP32[($17 << 2) + $0 >> 2];
    $4 = $7 >> 31;
    $14 = (($4 ^ $7) - $4 | 0) + $14 | 0;
    $4 = $7 - $3 | 0;
    $11 = $4 >> 31;
    $13 = (($4 ^ $11) - $11 | 0) + $13 | 0;
    $11 = $4 - $12 | 0;
    $3 = $11 >> 31;
    $9 = (($3 ^ $11) - $3 | 0) + $9 | 0;
    $8 = $11 - $8 | 0;
    $3 = $8 >> 31;
    $5 = (($3 ^ $8) - $3 | 0) + $5 | 0;
    $12 = $8 - $18 | 0;
    $3 = $12 >> 31;
    $6 = (($3 ^ $12) - $3 | 0) + $6 | 0;
    $3 = $7;
    $12 = $4;
    $18 = $8;
    $8 = $11;
    $17 = $17 + 1 | 0;
    if (($17 | 0) != ($1 | 0)) {
     continue
    }
    break;
   };
  }
  $0 = $9 >>> 0 > $13 >>> 0 ? $13 : $9;
  $0 = $0 >>> 0 < $5 >>> 0 ? $0 : $5;
  block1 : {
   if (($0 >>> 0 < $6 >>> 0 ? $0 : $6) >>> 0 > $14 >>> 0) {
    break block1
   }
   $0 = $5 >>> 0 > $9 >>> 0 ? $9 : $5;
   if ($13 >>> 0 < ($0 >>> 0 < $6 >>> 0 ? $0 : $6) >>> 0) {
    $15 = 1;
    break block1;
   }
   $0 = $5 >>> 0 < $6 >>> 0;
   if ($9 >>> 0 < ($0 ? $5 : $6) >>> 0) {
    $15 = 2;
    break block1;
   }
   $15 = $0 ? 3 : 4;
  }
  if ($14) {
   $10 = Math_fround(log(+($14 >>> 0) * .6931471805599453 / +($1 >>> 0)) / .6931471805599453)
  } else {
   $10 = $16
  }
  HEAPF32[$2 >> 2] = $10;
  if ($13) {
   $10 = Math_fround(log(+($13 >>> 0) * .6931471805599453 / +($1 >>> 0)) / .6931471805599453)
  } else {
   $10 = $16
  }
  HEAPF32[$2 + 4 >> 2] = $10;
  if ($9) {
   $10 = Math_fround(log(+($9 >>> 0) * .6931471805599453 / +($1 >>> 0)) / .6931471805599453)
  } else {
   $10 = $16
  }
  HEAPF32[$2 + 8 >> 2] = $10;
  if ($5) {
   $16 = Math_fround(log(+($5 >>> 0) * .6931471805599453 / +($1 >>> 0)) / .6931471805599453)
  }
  HEAPF32[$2 + 12 >> 2] = $16;
  if (!$6) {
   HEAPF32[$2 + 16 >> 2] = 0;
   return $15 | 0;
  }
  (wasm2js_i32$0 = $2, wasm2js_f32$0 = Math_fround(log(+($6 >>> 0) * .6931471805599453 / +($1 >>> 0)) / .6931471805599453)), HEAPF32[wasm2js_i32$0 + 16 >> 2] = wasm2js_f32$0;
  return $15 | 0;
 }
 
 function FLAC__fixed_compute_best_predictor_wide($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = Math_fround(0), $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = Math_fround(0), $21 = 0, $22 = 0, wasm2js_i32$0 = 0, wasm2js_f32$0 = Math_fround(0);
  block1 : {
   if (!$1) {
    break block1
   }
   $4 = HEAP32[$0 - 4 >> 2];
   $6 = HEAP32[$0 - 8 >> 2];
   $17 = $4 - $6 | 0;
   $8 = HEAP32[$0 - 12 >> 2];
   $7 = $17 + ($8 - $6 | 0) | 0;
   $22 = $7 + (($8 << 1) - ($6 + HEAP32[$0 - 16 >> 2] | 0) | 0) | 0;
   $8 = 0;
   $6 = 0;
   while (1) {
    $3 = HEAP32[($21 << 2) + $0 >> 2];
    $5 = $3 >> 31;
    $5 = ($3 ^ $5) - $5 | 0;
    $19 = $5 + $19 | 0;
    $18 = $5 >>> 0 > $19 >>> 0 ? $18 + 1 | 0 : $18;
    $5 = $3 - $4 | 0;
    $10 = $5 >> 31;
    $10 = ($5 ^ $10) - $10 | 0;
    $16 = $16 + $10 | 0;
    $13 = $10 >>> 0 > $16 >>> 0 ? $13 + 1 | 0 : $13;
    $10 = $5 - $17 | 0;
    $4 = $10 >> 31;
    $4 = ($4 ^ $10) - $4 | 0;
    $14 = $4 + $14 | 0;
    $9 = $4 >>> 0 > $14 >>> 0 ? $9 + 1 | 0 : $9;
    $7 = $10 - $7 | 0;
    $4 = $7 >> 31;
    $4 = ($4 ^ $7) - $4 | 0;
    $11 = $4 + $11 | 0;
    $6 = $4 >>> 0 > $11 >>> 0 ? $6 + 1 | 0 : $6;
    $17 = $7 - $22 | 0;
    $4 = $17 >> 31;
    $4 = ($4 ^ $17) - $4 | 0;
    $12 = $4 + $12 | 0;
    $8 = $4 >>> 0 > $12 >>> 0 ? $8 + 1 | 0 : $8;
    $4 = $3;
    $17 = $5;
    $22 = $7;
    $7 = $10;
    $21 = $21 + 1 | 0;
    if (($21 | 0) != ($1 | 0)) {
     continue
    }
    break;
   };
  }
  $3 = ($9 | 0) == ($13 | 0) & $14 >>> 0 > $16 >>> 0 | $9 >>> 0 > $13 >>> 0;
  $0 = $3 ? $16 : $14;
  $3 = $3 ? $13 : $9;
  $5 = ($6 | 0) == ($3 | 0) & $0 >>> 0 < $11 >>> 0 | $6 >>> 0 > $3 >>> 0;
  $0 = $5 ? $0 : $11;
  $7 = $0;
  $3 = $5 ? $3 : $6;
  $0 = ($8 | 0) == ($3 | 0) & $0 >>> 0 < $12 >>> 0 | $3 >>> 0 < $8 >>> 0;
  $5 = $0 ? $7 : $12;
  $0 = $0 ? $3 : $8;
  block3 : {
   if (!(($0 | 0) == ($18 | 0) & $5 >>> 0 <= $19 >>> 0 | $0 >>> 0 < $18 >>> 0)) {
    $7 = 0;
    break block3;
   }
   $3 = ($6 | 0) == ($9 | 0) & $11 >>> 0 > $14 >>> 0 | $6 >>> 0 > $9 >>> 0;
   $0 = $3 ? $14 : $11;
   $7 = $0;
   $3 = $3 ? $9 : $6;
   $0 = ($8 | 0) == ($3 | 0) & $0 >>> 0 < $12 >>> 0 | $3 >>> 0 < $8 >>> 0;
   $5 = $0 ? $7 : $12;
   $0 = $0 ? $3 : $8;
   if (!(($0 | 0) == ($13 | 0) & $5 >>> 0 <= $16 >>> 0 | $0 >>> 0 < $13 >>> 0)) {
    $7 = 1;
    break block3;
   }
   $0 = ($6 | 0) == ($8 | 0) & $11 >>> 0 < $12 >>> 0 | $6 >>> 0 < $8 >>> 0;
   $3 = $0 ? $11 : $12;
   $5 = $0 ? $6 : $8;
   $7 = 2;
   if (!(($5 | 0) == ($9 | 0) & $3 >>> 0 <= $14 >>> 0 | $5 >>> 0 < $9 >>> 0)) {
    break block3
   }
   $7 = $0 ? 3 : 4;
  }
  $0 = $7;
  if ($18 | $19) {
   $15 = Math_fround(log((+($19 >>> 0) + +($18 >>> 0) * 4294967296.0) * .6931471805599453 / +($1 >>> 0)) / .6931471805599453)
  } else {
   $15 = $20
  }
  HEAPF32[$2 >> 2] = $15;
  if ($13 | $16) {
   $15 = Math_fround(log((+($16 >>> 0) + +($13 >>> 0) * 4294967296.0) * .6931471805599453 / +($1 >>> 0)) / .6931471805599453)
  } else {
   $15 = $20
  }
  HEAPF32[$2 + 4 >> 2] = $15;
  if ($9 | $14) {
   $15 = Math_fround(log((+($14 >>> 0) + +($9 >>> 0) * 4294967296.0) * .6931471805599453 / +($1 >>> 0)) / .6931471805599453)
  } else {
   $15 = $20
  }
  HEAPF32[$2 + 8 >> 2] = $15;
  if ($6 | $11) {
   $20 = Math_fround(log((+($11 >>> 0) + +($6 >>> 0) * 4294967296.0) * .6931471805599453 / +($1 >>> 0)) / .6931471805599453)
  }
  HEAPF32[$2 + 12 >> 2] = $20;
  if (!($8 | $12)) {
   HEAPF32[$2 + 16 >> 2] = 0;
   return $0 | 0;
  }
  (wasm2js_i32$0 = $2, wasm2js_f32$0 = Math_fround(log((+($12 >>> 0) + +($8 >>> 0) * 4294967296.0) * .6931471805599453 / +($1 >>> 0)) / .6931471805599453)), HEAPF32[wasm2js_i32$0 + 16 >> 2] = wasm2js_f32$0;
  return $0 | 0;
 }
 
 function FLAC__stream_decoder_new() {
  var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0;
  $3 = emscripten_builtin_calloc(1, 8);
  if ($3) {
   $2 = emscripten_builtin_calloc(1, 504);
   HEAP32[$3 >> 2] = $2;
   if ($2) {
    $0 = emscripten_builtin_calloc(1, 6160);
    HEAP32[$3 + 4 >> 2] = $0;
    if ($0) {
     $1 = emscripten_builtin_calloc(1, 44);
     HEAP32[$0 + 56 >> 2] = $1;
     if ($1) {
      HEAP32[$0 + 1128 >> 2] = 16;
      $4 = emscripten_builtin_malloc(HEAP32[1641] << 1 & -16);
      HEAP32[$0 + 1120 >> 2] = $4;
      if ($4) {
       HEAP32[$0 + 3592 >> 2] = 0;
       HEAP32[$0 + 3596 >> 2] = 0;
       HEAP32[$0 + 252 >> 2] = 0;
       HEAP32[$0 + 220 >> 2] = 0;
       HEAP32[$0 + 224 >> 2] = 0;
       HEAP32[$0 + 60 >> 2] = 0;
       HEAP32[$0 + 64 >> 2] = 0;
       $1 = $0 + 3616 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       $1 = $0 + 3608 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       $1 = $0 + 3600 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       $1 = $0 + 68 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       $1 = $0 + 76 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       $1 = $0 + 84 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       $1 = $0 + 92 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       $1 = $0 + 100 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       $1 = $0 + 108 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       $1 = $0 + 116 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       FLAC__format_entropy_coding_method_partitioned_rice_contents_init($0 + 124 | 0);
       FLAC__format_entropy_coding_method_partitioned_rice_contents_init($0 + 136 | 0);
       FLAC__format_entropy_coding_method_partitioned_rice_contents_init($0 + 148 | 0);
       FLAC__format_entropy_coding_method_partitioned_rice_contents_init($0 + 160 | 0);
       FLAC__format_entropy_coding_method_partitioned_rice_contents_init($0 + 172 | 0);
       FLAC__format_entropy_coding_method_partitioned_rice_contents_init($0 + 184 | 0);
       FLAC__format_entropy_coding_method_partitioned_rice_contents_init($0 + 196 | 0);
       FLAC__format_entropy_coding_method_partitioned_rice_contents_init($0 + 208 | 0);
       HEAP32[$0 + 48 >> 2] = 0;
       HEAP32[$0 + 52 >> 2] = 0;
       wasm2js_memory_fill($0 + 608 | 0, 0, 512);
       HEAP32[$0 + 32 >> 2] = 0;
       $1 = $0 + 24 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       $1 = $0 + 16 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       $1 = $0 + 8 | 0;
       HEAP32[$1 >> 2] = 0;
       HEAP32[$1 + 4 >> 2] = 0;
       HEAP32[$0 >> 2] = 0;
       HEAP32[$0 + 4 >> 2] = 0;
       HEAP32[$0 + 1124 >> 2] = 0;
       HEAP32[$0 + 608 >> 2] = 1;
       HEAP32[$2 + 28 >> 2] = 0;
       FLAC__ogg_decoder_aspect_set_defaults($2 + 32 | 0);
       HEAP32[$2 >> 2] = 9;
       return $3 | 0;
      }
      FLAC__bitreader_delete($1);
     }
     emscripten_builtin_free($0);
    }
    emscripten_builtin_free($2);
   }
   emscripten_builtin_free($3);
  }
  return 0;
 }
 
 function FLAC__stream_decoder_delete($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  if ($0) {
   FLAC__stream_decoder_finish($0);
   $1 = HEAP32[$0 + 4 >> 2];
   $2 = HEAP32[$1 + 1120 >> 2];
   if ($2) {
    emscripten_builtin_free($2);
    $1 = HEAP32[$0 + 4 >> 2];
   }
   FLAC__bitreader_delete(HEAP32[$1 + 56 >> 2]);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 124 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 136 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 148 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 160 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 172 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 184 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 196 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 208 | 0);
   emscripten_builtin_free(HEAP32[$0 + 4 >> 2]);
   emscripten_builtin_free(HEAP32[$0 >> 2]);
   emscripten_builtin_free($0);
  }
 }
 
 function FLAC__stream_decoder_finish($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0;
  $2 = 1;
  if (HEAP32[HEAP32[$0 >> 2] >> 2] != 9) {
   $1 = HEAP32[$0 + 4 >> 2];
   FLAC__MD5Final($1 + 3732 | 0, $1 + 3636 | 0);
   emscripten_builtin_free(HEAP32[HEAP32[$0 + 4 >> 2] + 452 >> 2]);
   HEAP32[HEAP32[$0 + 4 >> 2] + 452 >> 2] = 0;
   $1 = HEAP32[$0 + 4 >> 2];
   HEAP32[$1 + 252 >> 2] = 0;
   $1 = HEAP32[$1 + 56 >> 2];
   $2 = HEAP32[$1 >> 2];
   if ($2) {
    emscripten_builtin_free($2)
   }
   HEAP32[$1 >> 2] = 0;
   HEAP32[$1 + 4 >> 2] = 0;
   HEAP32[$1 + 36 >> 2] = 0;
   HEAP32[$1 + 40 >> 2] = 0;
   $2 = $1 + 8 | 0;
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 4 >> 2] = 0;
   $1 = $1 + 16 | 0;
   HEAP32[$1 >> 2] = 0;
   HEAP32[$1 + 4 >> 2] = 0;
   $1 = HEAP32[$0 + 4 >> 2];
   $2 = HEAP32[$1 + 60 >> 2];
   if ($2) {
    emscripten_builtin_free($2 - 16 | 0);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 60 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 3592 >> 2];
   if ($2) {
    emscripten_builtin_free($2);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 3592 >> 2] = 0;
    HEAP32[$1 + 92 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 64 >> 2];
   if ($2) {
    emscripten_builtin_free($2 - 16 | 0);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 64 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 3596 >> 2];
   if ($2) {
    emscripten_builtin_free($2);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 3596 >> 2] = 0;
    HEAP32[$1 + 96 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 68 >> 2];
   if ($2) {
    emscripten_builtin_free($2 - 16 | 0);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 68 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 3600 >> 2];
   if ($2) {
    emscripten_builtin_free($2);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 3600 >> 2] = 0;
    HEAP32[$1 + 100 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 72 >> 2];
   if ($2) {
    emscripten_builtin_free($2 - 16 | 0);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 72 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 3604 >> 2];
   if ($2) {
    emscripten_builtin_free($2);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 3604 >> 2] = 0;
    HEAP32[$1 + 104 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 76 >> 2];
   if ($2) {
    emscripten_builtin_free($2 - 16 | 0);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 76 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 3608 >> 2];
   if ($2) {
    emscripten_builtin_free($2);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 3608 >> 2] = 0;
    HEAP32[$1 + 108 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 80 >> 2];
   if ($2) {
    emscripten_builtin_free($2 - 16 | 0);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 80 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 3612 >> 2];
   if ($2) {
    emscripten_builtin_free($2);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 3612 >> 2] = 0;
    HEAP32[$1 + 112 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 84 >> 2];
   if ($2) {
    emscripten_builtin_free($2 - 16 | 0);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 84 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 3616 >> 2];
   if ($2) {
    emscripten_builtin_free($2);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 3616 >> 2] = 0;
    HEAP32[$1 + 116 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 88 >> 2];
   if ($2) {
    emscripten_builtin_free($2 - 16 | 0);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 88 >> 2] = 0;
   }
   $2 = HEAP32[$1 + 3620 >> 2];
   if ($2) {
    emscripten_builtin_free($2);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 3620 >> 2] = 0;
    HEAP32[$1 + 120 >> 2] = 0;
   }
   HEAP32[$1 + 220 >> 2] = 0;
   HEAP32[$1 + 224 >> 2] = 0;
   if (HEAP32[$1 >> 2]) {
    $2 = HEAP32[$0 >> 2] + 32 | 0;
    $1 = $2 + 368 | 0;
    if ($1) {
     $3 = HEAP32[$1 >> 2];
     if ($3) {
      emscripten_builtin_free($3)
     }
     HEAP32[$1 >> 2] = 0;
     HEAP32[$1 + 4 >> 2] = 0;
     HEAP32[$1 + 24 >> 2] = 0;
     $3 = $1 + 16 | 0;
     HEAP32[$3 >> 2] = 0;
     HEAP32[$3 + 4 >> 2] = 0;
     $1 = $1 + 8 | 0;
     HEAP32[$1 >> 2] = 0;
     HEAP32[$1 + 4 >> 2] = 0;
    }
    ogg_stream_clear($2 + 8 | 0);
    $1 = HEAP32[$0 + 4 >> 2];
   }
   $2 = HEAP32[$1 + 52 >> 2];
   if ($2) {
    if (HEAP32[1958] != ($2 | 0)) {
     fclose($2);
     $1 = HEAP32[$0 + 4 >> 2];
    }
    HEAP32[$1 + 52 >> 2] = 0;
   }
   if (HEAP32[$1 + 3624 >> 2]) {
    $2 = memcmp($1 + 312 | 0, $1 + 3732 | 0, 16)
   } else {
    $2 = 0
   }
   $2 = !$2;
   HEAP32[$1 + 48 >> 2] = 0;
   HEAP32[$1 + 3632 >> 2] = 0;
   wasm2js_memory_fill($1 + 608 | 0, 0, 512);
   HEAP32[$1 + 32 >> 2] = 0;
   $3 = $1 + 24 | 0;
   HEAP32[$3 >> 2] = 0;
   HEAP32[$3 + 4 >> 2] = 0;
   $3 = $1 + 16 | 0;
   HEAP32[$3 >> 2] = 0;
   HEAP32[$3 + 4 >> 2] = 0;
   $3 = $1 + 8 | 0;
   HEAP32[$3 >> 2] = 0;
   HEAP32[$3 + 4 >> 2] = 0;
   HEAP32[$1 >> 2] = 0;
   HEAP32[$1 + 4 >> 2] = 0;
   $1 = HEAP32[$0 + 4 >> 2];
   HEAP32[$1 + 1124 >> 2] = 0;
   HEAP32[$1 + 608 >> 2] = 1;
   $1 = HEAP32[$0 >> 2];
   HEAP32[$1 + 28 >> 2] = 0;
   FLAC__ogg_decoder_aspect_set_defaults($1 + 32 | 0);
   HEAP32[HEAP32[$0 >> 2] >> 2] = 9;
  }
  return $2 | 0;
 }
 
 function FLAC__stream_decoder_init_stream($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  $6 = $6 | 0;
  $7 = $7 | 0;
  $8 = $8 | 0;
  $9 = $9 | 0;
  return init_stream_internal_($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, 0) | 0;
 }
 
 function init_stream_internal_($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
  var $11 = 0, $12 = 0;
  block3 : {
   $12 = HEAP32[$0 >> 2];
   $11 = 5;
   block : {
    if (HEAP32[$12 >> 2] != 9) {
     break block
    }
    $11 = 2;
    if (!$8 | (!$1 | !$6) | (!$5 | (!$3 | !$4) ? $2 : 0)) {
     break block
    }
    $11 = HEAP32[$0 + 4 >> 2];
    HEAP32[$11 >> 2] = $10;
    if ($10) {
     $11 = 0;
     $10 = $12 + 32 | 0;
     if (!ogg_stream_init($10 + 8 | 0, HEAP32[$10 + 4 >> 2])) {
      $11 = $10 + 368 | 0;
      if ($11) {
       HEAP32[$11 >> 2] = 0;
       HEAP32[$11 + 4 >> 2] = 0;
       HEAP32[$11 + 24 >> 2] = 0;
       $12 = $11 + 16 | 0;
       HEAP32[$12 >> 2] = 0;
       HEAP32[$12 + 4 >> 2] = 0;
       $11 = $11 + 8 | 0;
       HEAP32[$11 >> 2] = 0;
       HEAP32[$11 + 4 >> 2] = 0;
      }
      HEAP32[$10 + 396 >> 2] = -1;
      HEAP32[$10 + 400 >> 2] = -1;
      HEAP32[$10 + 408 >> 2] = 0;
      HEAP32[$10 + 412 >> 2] = 0;
      HEAP32[$10 + 404 >> 2] = HEAP32[$10 >> 2];
      $11 = 1;
     }
     if (!$11) {
      break block3
     }
     $11 = HEAP32[$0 + 4 >> 2];
    }
    FLAC__cpu_info($11 + 3524 | 0);
    $10 = HEAP32[$0 + 4 >> 2];
    HEAP32[$10 + 44 >> 2] = 6;
    HEAP32[$10 + 40 >> 2] = 7;
    HEAP32[$10 + 36 >> 2] = 6;
    $10 = HEAP32[$10 + 56 >> 2];
    HEAP32[$10 + 8 >> 2] = 0;
    HEAP32[$10 + 12 >> 2] = 0;
    HEAP32[$10 + 4 >> 2] = 2048;
    $11 = $10 + 16 | 0;
    HEAP32[$11 >> 2] = 0;
    HEAP32[$11 + 4 >> 2] = 0;
    $11 = emscripten_builtin_malloc(8192);
    HEAP32[$10 >> 2] = $11;
    $12 = 0;
    __inlined_func$FLAC__bitreader_init$41 : {
     if (!$11) {
      break __inlined_func$FLAC__bitreader_init$41
     }
     HEAP32[$10 + 40 >> 2] = $0;
     HEAP32[$10 + 36 >> 2] = 8;
     $12 = 1;
    }
    if (!$12) {
     HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
     return 3;
    }
    $10 = HEAP32[$0 + 4 >> 2];
    HEAP32[$10 + 48 >> 2] = $9;
    HEAP32[$10 + 32 >> 2] = $8;
    HEAP32[$10 + 28 >> 2] = $7;
    HEAP32[$10 + 24 >> 2] = $6;
    HEAP32[$10 + 20 >> 2] = $5;
    HEAP32[$10 + 16 >> 2] = $4;
    HEAP32[$10 + 12 >> 2] = $3;
    HEAP32[$10 + 8 >> 2] = $2;
    HEAP32[$10 + 4 >> 2] = $1;
    HEAP32[$10 + 3520 >> 2] = 0;
    HEAP32[$10 + 248 >> 2] = 0;
    HEAP32[$10 + 240 >> 2] = 0;
    HEAP32[$10 + 244 >> 2] = 0;
    HEAP32[$10 + 228 >> 2] = 0;
    HEAP32[$10 + 232 >> 2] = 0;
    HEAP32[$10 + 3624 >> 2] = HEAP32[HEAP32[$0 >> 2] + 28 >> 2];
    HEAP32[$10 + 3628 >> 2] = 1;
    HEAP32[$10 + 3632 >> 2] = 0;
    $11 = FLAC__stream_decoder_reset($0) ? 0 : 3;
   }
   return $11;
  }
  HEAP32[HEAP32[$0 >> 2] + 4 >> 2] = 4;
  return 4;
 }
 
 function read_callback_($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0;
  block8 : {
   block1 : {
    block : {
     $4 = HEAP32[$2 + 4 >> 2];
     if (HEAP32[$4 >> 2]) {
      break block
     }
     $3 = HEAP32[$4 + 20 >> 2];
     if (!$3) {
      break block
     }
     if (!(FUNCTION_TABLE[$3 | 0]($2, HEAP32[$4 + 48 >> 2]) | 0)) {
      break block
     }
     HEAP32[$1 >> 2] = 0;
     $28 = 4;
     break block1;
    }
    $28 = 7;
    if (!HEAP32[$1 >> 2]) {
     break block1
    }
    $3 = HEAP32[$2 + 4 >> 2];
    if (!!HEAP32[$3 + 3632 >> 2] & HEAPU32[$3 + 6152 >> 2] > 20) {
     break block1
    }
    $31 = HEAP32[$3 + 48 >> 2];
    block6 : {
     block5 : {
      block4 : {
       if (HEAP32[$3 >> 2]) {
        $11 = HEAP32[$2 >> 2] + 32 | 0;
        $24 = $0;
        $0 = 0;
        $26 = __stack_pointer - 16 | 0;
        __stack_pointer = $26;
        $29 = HEAP32[$1 >> 2];
        HEAP32[$1 >> 2] = 0;
        block10 : {
         if ($29) {
          $22 = $11 + 416 | 0;
          $8 = $11 + 368 | 0;
          $6 = $11 + 8 | 0;
          $18 = $11 + 440 | 0;
          $30 = HEAP32[4306];
          $33 = HEAPU8[7824];
          while (1) {
           if (!HEAP32[$11 + 408 >> 2]) {
            block7 : {
             block11 : {
              if (HEAP32[$11 + 412 >> 2]) {
               if (HEAP32[$11 + 432 >> 2]) {
                $3 = HEAP32[$11 + 440 >> 2];
                $4 = HEAP32[$11 + 444 >> 2];
                $0 = $29 - $0 | 0;
                if ($4 >>> 0 <= $0 >>> 0) {
                 if ($4) {
                  wasm2js_memory_copy($24, $3, $4)
                 }
                 HEAP32[$1 >> 2] = $4 + HEAP32[$1 >> 2];
                 HEAP32[$11 + 432 >> 2] = 0;
                 $24 = $4 + $24 | 0;
                 break block7;
                }
                if ($0) {
                 wasm2js_memory_copy($24, $3, $0)
                }
                HEAP32[$1 >> 2] = $0 + HEAP32[$1 >> 2];
                HEAP32[$11 + 440 >> 2] = $0 + HEAP32[$11 + 440 >> 2];
                HEAP32[$11 + 444 >> 2] = HEAP32[$11 + 444 >> 2] - $0;
                $24 = $0 + $24 | 0;
                break block7;
               }
               $3 = 0;
               block0 : {
                if (!$6) {
                 break block0
                }
                $5 = HEAP32[$6 >> 2];
                if (!$5) {
                 break block0
                }
                $9 = HEAP32[$6 + 36 >> 2];
                if (($9 | 0) >= HEAP32[$6 + 32 >> 2]) {
                 break block0
                }
                $3 = -1;
                $4 = HEAP32[$6 + 16 >> 2];
                $13 = HEAP32[$4 + ($9 << 2) >> 2];
                if (!($13 & 1024)) {
                 $7 = $13 & 512;
                 $3 = 255;
                 $0 = $13 & 255;
                 block3 : {
                  if (($0 | 0) != 255) {
                   $3 = $0;
                   break block3;
                  }
                  while (1) {
                   $9 = $9 + 1 | 0;
                   $0 = HEAP32[($9 << 2) + $4 >> 2];
                   $7 = $0 & 512 ? 512 : $7;
                   $0 = $0 & 255;
                   $3 = $0 + $3 | 0;
                   if (($0 | 0) == 255) {
                    continue
                   }
                   break;
                  };
                 }
                 block51 : {
                  if (!$18) {
                   $7 = HEAP32[$6 + 12 >> 2];
                   break block51;
                  }
                  HEAP32[$18 + 8 >> 2] = $13 & 256;
                  HEAP32[$18 + 12 >> 2] = $7;
                  $7 = HEAP32[$6 + 12 >> 2];
                  HEAP32[$18 >> 2] = $7 + $5;
                  $0 = HEAP32[$6 + 348 >> 2];
                  HEAP32[$18 + 24 >> 2] = HEAP32[$6 + 344 >> 2];
                  HEAP32[$18 + 28 >> 2] = $0;
                  $0 = HEAP32[$6 + 20 >> 2] + ($9 << 3) | 0;
                  $4 = HEAP32[$0 >> 2];
                  $0 = HEAP32[$0 + 4 >> 2];
                  HEAP32[$18 + 4 >> 2] = $3;
                  HEAP32[$18 + 16 >> 2] = $4;
                  HEAP32[$18 + 20 >> 2] = $0;
                 }
                 HEAP32[$6 + 12 >> 2] = $3 + $7;
                 $3 = 1;
                }
                HEAP32[$6 + 36 >> 2] = $9 + 1;
                $0 = HEAP32[$6 + 348 >> 2];
                $4 = HEAP32[$6 + 344 >> 2] + 1 | 0;
                $0 = $4 ? $0 : $0 + 1 | 0;
                HEAP32[$6 + 344 >> 2] = $4;
                HEAP32[$6 + 348 >> 2] = $0;
               }
               if (($3 | 0) > 0) {
                HEAP32[$11 + 432 >> 2] = 1;
                $3 = HEAP32[$11 + 444 >> 2];
                if (($3 | 0) <= 0) {
                 break block7
                }
                $4 = HEAP32[$18 >> 2];
                if (HEAPU8[$4 | 0] != ($33 | 0)) {
                 break block7
                }
                $7 = 3;
                if ((HEAPU8[$4 + 1 | 0] | HEAPU8[$4 + 2 | 0] << 8 | (HEAPU8[$4 + 3 | 0] << 16 | HEAPU8[$4 + 4 | 0] << 24)) != (HEAPU8[$30 | 0] | HEAPU8[$30 + 1 | 0] << 8 | (HEAPU8[$30 + 2 | 0] << 16 | HEAPU8[$30 + 3 | 0] << 24)) | $3 >>> 0 < 9) {
                 break block10
                }
                $0 = HEAPU8[$4 + 5 | 0];
                HEAP32[$11 + 396 >> 2] = $0;
                HEAP32[$11 + 400 >> 2] = HEAPU8[$4 + 6 | 0];
                if (($0 | 0) == 1) {
                 break block11
                }
                $7 = 4;
                break block10;
               }
               $7 = 2;
               if ($3) {
                break block10
               }
               HEAP32[$11 + 412 >> 2] = 0;
               break block7;
              }
              if (HEAP32[$8 + 4 >> 2] >= 0) {
               __inlined_func$ogg_sync_pageout$19 : {
                while (1) {
                 $0 = 0;
                 $5 = 0;
                 $15 = __stack_pointer - 16 | 0;
                 __stack_pointer = $15;
                 block02 : {
                  if (HEAP32[$8 + 4 >> 2] < 0) {
                   break block02
                  }
                  $3 = HEAP32[$8 + 12 >> 2];
                  $16 = HEAP32[$8 + 8 >> 2] - $3 | 0;
                  $9 = HEAP32[$8 >> 2];
                  $10 = $3 + $9 | 0;
                  block101 : {
                   $7 = HEAP32[$8 + 20 >> 2];
                   block2 : {
                    if (!$7) {
                     if (($16 | 0) < 27) {
                      break block02
                     }
                     if ((HEAPU8[$10 | 0] | HEAPU8[$10 + 1 | 0] << 8 | (HEAPU8[$10 + 2 | 0] << 16 | HEAPU8[$10 + 3 | 0] << 24)) != 1399285583) {
                      break block2
                     }
                     $3 = HEAPU8[$10 + 26 | 0];
                     $7 = $3 + 27 | 0;
                     if ($7 >>> 0 > $16 >>> 0) {
                      break block02
                     }
                     if ($3) {
                      $3 = $10 + 27 | 0;
                      $9 = HEAP32[$8 + 24 >> 2];
                      while (1) {
                       $9 = HEAPU8[$3 + $5 | 0] + $9 | 0;
                       HEAP32[$8 + 24 >> 2] = $9;
                       $5 = $5 + 1 | 0;
                       if ($5 >>> 0 < HEAPU8[$10 + 26 | 0]) {
                        continue
                       }
                       break;
                      };
                     }
                     HEAP32[$8 + 20 >> 2] = $7;
                    }
                    if ((HEAP32[$8 + 24 >> 2] + $7 | 0) > ($16 | 0)) {
                     break block02
                    }
                    $14 = HEAPU8[$10 + 22 | 0] | HEAPU8[$10 + 23 | 0] << 8 | (HEAPU8[$10 + 24 | 0] << 16 | HEAPU8[$10 + 25 | 0] << 24);
                    HEAP32[$15 + 12 >> 2] = $14;
                    HEAP8[$10 + 22 | 0] = 0;
                    HEAP8[$10 + 23 | 0] = 0;
                    HEAP8[$10 + 24 | 0] = 0;
                    HEAP8[$10 + 25 | 0] = 0;
                    $19 = HEAP32[$8 + 24 >> 2];
                    $9 = HEAP32[$8 + 20 >> 2];
                    HEAP8[$10 + 22 | 0] = 0;
                    HEAP8[$10 + 23 | 0] = 0;
                    HEAP8[$10 + 24 | 0] = 0;
                    HEAP8[$10 + 25 | 0] = 0;
                    block43 : {
                     if (($9 | 0) <= 0) {
                      break block43
                     }
                     $13 = $9 & 1;
                     block64 : {
                      if (($9 | 0) == 1) {
                       $5 = 0;
                       break block64;
                      }
                      $4 = $9 & 2147483646;
                      $5 = 0;
                      $7 = 0;
                      while (1) {
                       $3 = $5 + $10 | 0;
                       $0 = HEAP32[((HEAPU8[$3 | 0] ^ $0 >>> 24) << 2) + 6800 >> 2] ^ $0 << 8;
                       $0 = HEAP32[(($0 >>> 24 ^ HEAPU8[$3 + 1 | 0]) << 2) + 6800 >> 2] ^ $0 << 8;
                       $5 = $5 + 2 | 0;
                       $7 = $7 + 2 | 0;
                       if (($4 | 0) != ($7 | 0)) {
                        continue
                       }
                       break;
                      };
                     }
                     if (!$13) {
                      break block43
                     }
                     $0 = HEAP32[((HEAPU8[$5 + $10 | 0] ^ $0 >>> 24) << 2) + 6800 >> 2] ^ $0 << 8;
                    }
                    $20 = $10 + 22 | 0;
                    block74 : {
                     if (($19 | 0) <= 0) {
                      break block74
                     }
                     $9 = $9 + $10 | 0;
                     $13 = $19 & 1;
                     block9 : {
                      if (($19 | 0) == 1) {
                       $5 = 0;
                       break block9;
                      }
                      $4 = $19 & 2147483646;
                      $5 = 0;
                      $7 = 0;
                      while (1) {
                       $3 = $5 + $9 | 0;
                       $0 = HEAP32[((HEAPU8[$3 | 0] ^ $0 >>> 24) << 2) + 6800 >> 2] ^ $0 << 8;
                       $0 = HEAP32[(($0 >>> 24 ^ HEAPU8[$3 + 1 | 0]) << 2) + 6800 >> 2] ^ $0 << 8;
                       $5 = $5 + 2 | 0;
                       $7 = $7 + 2 | 0;
                       if (($4 | 0) != ($7 | 0)) {
                        continue
                       }
                       break;
                      };
                     }
                     if (!$13) {
                      break block74
                     }
                     $0 = HEAP32[((HEAPU8[$5 + $9 | 0] ^ $0 >>> 24) << 2) + 6800 >> 2] ^ $0 << 8;
                    }
                    HEAP8[$10 + 22 | 0] = $0;
                    HEAP8[$10 + 23 | 0] = $0 >>> 8;
                    HEAP8[$10 + 24 | 0] = $0 >>> 16;
                    HEAP8[$10 + 25 | 0] = $0 >>> 24;
                    if (HEAP32[$15 + 12 >> 2] == (HEAPU8[$20 | 0] | HEAPU8[$20 + 1 | 0] << 8 | (HEAPU8[$20 + 2 | 0] << 16 | HEAPU8[$20 + 3 | 0] << 24))) {
                     break block101
                    }
                    HEAP8[$20 | 0] = $14;
                    HEAP8[$20 + 1 | 0] = $14 >>> 8;
                    HEAP8[$20 + 2 | 0] = $14 >>> 16;
                    HEAP8[$20 + 3 | 0] = $14 >>> 24;
                    $9 = HEAP32[$8 >> 2];
                   }
                   HEAP32[$8 + 20 >> 2] = 0;
                   HEAP32[$8 + 24 >> 2] = 0;
                   $0 = $16 - 1 | 0;
                   $5 = ($0 | 0) != 0;
                   $7 = $10 + 1 | 0;
                   __inlined_func$memchr$15 : {
                    block20 : {
                     block15 : {
                      block36 : {
                       if (!($7 & 3) | !$0) {
                        break block36
                       }
                       while (1) {
                        if (HEAPU8[$7 | 0] == 79) {
                         break block15
                        }
                        $0 = $0 - 1 | 0;
                        $5 = ($0 | 0) != 0;
                        $7 = $7 + 1 | 0;
                        if (!($7 & 3)) {
                         break block36
                        }
                        if ($0) {
                         continue
                        }
                        break;
                       };
                      }
                      if (!$5) {
                       break block20
                      }
                      if (!(HEAPU8[$7 | 0] == 79 | $0 >>> 0 < 4)) {
                       while (1) {
                        $3 = HEAP32[$7 >> 2] ^ 1330597711;
                        if (((16843008 - $3 | $3) & -2139062144) != -2139062144) {
                         break block15
                        }
                        $7 = $7 + 4 | 0;
                        $0 = $0 - 4 | 0;
                        if ($0 >>> 0 > 3) {
                         continue
                        }
                        break;
                       }
                      }
                      if (!$0) {
                       break block20
                      }
                     }
                     while (1) {
                      $3 = $7;
                      if (HEAPU8[$7 | 0] == 79) {
                       break __inlined_func$memchr$15
                      }
                      $7 = $7 + 1 | 0;
                      $0 = $0 - 1 | 0;
                      if ($0) {
                       continue
                      }
                      break;
                     };
                    }
                    $3 = 0;
                   }
                   $0 = $3;
                   if (!$0) {
                    $0 = HEAP32[$8 + 8 >> 2] + $9 | 0
                   }
                   HEAP32[$8 + 12 >> 2] = $0 - $9;
                   $0 = $10 - $0 | 0;
                   break block02;
                  }
                  $4 = HEAP32[$8 + 12 >> 2];
                  $3 = HEAP32[$8 + 24 >> 2];
                  $5 = HEAP32[$8 + 20 >> 2];
                  if ($22) {
                   $0 = HEAP32[$8 >> 2];
                   HEAP32[$22 + 12 >> 2] = $3;
                   HEAP32[$22 + 4 >> 2] = $5;
                   $0 = $0 + $4 | 0;
                   HEAP32[$22 >> 2] = $0;
                   HEAP32[$22 + 8 >> 2] = $0 + $5;
                  }
                  HEAP32[$8 + 24 >> 2] = 0;
                  HEAP32[$8 + 16 >> 2] = 0;
                  HEAP32[$8 + 20 >> 2] = 0;
                  $0 = $3 + $5 | 0;
                  HEAP32[$8 + 12 >> 2] = $4 + $0;
                 }
                 __stack_pointer = $15 + 16 | 0;
                 $3 = 1;
                 if (($0 | 0) > 0) {
                  break __inlined_func$ogg_sync_pageout$19
                 }
                 $3 = 0;
                 if (!$0) {
                  break __inlined_func$ogg_sync_pageout$19
                 }
                 if (HEAP32[$8 + 16 >> 2]) {
                  continue
                 }
                 break;
                };
                HEAP32[$8 + 16 >> 2] = 1;
                $3 = -1;
               }
               $0 = $3;
              } else {
               $0 = 0
              }
              if (($0 | 0) > 0) {
               if (HEAP32[$11 + 404 >> 2]) {
                $0 = HEAP32[$22 >> 2];
                $0 = HEAPU8[$0 + 14 | 0] | HEAPU8[$0 + 15 | 0] << 8 | (HEAPU8[$0 + 16 | 0] << 16 | HEAPU8[$0 + 17 | 0] << 24);
                HEAP32[$11 + 404 >> 2] = 0;
                HEAP32[$11 + 344 >> 2] = $0;
                HEAP32[$11 + 4 >> 2] = $0;
               }
               $17 = -1;
               block27 : {
                if (!$6) {
                 break block27
                }
                $9 = HEAP32[$6 >> 2];
                if (!$9) {
                 break block27
                }
                $12 = HEAP32[$22 >> 2];
                $23 = HEAPU8[$12 + 5 | 0];
                $25 = HEAP32[$22 + 12 >> 2];
                $3 = HEAP32[$22 + 8 >> 2];
                $13 = HEAPU8[$12 + 26 | 0];
                $10 = HEAPU8[$12 + 18 | 0] | HEAPU8[$12 + 19 | 0] << 8 | (HEAPU8[$12 + 20 | 0] << 16 | HEAPU8[$12 + 21 | 0] << 24);
                $19 = HEAPU8[$12 + 14 | 0] | HEAPU8[$12 + 15 | 0] << 8 | (HEAPU8[$12 + 16 | 0] << 16 | HEAPU8[$12 + 17 | 0] << 24);
                $7 = HEAPU8[$12 + 6 | 0] | HEAPU8[$12 + 7 | 0] << 8 | (HEAPU8[$12 + 8 | 0] << 16 | HEAPU8[$12 + 9 | 0] << 24);
                $20 = HEAPU8[$12 + 10 | 0] | HEAPU8[$12 + 11 | 0] << 8 | (HEAPU8[$12 + 12 | 0] << 16 | HEAPU8[$12 + 13 | 0] << 24);
                $15 = HEAPU8[$12 + 4 | 0];
                $4 = HEAP32[$6 + 36 >> 2];
                $14 = HEAP32[$6 + 12 >> 2];
                if ($14) {
                 $0 = HEAP32[$6 + 8 >> 2];
                 $5 = $0 - $14 | 0;
                 HEAP32[$6 + 8 >> 2] = $5;
                 if (!(!$5 | ($0 | 0) == ($14 | 0))) {
                  wasm2js_memory_copy($9, $9 + $14 | 0, $5)
                 }
                 HEAP32[$6 + 12 >> 2] = 0;
                }
                if ($4) {
                 $5 = HEAP32[$6 + 28 >> 2];
                 $0 = $4;
                 if (($5 | 0) != ($0 | 0)) {
                  $9 = $5 - $0 << 2;
                  if ($9) {
                   $5 = HEAP32[$6 + 16 >> 2];
                   wasm2js_memory_copy($5, $5 + ($0 << 2) | 0, $9);
                  }
                  $5 = HEAP32[$6 + 28 >> 2] - $4 << 3;
                  if ($5) {
                   $0 = HEAP32[$6 + 20 >> 2];
                   wasm2js_memory_copy($0, $0 + ($4 << 3) | 0, $5);
                  }
                  $0 = HEAP32[$6 + 28 >> 2];
                 }
                 HEAP32[$6 + 36 >> 2] = 0;
                 HEAP32[$6 + 28 >> 2] = $0 - $4;
                 HEAP32[$6 + 32 >> 2] = HEAP32[$6 + 32 >> 2] - $4;
                }
                if ($15 | ($19 | 0) != HEAP32[$6 + 336 >> 2]) {
                 break block27
                }
                if (_os_lacing_expand($6, $13 + 1 | 0)) {
                 break block27
                }
                $16 = $23 & 1;
                $14 = HEAP32[$6 + 340 >> 2];
                block73 : {
                 if (($14 | 0) == ($10 | 0)) {
                  break block73
                 }
                 $4 = HEAP32[$6 + 32 >> 2];
                 $21 = HEAP32[$6 + 28 >> 2];
                 if (($4 | 0) < ($21 | 0)) {
                  $5 = HEAP32[$6 + 8 >> 2];
                  $27 = HEAP32[$6 + 16 >> 2];
                  $9 = $21 - $4 & 3;
                  block104 : {
                   if (!$9) {
                    $0 = $4;
                    break block104;
                   }
                   $15 = 0;
                   $0 = $4;
                   while (1) {
                    $5 = $5 - HEAPU8[$27 + ($0 << 2) | 0] | 0;
                    $0 = $0 + 1 | 0;
                    $15 = $15 + 1 | 0;
                    if (($9 | 0) != ($15 | 0)) {
                     continue
                    }
                    break;
                   };
                  }
                  if ($4 - $21 >>> 0 <= 4294967292) {
                   $19 = $27 + 12 | 0;
                   $15 = $27 + 8 | 0;
                   $9 = $27 + 4 | 0;
                   while (1) {
                    $34 = $5;
                    $5 = $0 << 2;
                    $5 = $34 - (((HEAPU8[$5 + $27 | 0] + HEAPU8[$5 + $9 | 0] | 0) + HEAPU8[$5 + $15 | 0] | 0) + HEAPU8[$5 + $19 | 0] | 0) | 0;
                    $0 = $0 + 4 | 0;
                    if (($21 | 0) != ($0 | 0)) {
                     continue
                    }
                    break;
                   };
                  }
                  HEAP32[$6 + 8 >> 2] = $5;
                 }
                 HEAP32[$6 + 28 >> 2] = $4;
                 if (($14 | 0) == -1) {
                  break block73
                 }
                 $0 = $4 + 1 | 0;
                 HEAP32[$6 + 28 >> 2] = $0;
                 HEAP32[HEAP32[$6 + 16 >> 2] + ($4 << 2) >> 2] = 1024;
                 HEAP32[$6 + 32 >> 2] = $0;
                }
                $0 = $23 & 2;
                $5 = 0;
                block12 : {
                 if (!$16) {
                  break block12
                 }
                 $4 = HEAP32[$6 + 28 >> 2];
                 if (($4 | 0) > 0) {
                  if (HEAP32[(HEAP32[$6 + 16 >> 2] + ($4 << 2) | 0) - 4 >> 2] != 1024) {
                   break block12
                  }
                 }
                 $0 = 0;
                 if (!$13) {
                  break block12
                 }
                 $4 = $12 + 27 | 0;
                 while (1) {
                  $5 = $0 + 1 | 0;
                  $0 = HEAPU8[$0 + $4 | 0];
                  $25 = $25 - $0 | 0;
                  $3 = $0 + $3 | 0;
                  if (($0 | 0) != 255) {
                   $0 = 0;
                   break block12;
                  }
                  $0 = $5;
                  if (($13 | 0) != ($0 | 0)) {
                   continue
                  }
                  break;
                 };
                 $0 = 0;
                 $5 = $13;
                }
                $4 = !!$25;
                if ($4) {
                 if (_os_body_expand($6, $25)) {
                  break block27
                 }
                 if ($4) {
                  wasm2js_memory_copy(HEAP32[$6 >> 2] + HEAP32[$6 + 8 >> 2] | 0, $3, $25)
                 }
                 HEAP32[$6 + 8 >> 2] = HEAP32[$6 + 8 >> 2] + $25;
                }
                $19 = $23 & 4;
                block18 : {
                 if (($5 | 0) >= ($13 | 0)) {
                  break block18
                 }
                 $23 = HEAP32[$6 + 20 >> 2];
                 $16 = HEAP32[$6 + 16 >> 2];
                 $21 = HEAP32[$6 + 28 >> 2];
                 $4 = $16 + ($21 << 2) | 0;
                 $14 = $12 + 27 | 0;
                 $9 = HEAPU8[$14 + $5 | 0];
                 HEAP32[$4 >> 2] = $9;
                 $3 = $23 + ($21 << 3) | 0;
                 HEAP32[$3 >> 2] = -1;
                 HEAP32[$3 + 4 >> 2] = -1;
                 if ($0) {
                  HEAP32[$4 >> 2] = $9 | 256
                 }
                 $4 = $21 + 1 | 0;
                 if (($9 | 0) == 255) {
                  $3 = -1
                 } else {
                  HEAP32[$6 + 32 >> 2] = $4;
                  $3 = $21;
                 }
                 HEAP32[$6 + 28 >> 2] = $4;
                 $17 = $5 + 1 | 0;
                 block22 : {
                  if (($13 | 0) == ($17 | 0)) {
                   break block22
                  }
                  $15 = $13 - 2 | 0;
                  block24 : {
                   if ($5 - $13 & 1) {
                    $0 = $4;
                    break block24;
                   }
                   $9 = HEAPU8[$14 + $17 | 0];
                   HEAP32[$16 + ($4 << 2) >> 2] = $9;
                   $0 = $23 + ($4 << 3) | 0;
                   HEAP32[$0 >> 2] = -1;
                   HEAP32[$0 + 4 >> 2] = -1;
                   $0 = $21 + 2 | 0;
                   if (($9 | 0) != 255) {
                    HEAP32[$6 + 32 >> 2] = $0;
                    $3 = $4;
                   }
                   HEAP32[$6 + 28 >> 2] = $0;
                   $17 = $5 + 2 | 0;
                  }
                  if (($5 | 0) == ($15 | 0)) {
                   break block22
                  }
                  $15 = $14 + 1 | 0;
                  while (1) {
                   $5 = HEAPU8[$14 + $17 | 0];
                   HEAP32[$16 + ($0 << 2) >> 2] = $5;
                   $4 = $23 + ($0 << 3) | 0;
                   HEAP32[$4 >> 2] = -1;
                   HEAP32[$4 + 4 >> 2] = -1;
                   $4 = $0 + 1 | 0;
                   if (($5 | 0) != 255) {
                    HEAP32[$6 + 32 >> 2] = $4;
                    $3 = $0;
                   }
                   HEAP32[$6 + 28 >> 2] = $4;
                   $9 = HEAPU8[$15 + $17 | 0];
                   HEAP32[$16 + ($4 << 2) >> 2] = $9;
                   $5 = $23 + ($4 << 3) | 0;
                   HEAP32[$5 >> 2] = -1;
                   HEAP32[$5 + 4 >> 2] = -1;
                   $0 = $0 + 2 | 0;
                   if (($9 | 0) != 255) {
                    HEAP32[$6 + 32 >> 2] = $0;
                    $3 = $4;
                   }
                   HEAP32[$6 + 28 >> 2] = $0;
                   $17 = $17 + 2 | 0;
                   if (($13 | 0) != ($17 | 0)) {
                    continue
                   }
                   break;
                  };
                 }
                 if (($3 | 0) == -1) {
                  break block18
                 }
                 $0 = HEAP32[$6 + 20 >> 2] + ($3 << 3) | 0;
                 HEAP32[$0 >> 2] = $7;
                 HEAP32[$0 + 4 >> 2] = $20;
                }
                block28 : {
                 if (!$19) {
                  break block28
                 }
                 HEAP32[$6 + 328 >> 2] = 1;
                 $0 = HEAP32[$6 + 28 >> 2];
                 if (($0 | 0) <= 0) {
                  break block28
                 }
                 $0 = (HEAP32[$6 + 16 >> 2] + ($0 << 2) | 0) - 4 | 0;
                 HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | 512;
                }
                HEAP32[$6 + 340 >> 2] = $10 + 1;
                $17 = 0;
               }
               if ($17) {
                break block7
               }
               HEAP32[$11 + 432 >> 2] = 0;
               HEAP32[$11 + 412 >> 2] = 1;
               break block7;
              }
              $7 = 2;
              if ($0) {
               break block10
              }
              $0 = $29 - HEAP32[$1 >> 2] | 0;
              $5 = $0 >>> 0 <= 8192 ? 8192 : $0;
              $0 = HEAP32[$8 + 4 >> 2];
              __inlined_func$ogg_sync_buffer$22 : {
               if (($0 | 0) >= 0) {
                $3 = HEAP32[$8 + 12 >> 2];
                if ($3) {
                 $4 = HEAP32[$8 + 8 >> 2] - $3 | 0;
                 HEAP32[$8 + 8 >> 2] = $4;
                 if (($4 | 0) > 0) {
                  if ($4) {
                   $0 = HEAP32[$8 >> 2];
                   wasm2js_memory_copy($0, $0 + $3 | 0, $4);
                  }
                  $0 = HEAP32[$8 + 4 >> 2];
                 }
                 HEAP32[$8 + 12 >> 2] = 0;
                }
                $3 = HEAP32[$8 >> 2];
                $4 = $0;
                $0 = HEAP32[$8 + 8 >> 2];
                if (($5 | 0) > ($4 - $0 | 0)) {
                 $0 = ($0 + $5 | 0) + 4096 | 0;
                 block69 : {
                  if ($3) {
                   $3 = emscripten_builtin_realloc($3, $0);
                   break block69;
                  }
                  $3 = emscripten_builtin_malloc($0);
                 }
                 if (!$3) {
                  $0 = HEAP32[$8 >> 2];
                  if ($0) {
                   emscripten_builtin_free($0)
                  }
                  HEAP32[$8 >> 2] = 0;
                  HEAP32[$8 + 4 >> 2] = 0;
                  HEAP32[$8 + 24 >> 2] = 0;
                  $0 = $8 + 16 | 0;
                  HEAP32[$0 >> 2] = 0;
                  HEAP32[$0 + 4 >> 2] = 0;
                  $0 = $8 + 8 | 0;
                  HEAP32[$0 >> 2] = 0;
                  HEAP32[$0 + 4 >> 2] = 0;
                  $0 = 0;
                  break __inlined_func$ogg_sync_buffer$22;
                 }
                 HEAP32[$8 + 4 >> 2] = $0;
                 HEAP32[$8 >> 2] = $3;
                 $0 = HEAP32[$8 + 8 >> 2];
                }
                $0 = $0 + $3 | 0;
               } else {
                $0 = 0
               }
              }
              $7 = 7;
              if (!$0) {
               break block10
              }
              HEAP32[$26 + 12 >> 2] = $5;
              block187 : {
               switch ((FUNCTION_TABLE[9]($2, $0, $26 + 12 | 0, $31) | 0) - 1 | 0) {
               case 4:
                $7 = 5;
                break block10;
               case 0:
                HEAP32[$11 + 408 >> 2] = 1;
                break;
               default:
                break block187;
               };
              }
              $4 = HEAP32[$26 + 12 >> 2];
              $0 = -1;
              $3 = HEAP32[$8 + 4 >> 2];
              block86 : {
               if (($3 | 0) < 0) {
                break block86
               }
               $5 = $3;
               $3 = HEAP32[$8 + 8 >> 2] + $4 | 0;
               if (($5 | 0) < ($3 | 0)) {
                break block86
               }
               HEAP32[$8 + 8 >> 2] = $3;
               $0 = 0;
              }
              if (($0 | 0) >= 0) {
               break block7
              }
              $7 = 6;
              break block10;
             }
             HEAP32[$11 + 444 >> 2] = $3 - 9;
             HEAP32[$11 + 440 >> 2] = $4 + 9;
            }
            $0 = HEAP32[$1 >> 2];
            if ($0 >>> 0 < $29 >>> 0) {
             continue
            }
           }
           break;
          };
          $0 = !$0;
         } else {
          $0 = 1
         }
         $7 = $0 & HEAP32[$11 + 408 >> 2] != 0;
        }
        $0 = $7;
        __stack_pointer = $26 + 16 | 0;
        switch ($0 | 0) {
        case 0:
        case 2:
         break block4;
        case 1:
         break block5;
        default:
         break block1;
        };
       }
       $32 = FUNCTION_TABLE[HEAP32[$3 + 4 >> 2]]($2, $0, $1, $31) | 0;
       if (($32 | 0) == 2) {
        break block1
       }
      }
      if (!HEAP32[$1 >> 2]) {
       break block6
      }
      return 1;
     }
     if (HEAP32[$1 >> 2]) {
      return 1
     }
     $28 = 4;
     break block1;
    }
    $1 = 1;
    $28 = 4;
    if (($32 | 0) == 1) {
     break block1
    }
    $3 = HEAP32[$2 + 4 >> 2];
    if (HEAP32[$3 >> 2]) {
     break block8
    }
    $0 = HEAP32[$3 + 20 >> 2];
    if (!$0) {
     break block8
    }
    if (!(FUNCTION_TABLE[$0 | 0]($2, HEAP32[$3 + 48 >> 2]) | 0)) {
     break block8
    }
   }
   HEAP32[HEAP32[$2 >> 2] >> 2] = $28;
   $1 = 0;
  }
  return $1 | 0;
 }
 
 function FLAC__stream_decoder_reset($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = HEAP32[$0 + 4 >> 2];
  block1 : {
   if (!HEAP32[$1 + 3628 >> 2] & HEAP32[HEAP32[$0 >> 2] >> 2] == 9) {
    break block1
   }
   HEAP32[$1 + 3624 >> 2] = 0;
   HEAP32[$1 + 240 >> 2] = 0;
   HEAP32[$1 + 244 >> 2] = 0;
   if (HEAP32[$1 >> 2]) {
    $1 = HEAP32[$0 >> 2] + 32 | 0;
    ogg_stream_reset($1 + 8 | 0);
    ogg_sync_reset($1 + 368 | 0);
    HEAP32[$1 + 408 >> 2] = 0;
    HEAP32[$1 + 412 >> 2] = 0;
    $1 = HEAP32[$0 + 4 >> 2];
   }
   $1 = HEAP32[$1 + 56 >> 2];
   HEAP32[$1 + 8 >> 2] = 0;
   HEAP32[$1 + 12 >> 2] = 0;
   $1 = $1 + 16 | 0;
   HEAP32[$1 >> 2] = 0;
   HEAP32[$1 + 4 >> 2] = 0;
   $1 = 1;
   $2 = HEAP32[$0 >> 2];
   HEAP32[$2 >> 2] = $1 ? 2 : 8;
   if (!$1) {
    break block1
   }
   $1 = HEAP32[$0 + 4 >> 2];
   if (HEAP32[$1 >> 2]) {
    $1 = $2 + 32 | 0;
    ogg_stream_reset($1 + 8 | 0);
    ogg_sync_reset($1 + 368 | 0);
    HEAP32[$1 + 408 >> 2] = 0;
    HEAP32[$1 + 412 >> 2] = 0;
    if (HEAP32[$1 >> 2]) {
     HEAP32[$1 + 404 >> 2] = 1
    }
    $1 = HEAP32[$0 + 4 >> 2];
   }
   block5 : {
    if (!HEAP32[$1 + 3628 >> 2]) {
     if (HEAP32[$1 + 52 >> 2] == HEAP32[1958]) {
      break block1
     }
     $2 = HEAP32[$1 + 8 >> 2];
     if (!$2) {
      break block5
     }
     if ((FUNCTION_TABLE[$2 | 0]($0, 0, 0, HEAP32[$1 + 48 >> 2]) | 0) == 1) {
      break block1
     }
     $1 = HEAP32[$0 + 4 >> 2];
     break block5;
    }
    HEAP32[$1 + 3628 >> 2] = 0;
   }
   HEAP32[HEAP32[$0 >> 2] >> 2] = 0;
   HEAP32[$1 + 248 >> 2] = 0;
   emscripten_builtin_free(HEAP32[$1 + 452 >> 2]);
   HEAP32[HEAP32[$0 + 4 >> 2] + 452 >> 2] = 0;
   $1 = HEAP32[$0 + 4 >> 2];
   HEAP32[$1 + 252 >> 2] = 0;
   HEAP32[$1 + 3624 >> 2] = HEAP32[HEAP32[$0 >> 2] + 28 >> 2];
   HEAP32[$1 + 228 >> 2] = 0;
   HEAP32[$1 + 232 >> 2] = 0;
   FLAC__MD5Init($1 + 3636 | 0);
   $0 = HEAP32[$0 + 4 >> 2];
   HEAP32[$0 + 6152 >> 2] = 0;
   HEAP32[$0 + 6136 >> 2] = 0;
   HEAP32[$0 + 6140 >> 2] = 0;
   $3 = 1;
  }
  return $3 | 0;
 }
 
 function FLAC__stream_decoder_init_ogg_stream($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  $6 = $6 | 0;
  $7 = $7 | 0;
  $8 = $8 | 0;
  $9 = $9 | 0;
  return init_stream_internal_($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, 1) | 0;
 }
 
 function FLAC__stream_decoder_set_ogg_serial_number($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $0 = HEAP32[$0 >> 2];
  if (HEAP32[$0 >> 2] == 9) {
   $0 = $0 + 32 | 0;
   HEAP32[$0 + 4 >> 2] = $1;
   HEAP32[$0 >> 2] = 0;
   $0 = 1;
  } else {
   $0 = 0
  }
  return $0 | 0;
 }
 
 function FLAC__stream_decoder_set_md5_checking($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $0 = HEAP32[$0 >> 2];
  if (HEAP32[$0 >> 2] == 9) {
   HEAP32[$0 + 28 >> 2] = $1;
   $2 = 1;
  }
  return $2 | 0;
 }
 
 function FLAC__stream_decoder_set_metadata_respond($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  block : {
   if (HEAP32[HEAP32[$0 >> 2] >> 2] != 9 | $1 >>> 0 > 126) {
    break block
   }
   $2 = 1;
   $0 = HEAP32[$0 + 4 >> 2];
   HEAP32[($0 + ($1 << 2) | 0) + 608 >> 2] = 1;
   if (($1 | 0) != 2) {
    break block
   }
   HEAP32[$0 + 1124 >> 2] = 0;
  }
  return $2 | 0;
 }
 
 function FLAC__stream_decoder_set_metadata_respond_application($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0;
  block2 : {
   block6 : {
    $2 = 0;
    block : {
     if (HEAP32[HEAP32[$0 >> 2] >> 2] != 9) {
      break block
     }
     $3 = HEAP32[$0 + 4 >> 2];
     $2 = 1;
     if (HEAP32[$3 + 616 >> 2]) {
      break block
     }
     $2 = HEAP32[$3 + 1120 >> 2];
     $4 = HEAP32[$3 + 1124 >> 2];
     if (($4 | 0) != HEAP32[$3 + 1128 >> 2]) {
      $3 = $2;
      break block2;
     }
     block7 : {
      if ($4) {
       if (($4 | 0) >= 0) {
        $3 = emscripten_builtin_realloc($2, $4 << 1);
        if ($3) {
         $4 = HEAP32[$0 + 4 >> 2];
         HEAP32[$4 + 1120 >> 2] = $3;
         break block6;
        }
        emscripten_builtin_free($2);
        $3 = HEAP32[$0 + 4 >> 2];
       }
       HEAP32[$3 + 1120 >> 2] = 0;
       break block7;
      }
      $3 = emscripten_builtin_realloc($2, 0);
      $4 = HEAP32[$0 + 4 >> 2];
      HEAP32[$4 + 1120 >> 2] = $3;
      if ($3) {
       break block6
      }
     }
     HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
     $2 = 0;
    }
    return $2 | 0;
   }
   HEAP32[$4 + 1128 >> 2] = HEAP32[$4 + 1128 >> 2] << 1;
   $4 = HEAP32[$4 + 1124 >> 2];
  }
  $2 = HEAP32[1641] >>> 3 | 0;
  if ($2) {
   wasm2js_memory_copy(Math_imul($4, $2) + $3 | 0, $1, $2)
  }
  $0 = HEAP32[$0 + 4 >> 2];
  HEAP32[$0 + 1124 >> 2] = HEAP32[$0 + 1124 >> 2] + 1;
  return 1;
 }
 
 function FLAC__stream_decoder_set_metadata_respond_all($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
  if (HEAP32[HEAP32[$0 >> 2] >> 2] == 9) {
   $3 = HEAP32[$0 + 4 >> 2];
   $4 = $3 + 608 | 0;
   while (1) {
    $0 = ($1 << 2) + $4 | 0;
    HEAP32[$0 >> 2] = 1;
    HEAP32[$0 + 4 >> 2] = 1;
    $2 = $0 + 8 | 0;
    HEAP32[$2 >> 2] = 1;
    HEAP32[$2 + 4 >> 2] = 1;
    $2 = $0 + 16 | 0;
    HEAP32[$2 >> 2] = 1;
    HEAP32[$2 + 4 >> 2] = 1;
    $0 = $0 + 24 | 0;
    HEAP32[$0 >> 2] = 1;
    HEAP32[$0 + 4 >> 2] = 1;
    $1 = $1 + 8 | 0;
    if (($1 | 0) != 128) {
     continue
    }
    break;
   };
   HEAP32[$3 + 1124 >> 2] = 0;
   $1 = 1;
  }
  return $1 | 0;
 }
 
 function FLAC__stream_decoder_set_metadata_ignore($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  block : {
   if (HEAP32[HEAP32[$0 >> 2] >> 2] != 9 | $1 >>> 0 > 126) {
    break block
   }
   $0 = HEAP32[$0 + 4 >> 2];
   HEAP32[($0 + ($1 << 2) | 0) + 608 >> 2] = 0;
   $2 = 1;
   if (($1 | 0) != 2) {
    break block
   }
   HEAP32[$0 + 1124 >> 2] = 0;
  }
  return $2 | 0;
 }
 
 function FLAC__stream_decoder_set_metadata_ignore_application($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0;
  block3 : {
   block7 : {
    if (HEAP32[HEAP32[$0 >> 2] >> 2] == 9) {
     $2 = HEAP32[$0 + 4 >> 2];
     if (!HEAP32[$2 + 616 >> 2]) {
      return 1
     }
     $4 = HEAP32[$2 + 1120 >> 2];
     $3 = HEAP32[$2 + 1124 >> 2];
     if (($3 | 0) != HEAP32[$2 + 1128 >> 2]) {
      $2 = $4;
      break block3;
     }
     block8 : {
      if ($3) {
       if (($3 | 0) >= 0) {
        $2 = emscripten_builtin_realloc($4, $3 << 1);
        if ($2) {
         $3 = HEAP32[$0 + 4 >> 2];
         HEAP32[$3 + 1120 >> 2] = $2;
         break block7;
        }
        emscripten_builtin_free($4);
        $2 = HEAP32[$0 + 4 >> 2];
       }
       HEAP32[$2 + 1120 >> 2] = 0;
       break block8;
      }
      $2 = emscripten_builtin_realloc($4, 0);
      $3 = HEAP32[$0 + 4 >> 2];
      HEAP32[$3 + 1120 >> 2] = $2;
      if ($2) {
       break block7
      }
     }
     HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
    }
    return 0;
   }
   HEAP32[$3 + 1128 >> 2] = HEAP32[$3 + 1128 >> 2] << 1;
   $3 = HEAP32[$3 + 1124 >> 2];
  }
  $4 = HEAP32[1641] >>> 3 | 0;
  if ($4) {
   wasm2js_memory_copy(Math_imul($3, $4) + $2 | 0, $1, $4)
  }
  $0 = HEAP32[$0 + 4 >> 2];
  HEAP32[$0 + 1124 >> 2] = HEAP32[$0 + 1124 >> 2] + 1;
  return 1;
 }
 
 function FLAC__stream_decoder_set_metadata_ignore_all($0) {
  $0 = $0 | 0;
  var $1 = 0;
  if (HEAP32[HEAP32[$0 >> 2] >> 2] == 9) {
   wasm2js_memory_fill(HEAP32[$0 + 4 >> 2] + 608 | 0, 0, 512);
   HEAP32[HEAP32[$0 + 4 >> 2] + 1124 >> 2] = 0;
   $1 = 1;
  }
  return $1 | 0;
 }
 
 function FLAC__stream_decoder_get_state($0) {
  $0 = $0 | 0;
  return HEAP32[HEAP32[$0 >> 2] >> 2];
 }
 
 function FLAC__stream_decoder_get_md5_checking($0) {
  $0 = $0 | 0;
  return HEAP32[HEAP32[$0 >> 2] + 28 >> 2];
 }
 
 function FLAC__stream_decoder_process_single($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  block5 : {
   while (1) {
    block4 : {
     block3 : {
      switch (HEAP32[HEAP32[$0 >> 2] >> 2]) {
      case 0:
       if (find_metadata_($0)) {
        continue
       }
       break block5;
      case 1:
       $2 = read_metadata_($0);
       break block5;
      case 2:
       if (frame_sync_($0)) {
        continue
       }
       break block4;
      case 3:
       break block3;
      case 4:
      case 7:
       break block4;
      default:
       break block5;
      };
     }
     if (!read_frame_($0, $1 + 12 | 0)) {
      break block5
     }
     if (!HEAP32[$1 + 12 >> 2]) {
      continue
     }
    }
    break;
   };
   $2 = 1;
  }
  __stack_pointer = $1 + 16 | 0;
  return $2 | 0;
 }
 
 function find_metadata_($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  $6 = HEAPU8[6517];
  $5 = 1;
  block3 : {
   while (1) {
    $4 = HEAP32[$0 + 4 >> 2];
    block1 : {
     if (HEAP32[$4 + 3520 >> 2]) {
      $2 = HEAPU8[$4 + 3590 | 0];
      HEAP32[$3 + 8 >> 2] = $2;
      HEAP32[$4 + 3520 >> 2] = 0;
      break block1;
     }
     if (!FLAC__bitreader_read_raw_uint32(HEAP32[$4 + 56 >> 2], $3 + 8 | 0, 8)) {
      $1 = 0;
      break block3;
     }
     $2 = HEAP32[$3 + 8 >> 2];
    }
    block19 : {
     block4 : {
      if (HEAPU8[$1 + 6517 | 0] == ($2 | 0)) {
       break block4
      }
      block12 : {
       block5 : {
        if (($2 | 0) != 73) {
         break block5
        }
        $1 = HEAP32[$0 + 4 >> 2];
        block7 : {
         if (HEAP32[$1 + 3520 >> 2]) {
          $2 = HEAPU8[$1 + 3590 | 0];
          HEAP32[$3 + 8 >> 2] = $2;
          HEAP32[$1 + 3520 >> 2] = 0;
          break block7;
         }
         if (!FLAC__bitreader_read_raw_uint32(HEAP32[$1 + 56 >> 2], $3 + 8 | 0, 8)) {
          $1 = 0;
          break block3;
         }
         $2 = HEAP32[$3 + 8 >> 2];
        }
        $1 = 0;
        if (($2 | 0) == ($6 | 0)) {
         break block4
        }
        if (($2 | 0) != 68) {
         break block5
        }
        $4 = HEAP32[$0 + 4 >> 2];
        block10 : {
         if (HEAP32[$4 + 3520 >> 2]) {
          $2 = HEAPU8[$4 + 3590 | 0];
          HEAP32[$3 + 8 >> 2] = $2;
          HEAP32[$4 + 3520 >> 2] = 0;
          break block10;
         }
         if (!FLAC__bitreader_read_raw_uint32(HEAP32[$4 + 56 >> 2], $3 + 8 | 0, 8)) {
          break block3
         }
         $2 = HEAP32[$3 + 8 >> 2];
        }
        if (($2 | 0) == ($6 | 0)) {
         break block4
        }
        if (($2 | 0) != 51) {
         break block5
        }
        $1 = $3 + 12 | 0;
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $1, 24)) {
         break block12
        }
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $1, 8)) {
         break block12
        }
        $2 = HEAP32[$3 + 12 >> 2];
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $1, 8)) {
         break block12
        }
        $5 = HEAP32[$3 + 12 >> 2];
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $1, 8)) {
         break block12
        }
        $4 = HEAP32[$3 + 12 >> 2];
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $1, 8)) {
         break block12
        }
        $1 = 0;
        if (!FLAC__bitreader_skip_byte_block_aligned_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], HEAP32[$3 + 12 >> 2] & 127 | ($4 << 7 & 16256 | ($5 & 127 | $2 << 7 & 16256) << 14))) {
         break block3
        }
        $2 = HEAP32[$0 + 4 >> 2];
        block14 : {
         if (HEAP32[$2 + 3520 >> 2]) {
          $5 = HEAPU8[$2 + 3590 | 0];
          HEAP32[$3 + 8 >> 2] = $5;
          HEAP32[$2 + 3520 >> 2] = 0;
          break block14;
         }
         if (!FLAC__bitreader_read_raw_uint32(HEAP32[$2 + 56 >> 2], $3 + 8 | 0, 8)) {
          break block3
         }
         $5 = HEAP32[$3 + 8 >> 2];
        }
        if (($5 | 0) == ($6 | 0)) {
         break block4
        }
        break block3;
       }
       block15 : {
        if (($2 | 0) != 255) {
         break block15
        }
        HEAP8[HEAP32[$0 + 4 >> 2] + 3588 | 0] = 255;
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $3 + 8 | 0, 8)) {
         $1 = 0;
         break block3;
        }
        $1 = HEAP32[$3 + 8 >> 2];
        if (($1 | 0) == 255) {
         $1 = HEAP32[$0 + 4 >> 2];
         HEAP32[$1 + 3520 >> 2] = 1;
         HEAP8[$1 + 3590 | 0] = 255;
         break block15;
        }
        if (($1 & -2) != 248) {
         break block15
        }
        HEAP8[HEAP32[$0 + 4 >> 2] + 3589 | 0] = $1;
        HEAP32[HEAP32[$0 >> 2] >> 2] = 3;
        $1 = 1;
        break block3;
       }
       $1 = 0;
       $4 = 0;
       if (!$5) {
        break block19
       }
       $2 = HEAP32[$0 + 4 >> 2];
       $4 = 0;
       if (HEAP32[$2 + 3632 >> 2]) {
        break block19
       }
       FUNCTION_TABLE[HEAP32[$2 + 32 >> 2]]($0, 0, HEAP32[$2 + 48 >> 2]);
       $4 = 0;
       break block19;
      }
      $1 = 0;
      break block3;
     }
     $1 = $1 + 1 | 0;
     $4 = 1;
    }
    $5 = $4;
    if ($1 >>> 0 < 4) {
     continue
    }
    break;
   };
   $1 = 1;
   HEAP32[HEAP32[$0 >> 2] >> 2] = 1;
  }
  __stack_pointer = $3 + 16 | 0;
  return $1;
 }
 
 function read_metadata_($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
  $5 = __stack_pointer - 192 | 0;
  __stack_pointer = $5;
  block1 : {
   block11 : {
    block : {
     if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $5 + 184 | 0, HEAP32[1668])) {
      break block
     }
     $14 = HEAP32[$5 + 184 >> 2];
     if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $5 + 180 | 0, HEAP32[1669])) {
      break block1
     }
     if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $5 + 176 | 0, HEAP32[1670])) {
      break block1
     }
     $2 = ($14 | 0) != 0;
     block6 : {
      block3 : {
       block4 : {
        block2 : {
         $3 = HEAP32[$5 + 180 >> 2];
         switch ($3 | 0) {
         case 0:
          break block2;
         case 3:
          break block4;
         default:
          break block3;
         };
        }
        $4 = HEAP32[$0 + 4 >> 2];
        $3 = HEAP32[$5 + 176 >> 2];
        HEAP32[$4 + 264 >> 2] = $3;
        HEAP32[$4 + 260 >> 2] = $2;
        HEAP32[$4 + 256 >> 2] = 0;
        $2 = HEAP32[1633];
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[$4 + 56 >> 2], $5, $2)) {
         break block1
        }
        HEAP32[HEAP32[$0 + 4 >> 2] + 272 >> 2] = HEAP32[$5 >> 2];
        $4 = HEAP32[1634];
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $5, $4)) {
         break block1
        }
        HEAP32[HEAP32[$0 + 4 >> 2] + 276 >> 2] = HEAP32[$5 >> 2];
        $6 = HEAP32[1635];
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $5, $6)) {
         break block1
        }
        HEAP32[HEAP32[$0 + 4 >> 2] + 280 >> 2] = HEAP32[$5 >> 2];
        $7 = HEAP32[1636];
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $5, $7)) {
         break block1
        }
        HEAP32[HEAP32[$0 + 4 >> 2] + 284 >> 2] = HEAP32[$5 >> 2];
        $8 = HEAP32[1637];
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $5, $8)) {
         break block1
        }
        HEAP32[HEAP32[$0 + 4 >> 2] + 288 >> 2] = HEAP32[$5 >> 2];
        $9 = HEAP32[1638];
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $5, $9)) {
         break block1
        }
        HEAP32[HEAP32[$0 + 4 >> 2] + 292 >> 2] = HEAP32[$5 >> 2] + 1;
        $10 = HEAP32[1639];
        if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $5, $10)) {
         break block1
        }
        HEAP32[HEAP32[$0 + 4 >> 2] + 296 >> 2] = HEAP32[$5 >> 2] + 1;
        $11 = HEAP32[$0 + 4 >> 2];
        $12 = HEAP32[$11 + 56 >> 2];
        $13 = $11 + 304 | 0;
        $11 = HEAP32[1640];
        if (!FLAC__bitreader_read_raw_uint64($12, $13, $11)) {
         break block1
        }
        $12 = HEAP32[$0 + 4 >> 2];
        if (!FLAC__bitreader_read_byte_block_aligned_no_crc(HEAP32[$12 + 56 >> 2], $12 + 312 | 0, 16)) {
         break block1
        }
        if (!FLAC__bitreader_skip_byte_block_aligned_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $3 - (($11 + (((($7 + ($6 + ($2 + $4 | 0) | 0) | 0) + $8 | 0) + $9 | 0) + $10 | 0) | 0) + 128 >>> 3 | 0) | 0)) {
         break block
        }
        $1 = HEAP32[$0 + 4 >> 2];
        HEAP32[$1 + 248 >> 2] = 1;
        if (!memcmp($1 + 312 | 0, 12080, 16)) {
         HEAP32[$1 + 3624 >> 2] = 0
        }
        if (HEAP32[$1 + 3632 >> 2] | !HEAP32[$1 + 608 >> 2]) {
         break block6
        }
        $2 = HEAP32[$1 + 28 >> 2];
        if (!$2) {
         break block6
        }
        FUNCTION_TABLE[$2 | 0]($0, $1 + 256 | 0, HEAP32[$1 + 48 >> 2]);
        break block6;
       }
       $1 = HEAP32[$0 + 4 >> 2];
       HEAP32[$1 + 252 >> 2] = 0;
       $4 = HEAP32[$5 + 176 >> 2];
       HEAP32[$1 + 448 >> 2] = ($4 >>> 0) / 18;
       HEAP32[$1 + 440 >> 2] = $4;
       HEAP32[$1 + 436 >> 2] = $2;
       HEAP32[$1 + 432 >> 2] = 3;
       $2 = HEAP32[$0 + 4 >> 2];
       $1 = HEAP32[$2 + 452 >> 2];
       $3 = HEAP32[$2 + 448 >> 2];
       block10 : {
        if ($3) {
         if ($3 >>> 0 <= 178956970) {
          $2 = emscripten_builtin_realloc($1, Math_imul($3, 24));
          if ($2) {
           HEAP32[HEAP32[$0 + 4 >> 2] + 452 >> 2] = $2;
           break block10;
          }
          emscripten_builtin_free($1);
          $2 = HEAP32[$0 + 4 >> 2];
         }
         HEAP32[$2 + 452 >> 2] = 0;
         break block11;
        }
        $1 = emscripten_builtin_realloc($1, 0);
        HEAP32[HEAP32[$0 + 4 >> 2] + 452 >> 2] = $1;
        if (!$1) {
         break block11
        }
       }
       $1 = HEAP32[$0 + 4 >> 2];
       if (HEAP32[$1 + 448 >> 2]) {
        $6 = HEAP32[1644];
        $7 = HEAP32[1643];
        $8 = HEAP32[1642];
        $2 = 0;
        while (1) {
         if (!FLAC__bitreader_read_raw_uint64(HEAP32[$1 + 56 >> 2], $5, $8)) {
          break block
         }
         $1 = HEAP32[$5 + 4 >> 2];
         $3 = Math_imul($2, 24);
         $9 = HEAP32[$0 + 4 >> 2];
         $10 = $3 + HEAP32[$9 + 452 >> 2] | 0;
         HEAP32[$10 >> 2] = HEAP32[$5 >> 2];
         HEAP32[$10 + 4 >> 2] = $1;
         if (!FLAC__bitreader_read_raw_uint64(HEAP32[$9 + 56 >> 2], $5, $7)) {
          break block
         }
         $1 = HEAP32[$5 + 4 >> 2];
         $9 = HEAP32[$0 + 4 >> 2];
         $10 = $3 + HEAP32[$9 + 452 >> 2] | 0;
         HEAP32[$10 + 8 >> 2] = HEAP32[$5 >> 2];
         HEAP32[$10 + 12 >> 2] = $1;
         if (!FLAC__bitreader_read_raw_uint32(HEAP32[$9 + 56 >> 2], $5 + 188 | 0, $6)) {
          break block
         }
         $1 = HEAP32[$0 + 4 >> 2];
         HEAP32[($3 + HEAP32[$1 + 452 >> 2] | 0) + 16 >> 2] = HEAP32[$5 + 188 >> 2];
         $2 = $2 + 1 | 0;
         $3 = HEAP32[$1 + 448 >> 2];
         if ($2 >>> 0 < $3 >>> 0) {
          continue
         }
         break;
        };
        $2 = Math_imul($3, -18);
       } else {
        $2 = 0
       }
       $2 = $2 + $4 | 0;
       if ($2) {
        if (!FLAC__bitreader_skip_byte_block_aligned_no_crc(HEAP32[$1 + 56 >> 2], $2)) {
         break block
        }
        $1 = HEAP32[$0 + 4 >> 2];
       }
       HEAP32[$1 + 252 >> 2] = 1;
       if (HEAP32[$1 + 3632 >> 2] | !HEAP32[$1 + 620 >> 2]) {
        break block6
       }
       $2 = HEAP32[$1 + 28 >> 2];
       if (!$2) {
        break block6
       }
       FUNCTION_TABLE[$2 | 0]($0, $1 + 432 | 0, HEAP32[$1 + 48 >> 2]);
       break block6;
      }
      $4 = HEAP32[$0 + 4 >> 2];
      $6 = HEAP32[($4 + ($3 << 2) | 0) + 608 >> 2];
      $1 = HEAP32[$5 + 176 >> 2];
      wasm2js_memory_fill($5 + 8 | 0, 0, 168);
      HEAP32[$5 + 8 >> 2] = $1;
      HEAP32[$5 >> 2] = $3;
      HEAP32[$5 + 4 >> 2] = $2;
      block19 : {
       block18 : {
        block16 : {
         if (($3 | 0) != 2) {
          break block16
         }
         $3 = HEAP32[$4 + 56 >> 2];
         $2 = $5 + 16 | 0;
         $4 = HEAP32[1641] >>> 3 | 0;
         if (!FLAC__bitreader_read_byte_block_aligned_no_crc($3, $2, $4)) {
          break block
         }
         if ($1 >>> 0 < $4 >>> 0) {
          HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
          $1 = 0;
          break block1;
         }
         $1 = $1 - $4 | 0;
         $4 = HEAP32[$0 + 4 >> 2];
         if (!HEAP32[$4 + 1124 >> 2]) {
          break block16
         }
         $3 = HEAP32[$0 + 4 >> 2];
         $8 = HEAP32[$3 + 1124 >> 2];
         $7 = 0;
         __inlined_func$has_id_filtered_$46 : {
          if (!$8) {
           break __inlined_func$has_id_filtered_$46
          }
          $7 = HEAP32[1641] >>> 3 | 0;
          $9 = HEAP32[$3 + 1120 >> 2];
          $3 = 0;
          block12 : {
           while (1) {
            if (!memcmp(Math_imul($3, $7) + $9 | 0, $2, $7)) {
             break block12
            }
            $3 = $3 + 1 | 0;
            if (($8 | 0) != ($3 | 0)) {
             continue
            }
            break;
           };
           $7 = 0;
           break __inlined_func$has_id_filtered_$46;
          }
          $7 = 1;
         }
         if (!$7 ^ ($6 | 0) != 0) {
          break block18
         }
         break block19;
        }
        if ($6) {
         break block19
        }
       }
       if (FLAC__bitreader_skip_byte_block_aligned_no_crc(HEAP32[$4 + 56 >> 2], $1)) {
        break block6
       }
       break block;
      }
      block27 : {
       block20 : {
        block28 : {
         block26 : {
          switch (HEAP32[$5 + 180 >> 2]) {
          case 1:
           if (FLAC__bitreader_skip_byte_block_aligned_no_crc(HEAP32[$4 + 56 >> 2], $1)) {
            break block20
           }
           $4 = 1;
           break block27;
          case 2:
           if (!$1) {
            break block28
           }
           $2 = emscripten_builtin_malloc($1);
           HEAP32[$5 + 20 >> 2] = $2;
           if (!$2) {
            HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
            $4 = 1;
            break block27;
           }
           if (FLAC__bitreader_read_byte_block_aligned_no_crc(HEAP32[$4 + 56 >> 2], $2, $1)) {
            break block20
           }
           $4 = 1;
           break block27;
          case 4:
           $2 = $5 + 16 | 0;
           $4 = 0;
           __inlined_func$read_metadata_vorbiscomment_$47 : {
            folding_inner0 : {
             block9 : {
              block7 : {
               block14 : {
                block5 : {
                 if ($1 >>> 0 < 8) {
                  break block5
                 }
                 if (!FLAC__bitreader_read_uint32_little_endian(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $2)) {
                  break block14
                 }
                 $1 = $1 - 8 | 0;
                 $3 = HEAP32[$2 >> 2];
                 block56 : {
                  if ($3) {
                   if ($1 >>> 0 < $3 >>> 0) {
                    HEAP32[$2 >> 2] = 0;
                    HEAP32[$2 + 4 >> 2] = 0;
                    break block5;
                   }
                   $6 = emscripten_builtin_malloc($3 + 1 | 0);
                   HEAP32[$2 + 4 >> 2] = $6;
                   if (!$6) {
                    break folding_inner0
                   }
                   if (!FLAC__bitreader_read_byte_block_aligned_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $6, $3)) {
                    break block14
                   }
                   $1 = $1 - $3 | 0;
                   HEAP8[HEAP32[$2 + 4 >> 2] + HEAP32[$2 >> 2] | 0] = 0;
                   break block56;
                  }
                  HEAP32[$2 + 4 >> 2] = 0;
                 }
                 $3 = $2 + 8 | 0;
                 if (!FLAC__bitreader_read_uint32_little_endian(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $3)) {
                  break block14
                 }
                 $4 = HEAP32[$3 >> 2];
                 if ($4 >>> 0 >= 100001) {
                  HEAP32[$3 >> 2] = 0;
                  $4 = 0;
                  break __inlined_func$read_metadata_vorbiscomment_$47;
                 }
                 if (!$4) {
                  break block5
                 }
                 $4 = safe_malloc_mul_2op_p($4, 8);
                 HEAP32[$2 + 12 >> 2] = $4;
                 if (!$4) {
                  break block7
                 }
                 if (!HEAP32[$3 >> 2]) {
                  break block5
                 }
                 $4 = 0;
                 while (1) {
                  $8 = $4 << 3;
                  $6 = $8 + HEAP32[$2 + 12 >> 2] | 0;
                  HEAP32[$6 >> 2] = 0;
                  HEAP32[$6 + 4 >> 2] = 0;
                  if ($1 >>> 0 <= 3) {
                   HEAP32[$3 >> 2] = $4;
                   break block5;
                  }
                  if (!FLAC__bitreader_read_uint32_little_endian(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $6)) {
                   break block9
                  }
                  $1 = $1 - 4 | 0;
                  $7 = HEAP32[$2 + 12 >> 2] + $8 | 0;
                  $6 = HEAP32[$7 >> 2];
                  block15 : {
                   if ($6) {
                    if ($1 >>> 0 < $6 >>> 0) {
                     HEAP32[$3 >> 2] = $4;
                     break block5;
                    }
                    $9 = emscripten_builtin_malloc($6 + 1 | 0);
                    HEAP32[$7 + 4 >> 2] = $9;
                    if (!$9) {
                     HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
                     break block9;
                    }
                    if ($6) {
                     wasm2js_memory_fill($9, 0, $6)
                    }
                    $1 = $1 - $6 | 0;
                    $7 = FLAC__bitreader_read_byte_block_aligned_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], HEAP32[$7 + 4 >> 2], HEAP32[$7 >> 2]);
                    $6 = HEAP32[$2 + 12 >> 2];
                    if (!$7) {
                     $3 = $4 << 3;
                     emscripten_builtin_free(HEAP32[($3 + $6 | 0) + 4 >> 2]);
                     HEAP32[($3 + HEAP32[$2 + 12 >> 2] | 0) + 4 >> 2] = 0;
                     HEAP32[$2 + 8 >> 2] = $4;
                     break block5;
                    }
                    $6 = $6 + $8 | 0;
                    HEAP8[HEAP32[$6 + 4 >> 2] + HEAP32[$6 >> 2] | 0] = 0;
                    break block15;
                   }
                   HEAP32[$7 + 4 >> 2] = 0;
                  }
                  $4 = $4 + 1 | 0;
                  if ($4 >>> 0 < HEAPU32[$3 >> 2]) {
                   continue
                  }
                  break;
                 };
                }
                block168 : {
                 if (!$1) {
                  break block168
                 }
                 if (!HEAP32[$2 + 8 >> 2]) {
                  emscripten_builtin_free(HEAP32[$2 + 12 >> 2]);
                  HEAP32[$2 + 12 >> 2] = 0;
                 }
                 if (FLAC__bitreader_skip_byte_block_aligned_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $1)) {
                  break block168
                 }
                 $4 = 0;
                 break __inlined_func$read_metadata_vorbiscomment_$47;
                }
                $4 = 1;
               }
               break __inlined_func$read_metadata_vorbiscomment_$47;
              }
              HEAP32[$3 >> 2] = 0;
              break folding_inner0;
             }
             HEAP32[$3 >> 2] = $4;
             $4 = 0;
             break __inlined_func$read_metadata_vorbiscomment_$47;
            }
            HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
            $4 = 0;
           }
           if ($4) {
            break block20
           }
           $4 = 1;
           break block27;
          case 5:
           $3 = 0;
           $6 = 0;
           $1 = __stack_pointer - 16 | 0;
           __stack_pointer = $1;
           $4 = $5 + 16 | 0;
           wasm2js_memory_fill($4, 0, 160);
           block110 : {
            if (!FLAC__bitreader_read_byte_block_aligned_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $4, HEAP32[1655] >>> 3 | 0)) {
             break block110
            }
            if (!FLAC__bitreader_read_raw_uint64(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $4 + 136 | 0, HEAP32[1656])) {
             break block110
            }
            $2 = $1 + 12 | 0;
            if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $2, HEAP32[1657])) {
             break block110
            }
            HEAP32[$4 + 144 >> 2] = HEAP32[$1 + 12 >> 2] != 0;
            if (!FLAC__bitreader_skip_bits_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], HEAP32[1658])) {
             break block110
            }
            if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $2, HEAP32[1659])) {
             break block110
            }
            $2 = HEAP32[$1 + 12 >> 2];
            HEAP32[$4 + 148 >> 2] = $2;
            if (!$2) {
             $3 = 1;
             break block110;
            }
            $2 = emscripten_builtin_calloc($2, 32);
            HEAP32[$4 + 152 >> 2] = $2;
            block411 : {
             block312 : {
              if (!$2) {
               break block312
              }
              $9 = HEAP32[1650] >>> 3 | 0;
              $10 = HEAP32[1647];
              $11 = HEAP32[1646];
              $12 = HEAP32[1645];
              $13 = HEAP32[1654];
              $15 = HEAP32[1653];
              $16 = HEAP32[1652];
              $17 = HEAP32[1651];
              $18 = HEAP32[1649];
              $19 = HEAP32[1648];
              while (1) {
               $2 = HEAP32[$4 + 152 >> 2] + ($6 << 5) | 0;
               if (!FLAC__bitreader_read_raw_uint64(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $2, $19)) {
                break block411
               }
               $3 = $1 + 12 | 0;
               if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $3, $18)) {
                break block411
               }
               HEAP8[$2 + 8 | 0] = HEAP32[$1 + 12 >> 2];
               if (!FLAC__bitreader_read_byte_block_aligned_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $2 + 9 | 0, $9)) {
                break block411
               }
               if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $3, $17)) {
                break block411
               }
               HEAP8[$2 + 22 | 0] = HEAPU8[$2 + 22 | 0] & 254 | HEAP8[$1 + 12 | 0] & 1;
               if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $3, $16)) {
                break block411
               }
               HEAP8[$2 + 22 | 0] = HEAPU8[$1 + 12 | 0] << 1 & 2 | HEAPU8[$2 + 22 | 0] & 253;
               if (!FLAC__bitreader_skip_bits_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $15)) {
                break block411
               }
               if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $3, $13)) {
                break block411
               }
               $3 = HEAP32[$1 + 12 >> 2];
               HEAP8[$2 + 23 | 0] = $3;
               $8 = $3 & 255;
               block513 : {
                if (!$8) {
                 break block513
                }
                $3 = emscripten_builtin_calloc($8, 16);
                HEAP32[$2 + 24 >> 2] = $3;
                if (!$3) {
                 break block312
                }
                $3 = 0;
                $7 = 0;
                if (!$8) {
                 break block513
                }
                while (1) {
                 $8 = HEAP32[$2 + 24 >> 2] + ($7 << 4) | 0;
                 if (!FLAC__bitreader_read_raw_uint64(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $8, $12)) {
                  break block110
                 }
                 if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $1 + 12 | 0, $11)) {
                  break block110
                 }
                 HEAP8[$8 + 8 | 0] = HEAP32[$1 + 12 >> 2];
                 if (!FLAC__bitreader_skip_bits_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $10)) {
                  break block110
                 }
                 $7 = $7 + 1 | 0;
                 if ($7 >>> 0 < HEAPU8[$2 + 23 | 0]) {
                  continue
                 }
                 break;
                };
               }
               $3 = 1;
               $6 = $6 + 1 | 0;
               if ($6 >>> 0 < HEAPU32[$4 + 148 >> 2]) {
                continue
               }
               break;
              };
              break block110;
             }
             HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
            }
            $3 = 0;
           }
           __stack_pointer = $1 + 16 | 0;
           if ($3) {
            break block20
           }
           $4 = 1;
           break block27;
          case 6:
           $1 = $5 + 16 | 0;
           $6 = 0;
           $4 = __stack_pointer - 16 | 0;
           __stack_pointer = $4;
           $2 = $4 + 12 | 0;
           block17 : {
            if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $2, HEAP32[1660])) {
             break block17
            }
            HEAP32[$1 >> 2] = HEAP32[$4 + 12 >> 2];
            if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $2, HEAP32[1661])) {
             break block17
            }
            block318 : {
             $3 = HEAP32[$4 + 12 >> 2];
             block219 : {
              if (($3 | 0) == -1) {
               HEAP32[$1 + 4 >> 2] = 0;
               break block219;
              }
              $2 = emscripten_builtin_malloc($3 + 1 | 0);
              HEAP32[$1 + 4 >> 2] = $2;
              if ($2) {
               break block318
              }
             }
             HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
             break block17;
            }
            if ($3) {
             if (!FLAC__bitreader_read_byte_block_aligned_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $2, $3)) {
              break block17
             }
             $2 = HEAP32[$1 + 4 >> 2];
             $3 = HEAP32[$4 + 12 >> 2];
            } else {
             $3 = 0
            }
            HEAP8[$3 + $2 | 0] = 0;
            if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $4 + 12 | 0, HEAP32[1662])) {
             break block17
            }
            block920 : {
             $3 = HEAP32[$4 + 12 >> 2];
             block8 : {
              if (($3 | 0) == -1) {
               HEAP32[$1 + 8 >> 2] = 0;
               break block8;
              }
              $2 = emscripten_builtin_malloc($3 + 1 | 0);
              HEAP32[$1 + 8 >> 2] = $2;
              if ($2) {
               break block920
              }
             }
             HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
             break block17;
            }
            if ($3) {
             if (!FLAC__bitreader_read_byte_block_aligned_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $2, $3)) {
              break block17
             }
             $2 = HEAP32[$1 + 8 >> 2];
             $3 = HEAP32[$4 + 12 >> 2];
            } else {
             $3 = 0
            }
            HEAP8[$3 + $2 | 0] = 0;
            if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $1 + 12 | 0, HEAP32[1663])) {
             break block17
            }
            if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $1 + 16 | 0, HEAP32[1664])) {
             break block17
            }
            if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $1 + 20 | 0, HEAP32[1665])) {
             break block17
            }
            if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $1 + 24 | 0, HEAP32[1666])) {
             break block17
            }
            if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $1 + 28 | 0, HEAP32[1667])) {
             break block17
            }
            $3 = $1;
            $1 = HEAP32[$1 + 28 >> 2];
            $2 = emscripten_builtin_malloc($1 >>> 0 <= 1 ? 1 : $1);
            HEAP32[$3 + 32 >> 2] = $2;
            if (!$2) {
             HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
             break block17;
            }
            if ($1) {
             if (!FLAC__bitreader_read_byte_block_aligned_no_crc(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $2, $1)) {
              break block17
             }
            }
            $6 = 1;
           }
           __stack_pointer = $4 + 16 | 0;
           if ($6) {
            break block20
           }
           $4 = 1;
           break block27;
          case 0:
          case 3:
           break block20;
          default:
           break block26;
          };
         }
         block31 : {
          if ($1) {
           $2 = emscripten_builtin_malloc($1);
           HEAP32[$5 + 16 >> 2] = $2;
           if ($2) {
            break block31
           }
           HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
           $4 = 1;
           break block27;
          }
          HEAP32[$5 + 16 >> 2] = 0;
          break block20;
         }
         if (FLAC__bitreader_read_byte_block_aligned_no_crc(HEAP32[$4 + 56 >> 2], $2, $1)) {
          break block20
         }
         $4 = 1;
         break block27;
        }
        HEAP32[$5 + 20 >> 2] = 0;
       }
       $4 = 0;
       $1 = HEAP32[$0 + 4 >> 2];
       if (HEAP32[$1 + 3632 >> 2]) {
        break block27
       }
       $2 = HEAP32[$1 + 28 >> 2];
       if (!$2) {
        break block27
       }
       FUNCTION_TABLE[$2 | 0]($0, $5, HEAP32[$1 + 48 >> 2]);
      }
      block32 : {
       block38 : {
        block34 : {
         switch (HEAP32[$5 + 180 >> 2] - 1 | 0) {
         case 1:
          $1 = HEAP32[$5 + 20 >> 2];
          if ($1) {
           break block38
          }
          break block32;
         case 3:
          $1 = HEAP32[$5 + 20 >> 2];
          if ($1) {
           emscripten_builtin_free($1)
          }
          $2 = HEAP32[$5 + 24 >> 2];
          if ($2) {
           $1 = 0;
           while (1) {
            $3 = HEAP32[(HEAP32[$5 + 28 >> 2] + ($1 << 3) | 0) + 4 >> 2];
            if ($3) {
             emscripten_builtin_free($3);
             $2 = HEAP32[$5 + 24 >> 2];
            }
            $1 = $1 + 1 | 0;
            if ($2 >>> 0 > $1 >>> 0) {
             continue
            }
            break;
           };
          }
          $1 = HEAP32[$5 + 28 >> 2];
          if ($1) {
           break block38
          }
          break block32;
         case 4:
          $2 = HEAP32[$5 + 164 >> 2];
          if ($2) {
           $1 = 0;
           while (1) {
            $3 = HEAP32[(HEAP32[$5 + 168 >> 2] + ($1 << 5) | 0) + 24 >> 2];
            if ($3) {
             emscripten_builtin_free($3);
             $2 = HEAP32[$5 + 164 >> 2];
            }
            $1 = $1 + 1 | 0;
            if ($2 >>> 0 > $1 >>> 0) {
             continue
            }
            break;
           };
          }
          $1 = HEAP32[$5 + 168 >> 2];
          if ($1) {
           break block38
          }
          break block32;
         case 5:
          $1 = HEAP32[$5 + 20 >> 2];
          if ($1) {
           emscripten_builtin_free($1)
          }
          $1 = HEAP32[$5 + 24 >> 2];
          if ($1) {
           emscripten_builtin_free($1)
          }
          $1 = HEAP32[$5 + 48 >> 2];
          if ($1) {
           break block38
          }
          break block32;
         case 0:
          break block32;
         default:
          break block34;
         };
        }
        $1 = HEAP32[$5 + 16 >> 2];
        if (!$1) {
         break block32
        }
       }
       emscripten_builtin_free($1);
      }
      if ($4) {
       break block
      }
     }
     $1 = 1;
     if (!$14) {
      break block1
     }
     block47 : {
      block46 : {
       $4 = HEAP32[$0 + 4 >> 2];
       if (HEAP32[$4 >> 2]) {
        break block46
       }
       $3 = HEAP32[$4 + 12 >> 2];
       if (!$3) {
        break block46
       }
       $2 = $4 + 6136 | 0;
       $3 = FUNCTION_TABLE[$3 | 0]($0, $2, HEAP32[$4 + 48 >> 2]) | 0;
       $4 = HEAP32[$0 + 4 >> 2];
       if ($3) {
        break block46
       }
       $3 = FLAC__bitreader_is_consumed_byte_aligned(HEAP32[$4 + 56 >> 2]);
       $4 = HEAP32[$0 + 4 >> 2];
       if (!$3) {
        break block46
       }
       $4 = HEAP32[$4 + 56 >> 2];
       $4 = ((HEAP32[$4 + 8 >> 2] - HEAP32[$4 + 16 >> 2] << 5) + (HEAP32[$4 + 12 >> 2] << 3) | 0) - HEAP32[$4 + 20 >> 2] >>> 3 | 0;
       $3 = HEAP32[$2 >> 2];
       $6 = HEAP32[$2 + 4 >> 2] - ($4 >>> 0 > $3 >>> 0) | 0;
       HEAP32[$2 >> 2] = $3 - $4;
       HEAP32[$2 + 4 >> 2] = $6;
       break block47;
      }
      HEAP32[$4 + 6136 >> 2] = 0;
      HEAP32[$4 + 6140 >> 2] = 0;
     }
     HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
     break block1;
    }
    $1 = 0;
    break block1;
   }
   HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
   $1 = 0;
  }
  __stack_pointer = $5 + 192 | 0;
  return $1;
 }
 
 function frame_sync_($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  $4 = HEAP32[$0 + 4 >> 2];
  block3 : {
   block1 : {
    block : {
     if (!HEAP32[$4 + 248 >> 2]) {
      break block
     }
     $2 = HEAP32[$4 + 308 >> 2];
     $1 = HEAP32[$4 + 304 >> 2];
     if (!($2 | $1)) {
      break block
     }
     $6 = HEAP32[$4 + 244 >> 2];
     $5 = 4;
     if (($2 | 0) == ($6 | 0) & HEAPU32[$4 + 240 >> 2] >= $1 >>> 0 | $2 >>> 0 < $6 >>> 0) {
      break block1
     }
    }
    block2 : {
     if (FLAC__bitreader_is_consumed_byte_aligned(HEAP32[$4 + 56 >> 2])) {
      break block2
     }
     $1 = HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2];
     if (FLAC__bitreader_read_raw_uint32($1, $3 + 12 | 0, FLAC__bitreader_bits_left_for_byte_alignment($1))) {
      break block2
     }
     $2 = 0;
     break block3;
    }
    $1 = HEAP32[$0 + 4 >> 2];
    block5 : {
     if (HEAP32[$1 + 3520 >> 2]) {
      $2 = HEAPU8[$1 + 3590 | 0];
      HEAP32[$3 + 12 >> 2] = $2;
      HEAP32[$1 + 3520 >> 2] = 0;
      break block5;
     }
     $2 = 0;
     if (!FLAC__bitreader_read_raw_uint32(HEAP32[$1 + 56 >> 2], $3 + 12 | 0, 8)) {
      break block3
     }
     $2 = HEAP32[$3 + 12 >> 2];
    }
    block10 : {
     block7 : {
      if (($2 | 0) != 255) {
       break block7
      }
      HEAP8[HEAP32[$0 + 4 >> 2] + 3588 | 0] = 255;
      $2 = 0;
      if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $3 + 12 | 0, 8)) {
       break block3
      }
      $1 = HEAP32[$3 + 12 >> 2];
      if (($1 | 0) != 255) {
       if (($1 & -2) != 248) {
        break block7
       }
       break block10;
      }
      $1 = HEAP32[$0 + 4 >> 2];
      HEAP32[$1 + 3520 >> 2] = 1;
      HEAP8[$1 + 3590 | 0] = 255;
     }
     $1 = HEAP32[$0 + 4 >> 2];
     if (!HEAP32[$1 + 3632 >> 2]) {
      FUNCTION_TABLE[HEAP32[$1 + 32 >> 2]]($0, 0, HEAP32[$1 + 48 >> 2])
     }
     while (1) {
      $1 = HEAP32[$0 + 4 >> 2];
      block13 : {
       if (HEAP32[$1 + 3520 >> 2]) {
        $2 = HEAPU8[$1 + 3590 | 0];
        HEAP32[$3 + 12 >> 2] = $2;
        HEAP32[$1 + 3520 >> 2] = 0;
        break block13;
       }
       $2 = 0;
       if (!FLAC__bitreader_read_raw_uint32(HEAP32[$1 + 56 >> 2], $3 + 12 | 0, 8)) {
        break block3
       }
       $2 = HEAP32[$3 + 12 >> 2];
      }
      if (($2 | 0) != 255) {
       continue
      }
      HEAP8[HEAP32[$0 + 4 >> 2] + 3588 | 0] = 255;
      $2 = 0;
      if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $3 + 12 | 0, 8)) {
       break block3
      }
      $1 = HEAP32[$3 + 12 >> 2];
      if (($1 | 0) == 255) {
       $1 = HEAP32[$0 + 4 >> 2];
       HEAP32[$1 + 3520 >> 2] = 1;
       HEAP8[$1 + 3590 | 0] = 255;
       continue;
      }
      if (($1 & -2) != 248) {
       continue
      }
      break;
     };
    }
    HEAP8[HEAP32[$0 + 4 >> 2] + 3589 | 0] = $1;
    $5 = 3;
   }
   $2 = $5;
   HEAP32[HEAP32[$0 >> 2] >> 2] = $2;
   $2 = 1;
  }
  $1 = $2;
  __stack_pointer = $3 + 16 | 0;
  return $1;
 }
 
 function read_frame_($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
  $6 = __stack_pointer - 48 | 0;
  __stack_pointer = $6;
  HEAP32[$1 >> 2] = 0;
  $5 = HEAP32[$0 + 4 >> 2];
  $4 = HEAPU16[(HEAPU8[$5 + 3588 | 0] << 1) + 1280 >> 1];
  $3 = HEAP32[$5 + 56 >> 2];
  HEAP32[$3 + 24 >> 2] = HEAPU16[((HEAPU8[$5 + 3589 | 0] ^ $4 >>> 8) << 1) + 1280 >> 1] ^ $4 << 8 & 65280;
  $5 = HEAP32[$3 + 20 >> 2];
  HEAP32[$3 + 28 >> 2] = HEAP32[$3 + 16 >> 2];
  HEAP32[$3 + 32 >> 2] = $5;
  $3 = HEAP32[$0 + 4 >> 2];
  HEAP8[$6 + 16 | 0] = HEAPU8[$3 + 3588 | 0];
  $5 = HEAPU8[$3 + 3589 | 0];
  HEAP32[$6 + 12 >> 2] = 2;
  HEAP8[$6 + 17 | 0] = $5;
  $12 = HEAP32[$3 + 56 >> 2];
  $3 = $6 + 44 | 0;
  block : {
   if (!FLAC__bitreader_read_raw_uint32($12, $3, 8)) {
    break block
   }
   block26 : {
    block1 : {
     $4 = HEAP32[$6 + 44 >> 2];
     if (($4 | 0) == 255) {
      break block1
     }
     HEAP8[$6 + 18 | 0] = $4;
     HEAP32[$6 + 12 >> 2] = 3;
     if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $3, 8)) {
      break block
     }
     $3 = HEAP32[$6 + 44 >> 2];
     if (($3 | 0) == 255) {
      break block1
     }
     $5 = $5 >>> 1 & 1;
     $4 = HEAP32[$6 + 12 >> 2];
     HEAP8[$4 + ($6 + 16 | 0) | 0] = $3;
     $3 = 1;
     HEAP32[$6 + 12 >> 2] = $4 + 1;
     block2 : {
      block5 : {
       block7 : {
        block6 : {
         block4 : {
          block3 : {
           $4 = HEAPU8[$6 + 18 | 0];
           $8 = $4 >>> 4 | 0;
           switch ($8 - 1 | 0) {
           case 0:
            break block3;
           case 1:
           case 2:
           case 3:
           case 4:
            break block4;
           case 5:
           case 6:
            break block5;
           case 7:
           case 8:
           case 9:
           case 10:
           case 11:
           case 12:
           case 13:
           case 14:
            break block6;
           default:
            break block2;
           };
          }
          HEAP32[HEAP32[$0 + 4 >> 2] + 1136 >> 2] = 192;
          break block7;
         }
         HEAP32[HEAP32[$0 + 4 >> 2] + 1136 >> 2] = 144 << $8;
         break block7;
        }
        HEAP32[HEAP32[$0 + 4 >> 2] + 1136 >> 2] = 1 << $8;
       }
       $8 = 0;
      }
      $3 = $5;
     }
     $7 = $4 & 15;
     HEAP32[$6 + 44 >> 2] = $7;
     block20 : {
      block23 : {
       block24 : {
        block22 : {
         block21 : {
          switch ($7 - 1 | 0) {
          default:
           $2 = HEAP32[$0 + 4 >> 2];
           if (HEAP32[$2 + 248 >> 2]) {
            break block22
           }
           $3 = 1;
           break block23;
          case 0:
           $2 = HEAP32[$0 + 4 >> 2];
           $5 = 88200;
           break block24;
          case 1:
           $2 = HEAP32[$0 + 4 >> 2];
           $5 = 176400;
           break block24;
          case 2:
           $2 = HEAP32[$0 + 4 >> 2];
           $5 = 192e3;
           break block24;
          case 3:
           $2 = HEAP32[$0 + 4 >> 2];
           $5 = 8e3;
           break block24;
          case 4:
           $2 = HEAP32[$0 + 4 >> 2];
           $5 = 16e3;
           break block24;
          case 5:
           $2 = HEAP32[$0 + 4 >> 2];
           $5 = 22050;
           break block24;
          case 6:
           $2 = HEAP32[$0 + 4 >> 2];
           $5 = 24e3;
           break block24;
          case 7:
           $2 = HEAP32[$0 + 4 >> 2];
           $5 = 32e3;
           break block24;
          case 8:
           $2 = HEAP32[$0 + 4 >> 2];
           $5 = 44100;
           break block24;
          case 9:
           $2 = HEAP32[$0 + 4 >> 2];
           $5 = 48e3;
           break block24;
          case 10:
           $2 = HEAP32[$0 + 4 >> 2];
           $5 = 96e3;
           break block24;
          case 11:
          case 12:
          case 13:
           break block20;
          case 14:
           break block21;
          };
         }
         $3 = HEAP32[$0 + 4 >> 2];
         if (!HEAP32[$3 + 3632 >> 2]) {
          FUNCTION_TABLE[HEAP32[$3 + 32 >> 2]]($0, 1, HEAP32[$3 + 48 >> 2])
         }
         $2 = HEAP32[$0 >> 2];
         HEAP32[$2 >> 2] = 2;
         break block26;
        }
        $5 = HEAP32[$2 + 288 >> 2];
       }
       HEAP32[$2 + 1140 >> 2] = $5;
      }
      $7 = 0;
     }
     $5 = HEAPU8[$6 + 19 | 0];
     $9 = $5 >>> 4 | 0;
     $15 = $5 << 24 >> 24;
     block31 : {
      block28 : {
       if (($15 | 0) < 0) {
        $2 = HEAP32[$0 + 4 >> 2];
        HEAP32[$2 + 1144 >> 2] = 2;
        $4 = 1;
        $5 = 0;
        block30 : {
         switch ($9 & 7) {
         case 1:
          $4 = 2;
          break block28;
         case 0:
          break block28;
         case 2:
          break block30;
         default:
          break block31;
         };
        }
        $4 = 3;
        break block28;
       }
       $2 = HEAP32[$0 + 4 >> 2];
       HEAP32[$2 + 1144 >> 2] = $9 + 1;
       $4 = 0;
      }
      HEAP32[$2 + 1148 >> 2] = $4;
      $5 = !$3;
     }
     $9 = $15 >>> 1 & 7;
     HEAP32[$6 + 44 >> 2] = $9;
     $4 = 0;
     $3 = 8;
     block35 : {
      block33 : {
       block38 : {
        switch ($9 - 1 | 0) {
        default:
         if (!HEAP32[$2 + 248 >> 2]) {
          break block35
         }
         $3 = HEAP32[$2 + 296 >> 2];
         break block33;
        case 1:
         $3 = 12;
         break block33;
        case 3:
         $3 = 16;
         break block33;
        case 4:
         $3 = 20;
         break block33;
        case 0:
         break block33;
        case 2:
        case 6:
         break block35;
        case 5:
         break block38;
        };
       }
       $3 = 24;
      }
      HEAP32[$2 + 1152 >> 2] = $3;
      $4 = $5;
     }
     block43 : {
      if (!(!(HEAP8[$6 + 17 | 0] & 1) & (!HEAP32[$2 + 248 >> 2] | HEAP32[$2 + 272 >> 2] == HEAP32[$2 + 276 >> 2]))) {
       $13 = $6 + 32 | 0;
       $14 = $6 + 16 | 0;
       $11 = $6 + 12 | 0;
       $9 = __stack_pointer - 16 | 0;
       __stack_pointer = $9;
       $17 = HEAP32[$2 + 56 >> 2];
       block0 : {
        if (!FLAC__bitreader_read_raw_uint32($17, $9 + 12 | 0, 8)) {
         break block0
        }
        $3 = HEAP32[$9 + 12 >> 2];
        if ($14) {
         $5 = HEAP32[$11 >> 2];
         HEAP32[$11 >> 2] = $5 + 1;
         HEAP8[$5 + $14 | 0] = $3;
        }
        block101 : {
         block42 : {
          block93 : {
           if ($3 & 128) {
            if (!($3 & 32)) {
             $5 = $3 & 31;
             $2 = 1;
             break block42;
            }
            if (!($3 & 16)) {
             $5 = $3 & 15;
             $2 = 2;
             break block42;
            }
            if (!($3 & 8)) {
             $5 = $3 & 7;
             $2 = 3;
             break block42;
            }
            $2 = 4;
            if (!($3 & 4)) {
             $5 = $3 & 3;
             break block42;
            }
            $5 = $3 & 1;
            if (!($3 & 2)) {
             $2 = 5;
             break block42;
            }
            if (!$5) {
             break block93
            }
            $3 = -1;
            $5 = -1;
            break block101;
           }
           $5 = 0;
           break block101;
          }
          $2 = 6;
          $5 = 0;
         }
         $3 = $5;
         $5 = 0;
         if (!$14) {
          while (1) {
           if (!FLAC__bitreader_read_raw_uint32($17, $9 + 12 | 0, 8)) {
            break block0
           }
           $11 = HEAP32[$9 + 12 >> 2];
           if (($11 & 192) != 128) {
            $3 = -1;
            $5 = -1;
            break block101;
           }
           $5 = $5 << 6 | $3 >>> 26;
           $3 = $11 & 63 | $3 << 6;
           $2 = $2 - 1 | 0;
           if ($2) {
            continue
           }
           break block101;
          }
         }
         while (1) {
          if (!FLAC__bitreader_read_raw_uint32($17, $9 + 12 | 0, 8)) {
           break block0
          }
          $16 = HEAP32[$9 + 12 >> 2];
          $19 = HEAP32[$11 >> 2];
          HEAP32[$11 >> 2] = $19 + 1;
          HEAP8[$14 + $19 | 0] = $16;
          if (($16 & 192) != 128) {
           $3 = -1;
           $5 = -1;
           break block101;
          }
          $5 = $5 << 6 | $3 >>> 26;
          $3 = $16 & 63 | $3 << 6;
          $2 = $2 - 1 | 0;
          if ($2) {
           continue
          }
          break;
         };
        }
        HEAP32[$13 >> 2] = $3;
        HEAP32[$13 + 4 >> 2] = $5;
        $18 = 1;
       }
       __stack_pointer = $9 + 16 | 0;
       if (!$18) {
        break block
       }
       $5 = HEAP32[$6 + 32 >> 2];
       $2 = HEAP32[$6 + 36 >> 2];
       if (($5 & $2) == -1) {
        $5 = HEAPU8[($14 + HEAP32[$6 + 12 >> 2] | 0) - 1 | 0];
        $3 = HEAP32[$0 + 4 >> 2];
        HEAP32[$3 + 3520 >> 2] = 1;
        HEAP8[$3 + 3590 | 0] = $5;
        if (!HEAP32[$3 + 3632 >> 2]) {
         FUNCTION_TABLE[HEAP32[$3 + 32 >> 2]]($0, 1, HEAP32[$3 + 48 >> 2])
        }
        $2 = HEAP32[$0 >> 2];
        HEAP32[$2 >> 2] = 2;
        break block26;
       }
       $3 = HEAP32[$0 + 4 >> 2];
       HEAP32[$3 + 1160 >> 2] = $5;
       HEAP32[$3 + 1164 >> 2] = $2;
       HEAP32[$3 + 1156 >> 2] = 1;
       break block43;
      }
      $18 = $6 + 44 | 0;
      $14 = $6 + 16 | 0;
      $11 = $6 + 12 | 0;
      $9 = __stack_pointer - 16 | 0;
      __stack_pointer = $9;
      $13 = HEAP32[$2 + 56 >> 2];
      block25 : {
       if (!FLAC__bitreader_read_raw_uint32($13, $9 + 12 | 0, 8)) {
        break block25
       }
       $3 = HEAP32[$9 + 12 >> 2];
       if ($14) {
        $5 = HEAP32[$11 >> 2];
        HEAP32[$11 >> 2] = $5 + 1;
        HEAP8[$5 + $14 | 0] = $3;
       }
       block226 : {
        if (!($3 & 128)) {
         break block226
        }
        block427 : {
         if (!($3 & 32)) {
          $5 = 1;
          $2 = 31;
          break block427;
         }
         if (!($3 & 16)) {
          $5 = 2;
          $2 = 15;
          break block427;
         }
         if (!($3 & 8)) {
          $5 = 3;
          $2 = 7;
          break block427;
         }
         $5 = 4;
         $2 = 3;
         if (!($3 & 4)) {
          break block427
         }
         if ($3 & 2) {
          $3 = -1;
          break block226;
         }
         $5 = 5;
         $2 = 1;
        }
        $3 = $2 & $3;
        if (!$14) {
         while (1) {
          if (!FLAC__bitreader_read_raw_uint32($13, $9 + 12 | 0, 8)) {
           break block25
          }
          $2 = HEAP32[$9 + 12 >> 2];
          if (($2 & 192) != 128) {
           $3 = -1;
           break block226;
          }
          $3 = $2 & 63 | $3 << 6;
          $5 = $5 - 1 | 0;
          if ($5) {
           continue
          }
          break block226;
         }
        }
        while (1) {
         if (!FLAC__bitreader_read_raw_uint32($13, $9 + 12 | 0, 8)) {
          break block25
         }
         $2 = HEAP32[$9 + 12 >> 2];
         $17 = HEAP32[$11 >> 2];
         HEAP32[$11 >> 2] = $17 + 1;
         HEAP8[$14 + $17 | 0] = $2;
         if (($2 & 192) != 128) {
          $3 = -1;
          break block226;
         }
         $3 = $2 & 63 | $3 << 6;
         $5 = $5 - 1 | 0;
         if ($5) {
          continue
         }
         break;
        };
       }
       HEAP32[$18 >> 2] = $3;
       $16 = 1;
      }
      __stack_pointer = $9 + 16 | 0;
      if (!$16) {
       break block
      }
      $3 = HEAP32[$6 + 44 >> 2];
      if (($3 | 0) == -1) {
       $5 = HEAPU8[($14 + HEAP32[$6 + 12 >> 2] | 0) - 1 | 0];
       $3 = HEAP32[$0 + 4 >> 2];
       HEAP32[$3 + 3520 >> 2] = 1;
       HEAP8[$3 + 3590 | 0] = $5;
       if (!HEAP32[$3 + 3632 >> 2]) {
        FUNCTION_TABLE[HEAP32[$3 + 32 >> 2]]($0, 1, HEAP32[$3 + 48 >> 2])
       }
       $2 = HEAP32[$0 >> 2];
       HEAP32[$2 >> 2] = 2;
       break block26;
      }
      $5 = HEAP32[$0 + 4 >> 2];
      HEAP32[$5 + 1160 >> 2] = $3;
      HEAP32[$5 + 1156 >> 2] = 0;
     }
     $2 = HEAP32[$0 + 4 >> 2];
     if ($8) {
      if (!FLAC__bitreader_read_raw_uint32(HEAP32[$2 + 56 >> 2], $6 + 44 | 0, 8)) {
       break block
      }
      $5 = $6 + 16 | 0;
      $2 = HEAP32[$6 + 12 >> 2];
      $3 = HEAP32[$6 + 44 >> 2];
      HEAP8[$5 + $2 | 0] = $3;
      HEAP32[$6 + 12 >> 2] = $2 + 1;
      if (($8 | 0) == 7) {
       if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $6 + 8 | 0, 8)) {
        break block
       }
       $3 = HEAP32[$6 + 12 >> 2];
       $12 = $3 + $5 | 0;
       $5 = HEAP32[$6 + 8 >> 2];
       HEAP8[$12 | 0] = $5;
       HEAP32[$6 + 12 >> 2] = $3 + 1;
       $3 = $5 | HEAP32[$6 + 44 >> 2] << 8;
       HEAP32[$6 + 44 >> 2] = $3;
      }
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 1136 >> 2] = $3 + 1;
     }
     if ($7) {
      if (!FLAC__bitreader_read_raw_uint32(HEAP32[$2 + 56 >> 2], $6 + 44 | 0, 8)) {
       break block
      }
      $3 = $6 + 16 | 0;
      $5 = HEAP32[$6 + 12 >> 2];
      $8 = HEAP32[$6 + 44 >> 2];
      HEAP8[$3 + $5 | 0] = $8;
      HEAP32[$6 + 12 >> 2] = $5 + 1;
      block50 : {
       block51 : {
        block49 : {
         if (($7 | 0) == 12) {
          break block49
         }
         if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $6 + 8 | 0, 8)) {
          break block
         }
         $5 = HEAP32[$6 + 12 >> 2];
         $12 = $3 + $5 | 0;
         $3 = HEAP32[$6 + 8 >> 2];
         HEAP8[$12 | 0] = $3;
         HEAP32[$6 + 12 >> 2] = $5 + 1;
         $8 = $3 | HEAP32[$6 + 44 >> 2] << 8;
         HEAP32[$6 + 44 >> 2] = $8;
         switch ($7 - 12 | 0) {
         case 0:
          break block49;
         case 1:
          break block50;
         default:
          break block51;
         };
        }
        $8 = Math_imul($8, 1e3);
        break block50;
       }
       $8 = Math_imul($8, 10);
      }
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 1140 >> 2] = $8;
     }
     if (!FLAC__bitreader_read_raw_uint32(HEAP32[$2 + 56 >> 2], $6 + 44 | 0, 8)) {
      break block
     }
     $3 = HEAPU8[$6 + 44 | 0];
     $5 = FLAC__crc8($6 + 16 | 0, HEAP32[$6 + 12 >> 2]);
     $2 = HEAP32[$0 + 4 >> 2];
     if (($3 | 0) != ($5 | 0)) {
      if (!HEAP32[$2 + 3632 >> 2]) {
       FUNCTION_TABLE[HEAP32[$2 + 32 >> 2]]($0, 1, HEAP32[$2 + 48 >> 2])
      }
      $2 = HEAP32[$0 >> 2];
      HEAP32[$2 >> 2] = 2;
      break block26;
     }
     HEAP32[$2 + 232 >> 2] = 0;
     block57 : {
      block54 : {
       if (HEAP32[$2 + 1156 >> 2]) {
        break block54
       }
       $3 = HEAP32[$2 + 1160 >> 2];
       HEAP32[$6 + 44 >> 2] = $3;
       HEAP32[$2 + 1156 >> 2] = 1;
       $5 = HEAP32[$2 + 228 >> 2];
       if ($5) {
        (wasm2js_i32$0 = $2, wasm2js_i32$1 = __wasm_i64_mul($5, 0, $3, 0)), HEAP32[wasm2js_i32$0 + 1160 >> 2] = wasm2js_i32$1;
        HEAP32[$2 + 1164 >> 2] = i64toi32_i32$HIGH_BITS;
        break block54;
       }
       if (HEAP32[$2 + 248 >> 2]) {
        $5 = HEAP32[$2 + 272 >> 2];
        if (($5 | 0) != HEAP32[$2 + 276 >> 2]) {
         break block57
        }
        (wasm2js_i32$0 = $2, wasm2js_i32$1 = __wasm_i64_mul($5, 0, $3, 0)), HEAP32[wasm2js_i32$0 + 1160 >> 2] = wasm2js_i32$1;
        HEAP32[$2 + 1164 >> 2] = i64toi32_i32$HIGH_BITS;
        $3 = HEAP32[$0 + 4 >> 2];
        HEAP32[$3 + 232 >> 2] = HEAP32[$3 + 276 >> 2];
        break block54;
       }
       if (!$3) {
        HEAP32[$2 + 1160 >> 2] = 0;
        HEAP32[$2 + 1164 >> 2] = 0;
        $3 = HEAP32[$0 + 4 >> 2];
        HEAP32[$3 + 232 >> 2] = HEAP32[$3 + 1136 >> 2];
        break block54;
       }
       (wasm2js_i32$0 = $2, wasm2js_i32$1 = __wasm_i64_mul(HEAP32[$2 + 1136 >> 2], 0, $3, 0)), HEAP32[wasm2js_i32$0 + 1160 >> 2] = wasm2js_i32$1;
       HEAP32[$2 + 1164 >> 2] = i64toi32_i32$HIGH_BITS;
      }
      if ($4 & !($15 & 1)) {
       $2 = HEAP32[$0 >> 2];
       break block26;
      }
      $2 = HEAP32[$0 + 4 >> 2];
     }
     block61 : {
      if (!HEAP32[$2 + 3632 >> 2]) {
       FUNCTION_TABLE[HEAP32[$2 + 32 >> 2]]($0, 3, HEAP32[$2 + 48 >> 2]);
       break block61;
      }
      HEAP32[$2 + 6152 >> 2] = HEAP32[$2 + 6152 >> 2] + 1;
     }
     $2 = HEAP32[$0 >> 2];
     HEAP32[$2 >> 2] = 2;
     break block26;
    }
    $3 = HEAP32[$0 + 4 >> 2];
    HEAP32[$3 + 3520 >> 2] = 1;
    HEAP8[$3 + 3590 | 0] = 255;
    if (!HEAP32[$3 + 3632 >> 2]) {
     FUNCTION_TABLE[HEAP32[$3 + 32 >> 2]]($0, 1, HEAP32[$3 + 48 >> 2])
    }
    $2 = HEAP32[$0 >> 2];
    HEAP32[$2 >> 2] = 2;
   }
   $10 = 1;
   if (HEAP32[$2 >> 2] == 2) {
    break block
   }
   $2 = HEAP32[$0 + 4 >> 2];
   $3 = HEAP32[$2 + 1144 >> 2];
   block82 : {
    $5 = HEAP32[$2 + 1136 >> 2];
    if (!($5 >>> 0 <= HEAPU32[$2 + 220 >> 2] & HEAPU32[$2 + 224 >> 2] >= $3 >>> 0)) {
     $4 = HEAP32[$2 + 60 >> 2];
     if ($4) {
      emscripten_builtin_free($4 - 16 | 0);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 60 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 3592 >> 2];
     if ($4) {
      emscripten_builtin_free($4);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 3592 >> 2] = 0;
      HEAP32[$2 + 92 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 64 >> 2];
     if ($4) {
      emscripten_builtin_free($4 - 16 | 0);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 64 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 3596 >> 2];
     if ($4) {
      emscripten_builtin_free($4);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 3596 >> 2] = 0;
      HEAP32[$2 + 96 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 68 >> 2];
     if ($4) {
      emscripten_builtin_free($4 - 16 | 0);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 68 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 3600 >> 2];
     if ($4) {
      emscripten_builtin_free($4);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 3600 >> 2] = 0;
      HEAP32[$2 + 100 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 72 >> 2];
     if ($4) {
      emscripten_builtin_free($4 - 16 | 0);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 72 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 3604 >> 2];
     if ($4) {
      emscripten_builtin_free($4);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 3604 >> 2] = 0;
      HEAP32[$2 + 104 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 76 >> 2];
     if ($4) {
      emscripten_builtin_free($4 - 16 | 0);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 76 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 3608 >> 2];
     if ($4) {
      emscripten_builtin_free($4);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 3608 >> 2] = 0;
      HEAP32[$2 + 108 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 80 >> 2];
     if ($4) {
      emscripten_builtin_free($4 - 16 | 0);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 80 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 3612 >> 2];
     if ($4) {
      emscripten_builtin_free($4);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 3612 >> 2] = 0;
      HEAP32[$2 + 112 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 84 >> 2];
     if ($4) {
      emscripten_builtin_free($4 - 16 | 0);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 84 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 3616 >> 2];
     if ($4) {
      emscripten_builtin_free($4);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 3616 >> 2] = 0;
      HEAP32[$2 + 116 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 88 >> 2];
     if ($4) {
      emscripten_builtin_free($4 - 16 | 0);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 88 >> 2] = 0;
     }
     $4 = HEAP32[$2 + 3620 >> 2];
     if ($4) {
      emscripten_builtin_free($4);
      $2 = HEAP32[$0 + 4 >> 2];
      HEAP32[$2 + 3620 >> 2] = 0;
      HEAP32[$2 + 120 >> 2] = 0;
     }
     if ($3) {
      if ($5 >>> 0 > 1073741819) {
       break block82
      }
      $8 = ($5 << 2) + 16 | 0;
      $7 = 0;
      block84 : {
       while (1) {
        $4 = emscripten_builtin_malloc($8);
        if (!$4) {
         break block82
        }
        HEAP32[$4 >> 2] = 0;
        HEAP32[$4 + 4 >> 2] = 0;
        $2 = $4 + 8 | 0;
        HEAP32[$2 >> 2] = 0;
        HEAP32[$2 + 4 >> 2] = 0;
        $2 = HEAP32[$0 + 4 >> 2] + ($7 << 2) | 0;
        HEAP32[$2 + 60 >> 2] = $4 + 16;
        if (FLAC__memory_alloc_aligned_int32_array($5, $2 + 3592 | 0, $2 + 92 | 0)) {
         $7 = $7 + 1 | 0;
         if (($7 | 0) == ($3 | 0)) {
          break block84
         }
         continue;
        }
        break;
       };
       HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
       $10 = 0;
       break block;
      }
      $2 = HEAP32[$0 + 4 >> 2];
     }
     HEAP32[$2 + 224 >> 2] = $3;
     HEAP32[$2 + 220 >> 2] = $5;
     $3 = HEAP32[$2 + 1144 >> 2];
    }
    block130 : {
     if ($3) {
      $18 = HEAP32[1689];
      $17 = -1 << $18;
      $16 = HEAP32[1683];
      $15 = HEAP32[1682];
      $19 = HEAP32[1690];
      $8 = 0;
      while (1) {
       $7 = HEAP32[$2 + 1152 >> 2];
       block89 : {
        block88 : {
         switch (HEAP32[$2 + 1148 >> 2] - 1 | 0) {
         case 0:
          $7 = (($8 | 0) == 1) + $7 | 0;
          break block89;
         case 1:
          $7 = !$8 + $7 | 0;
          break block89;
         case 2:
          break block88;
         default:
          break block89;
         };
        }
        $7 = (($8 | 0) == 1) + $7 | 0;
       }
       block112 : {
        block113 : {
         block98 : {
          block94 : {
           block10131 : {
            block90 : {
             if (!FLAC__bitreader_read_raw_uint32(HEAP32[$2 + 56 >> 2], $6 + 44 | 0, 8)) {
              break block90
             }
             $3 = HEAP32[$6 + 44 >> 2];
             HEAP32[$6 + 44 >> 2] = $3 & 254;
             $14 = $3 & 1;
             block92 : {
              if ($14) {
               if (!FLAC__bitreader_read_unary_unsigned(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $6 + 16 | 0)) {
                break block90
               }
               $2 = HEAP32[$0 + 4 >> 2];
               $3 = HEAP32[$6 + 16 >> 2] + 1 | 0;
               HEAP32[($2 + Math_imul($8, 292) | 0) + 1464 >> 2] = $3;
               if ($3 >>> 0 >= $7 >>> 0) {
                break block90
               }
               $7 = $7 - $3 | 0;
               break block92;
              }
              $2 = HEAP32[$0 + 4 >> 2];
              HEAP32[($2 + Math_imul($8, 292) | 0) + 1464 >> 2] = 0;
             }
             $3 = HEAP32[$6 + 44 >> 2];
             if ($3 & 128) {
              if (HEAP32[$2 + 3632 >> 2]) {
               break block94
              }
              FUNCTION_TABLE[HEAP32[$2 + 32 >> 2]]($0, 0, HEAP32[$2 + 48 >> 2]);
              break block94;
             }
             block96 : {
              switch ($3 | 0) {
              case 0:
               $3 = HEAP32[(($8 << 2) + $2 | 0) + 60 >> 2];
               $5 = Math_imul($8, 292) + $2 | 0;
               HEAP32[$5 + 1176 >> 2] = 0;
               if (!FLAC__bitreader_read_raw_int32(HEAP32[$2 + 56 >> 2], $6 + 16 | 0, $7)) {
                break block90
               }
               $12 = $5 + 1180 | 0;
               $5 = HEAP32[$6 + 16 >> 2];
               HEAP32[$12 >> 2] = $5;
               $2 = 0;
               $4 = HEAP32[$0 + 4 >> 2];
               if (!HEAP32[$4 + 1136 >> 2]) {
                break block98
               }
               while (1) {
                HEAP32[$3 + ($2 << 2) >> 2] = $5;
                $2 = $2 + 1 | 0;
                if ($2 >>> 0 < HEAPU32[$4 + 1136 >> 2]) {
                 continue
                }
                break;
               };
               break block98;
              case 2:
               $3 = Math_imul($8, 292) + $2 | 0;
               $5 = $3 + 1180 | 0;
               $4 = $8 << 2;
               $9 = HEAP32[($4 + $2 | 0) + 92 >> 2];
               HEAP32[$5 >> 2] = $9;
               HEAP32[$3 + 1176 >> 2] = 1;
               $10 = 0;
               if (HEAP32[$2 + 1136 >> 2]) {
                while (1) {
                 if (!FLAC__bitreader_read_raw_int32(HEAP32[$2 + 56 >> 2], $6 + 16 | 0, $7)) {
                  break block90
                 }
                 HEAP32[$9 + ($10 << 2) >> 2] = HEAP32[$6 + 16 >> 2];
                 $10 = $10 + 1 | 0;
                 $2 = HEAP32[$0 + 4 >> 2];
                 $3 = HEAP32[$2 + 1136 >> 2];
                 if ($10 >>> 0 < $3 >>> 0) {
                  continue
                 }
                 break;
                };
                $10 = $3 << 2;
               }
               if (!$10) {
                break block98
               }
               wasm2js_memory_copy(HEAP32[($2 + $4 | 0) + 60 >> 2], HEAP32[$5 >> 2], $10);
               break block98;
              default:
               break block96;
              };
             }
             if ($3 >>> 0 <= 15) {
              if (HEAP32[$2 + 3632 >> 2]) {
               break block10131
              }
              FUNCTION_TABLE[HEAP32[$2 + 32 >> 2]]($0, 3, HEAP32[$2 + 48 >> 2]);
              break block94;
             }
             if ($3 >>> 0 <= 24) {
              $5 = Math_imul($8, 292) + $2 | 0;
              HEAP32[$5 + 1176 >> 2] = 2;
              $10 = $8 << 2;
              $4 = HEAP32[($10 + $2 | 0) + 92 >> 2];
              $3 = $3 >>> 1 & 7;
              HEAP32[$5 + 1192 >> 2] = $3;
              HEAP32[$5 + 1212 >> 2] = $4;
              $5 = $5 + 1180 | 0;
              if ($3) {
               $4 = $5 + 16 | 0;
               $2 = 0;
               while (1) {
                if (!FLAC__bitreader_read_raw_int32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $6 + 16 | 0, $7)) {
                 break block90
                }
                HEAP32[$4 + ($2 << 2) >> 2] = HEAP32[$6 + 16 >> 2];
                $2 = $2 + 1 | 0;
                if (($3 | 0) != ($2 | 0)) {
                 continue
                }
                break;
               };
               $12 = HEAP32[$0 + 4 >> 2];
              } else {
               $12 = $2
              }
              $2 = $6 + 32 | 0;
              if (!FLAC__bitreader_read_raw_uint32(HEAP32[$12 + 56 >> 2], $2, $15)) {
               break block90
              }
              $7 = HEAP32[$6 + 32 >> 2];
              HEAP32[$5 >> 2] = $7;
              $4 = HEAP32[$0 + 4 >> 2];
              block107 : {
               block105 : {
                if ($7 >>> 0 <= 1) {
                 if (!FLAC__bitreader_read_raw_uint32(HEAP32[$4 + 56 >> 2], $2, $16)) {
                  break block90
                 }
                 $4 = HEAP32[$0 + 4 >> 2];
                 $2 = HEAP32[$6 + 32 >> 2];
                 if ($3 >>> 0 <= HEAP32[$4 + 1136 >> 2] >>> $2 >>> 0) {
                  break block105
                 }
                 if (!HEAP32[$4 + 3632 >> 2]) {
                  FUNCTION_TABLE[HEAP32[$4 + 32 >> 2]]($0, 0, HEAP32[$4 + 48 >> 2])
                 }
                 HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
                 break block107;
                }
                block109 : {
                 if (!HEAP32[$4 + 3632 >> 2]) {
                  FUNCTION_TABLE[HEAP32[$4 + 32 >> 2]]($0, 3, HEAP32[$4 + 48 >> 2]);
                  break block109;
                 }
                 HEAP32[$4 + 6152 >> 2] = HEAP32[$4 + 6152 >> 2] + 1;
                }
                HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
                break block107;
               }
               HEAP32[$5 + 4 >> 2] = $2;
               $4 = Math_imul($8, 12);
               HEAP32[$5 + 8 >> 2] = ($4 + HEAP32[$0 + 4 >> 2] | 0) + 124;
               $7 = HEAP32[$5 >> 2];
               if ($7 >>> 0 < 2) {
                $12 = $2;
                $2 = HEAP32[$0 + 4 >> 2];
                if (!read_residual_partitioned_rice_($0, $3, $12, ($4 + $2 | 0) + 124 | 0, HEAP32[($2 + $10 | 0) + 92 >> 2], ($7 | 0) == 1)) {
                 break block90
                }
               }
               $2 = $3 << 2;
               if ($2) {
                wasm2js_memory_copy(HEAP32[($10 + HEAP32[$0 + 4 >> 2] | 0) + 60 >> 2], $5 + 16 | 0, $2)
               }
               $5 = HEAP32[$0 + 4 >> 2];
               $10 = $5 + $10 | 0;
               $7 = HEAP32[$10 + 92 >> 2];
               $4 = HEAP32[$5 + 1136 >> 2] - $3 | 0;
               $5 = $2 + HEAP32[$10 + 60 >> 2] | 0;
               $10 = 0;
               __inlined_func$FLAC__fixed_restore_signal$54 : {
                block934 : {
                 block835 : {
                  block39 : {
                   switch ($3 | 0) {
                   case 4:
                    if (($4 | 0) <= 0) {
                     break __inlined_func$FLAC__fixed_restore_signal$54
                    }
                    $2 = HEAP32[$5 - 4 >> 2];
                    $3 = 0;
                    while (1) {
                     $9 = $3 << 2;
                     $10 = $9 + $5 | 0;
                     $2 = ((Math_imul(HEAP32[$10 - 8 >> 2], -6) + HEAP32[$7 + $9 >> 2] | 0) - HEAP32[$10 - 16 >> 2] | 0) + (HEAP32[$10 - 12 >> 2] + $2 << 2) | 0;
                     HEAP32[$10 >> 2] = $2;
                     $3 = $3 + 1 | 0;
                     if (($3 | 0) != ($4 | 0)) {
                      continue
                     }
                     break;
                    };
                    break __inlined_func$FLAC__fixed_restore_signal$54;
                   case 3:
                    if (($4 | 0) <= 0) {
                     break __inlined_func$FLAC__fixed_restore_signal$54
                    }
                    $10 = HEAP32[$5 - 4 >> 2];
                    $3 = 0;
                    if (($4 | 0) != 1) {
                     $12 = $4 & 2147483646;
                     $9 = 0;
                     while (1) {
                      $2 = $3 << 2;
                      $11 = $2 + $5 | 0;
                      $13 = HEAP32[$11 - 8 >> 2];
                      $10 = (HEAP32[$11 - 12 >> 2] + HEAP32[$2 + $7 >> 2] | 0) + Math_imul($10 - $13 | 0, 3) | 0;
                      HEAP32[$11 >> 2] = $10;
                      $2 = $2 | 4;
                      $11 = $2 + $5 | 0;
                      $10 = ($13 + HEAP32[$2 + $7 >> 2] | 0) + Math_imul($10 - HEAP32[$11 - 8 >> 2] | 0, 3) | 0;
                      HEAP32[$11 >> 2] = $10;
                      $3 = $3 + 2 | 0;
                      $9 = $9 + 2 | 0;
                      if (($12 | 0) != ($9 | 0)) {
                       continue
                      }
                      break;
                     };
                    }
                    if (!($4 & 1)) {
                     break __inlined_func$FLAC__fixed_restore_signal$54
                    }
                    $12 = $5;
                    $5 = $3 << 2;
                    $3 = $12 + $5 | 0;
                    HEAP32[$3 >> 2] = (HEAP32[$3 - 12 >> 2] + HEAP32[$5 + $7 >> 2] | 0) + Math_imul($10 - HEAP32[$3 - 8 >> 2] | 0, 3);
                    break __inlined_func$FLAC__fixed_restore_signal$54;
                   case 2:
                    if (($4 | 0) <= 0) {
                     break __inlined_func$FLAC__fixed_restore_signal$54
                    }
                    $2 = HEAP32[$5 - 4 >> 2];
                    $3 = 0;
                    if (($4 | 0) != 1) {
                     $11 = $4 & 2147483646;
                     while (1) {
                      $9 = $3 << 2;
                      $13 = $9 + $5 | 0;
                      $2 = (HEAP32[$7 + $9 >> 2] + ($2 << 1) | 0) - HEAP32[$13 - 8 >> 2] | 0;
                      HEAP32[$13 >> 2] = $2;
                      $9 = $9 | 4;
                      $13 = $9 + $5 | 0;
                      $2 = (HEAP32[$7 + $9 >> 2] + ($2 << 1) | 0) - HEAP32[$13 - 8 >> 2] | 0;
                      HEAP32[$13 >> 2] = $2;
                      $3 = $3 + 2 | 0;
                      $10 = $10 + 2 | 0;
                      if (($11 | 0) != ($10 | 0)) {
                       continue
                      }
                      break;
                     };
                    }
                    if (!($4 & 1)) {
                     break __inlined_func$FLAC__fixed_restore_signal$54
                    }
                    $3 = $3 << 2;
                    $5 = $3 + $5 | 0;
                    HEAP32[$5 >> 2] = (HEAP32[$3 + $7 >> 2] + ($2 << 1) | 0) - HEAP32[$5 - 8 >> 2];
                    break __inlined_func$FLAC__fixed_restore_signal$54;
                   case 1:
                    if (($4 | 0) <= 0) {
                     break __inlined_func$FLAC__fixed_restore_signal$54
                    }
                    $11 = $4 & 3;
                    $2 = HEAP32[$5 - 4 >> 2];
                    if ($4 >>> 0 >= 4) {
                     break block835
                    }
                    $3 = 0;
                    break block934;
                   case 0:
                    break block39;
                   default:
                    break __inlined_func$FLAC__fixed_restore_signal$54;
                   };
                  }
                  $3 = $4 << 2;
                  if (!$3) {
                   break __inlined_func$FLAC__fixed_restore_signal$54
                  }
                  wasm2js_memory_copy($5, $7, $3);
                  break __inlined_func$FLAC__fixed_restore_signal$54;
                 }
                 $13 = $4 & 2147483644;
                 $3 = 0;
                 $9 = 0;
                 while (1) {
                  $4 = $3 << 2;
                  $2 = $2 + HEAP32[$4 + $7 >> 2] | 0;
                  HEAP32[$4 + $5 >> 2] = $2;
                  $12 = $4 | 4;
                  $2 = $2 + HEAP32[$12 + $7 >> 2] | 0;
                  HEAP32[$5 + $12 >> 2] = $2;
                  $12 = $4 | 8;
                  $2 = $2 + HEAP32[$12 + $7 >> 2] | 0;
                  HEAP32[$5 + $12 >> 2] = $2;
                  $4 = $4 | 12;
                  $2 = $2 + HEAP32[$4 + $7 >> 2] | 0;
                  HEAP32[$4 + $5 >> 2] = $2;
                  $3 = $3 + 4 | 0;
                  $9 = $9 + 4 | 0;
                  if (($13 | 0) != ($9 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                if (!$11) {
                 break __inlined_func$FLAC__fixed_restore_signal$54
                }
                while (1) {
                 $4 = $3 << 2;
                 $2 = HEAP32[$4 + $7 >> 2] + $2 | 0;
                 HEAP32[$4 + $5 >> 2] = $2;
                 $3 = $3 + 1 | 0;
                 $10 = $10 + 1 | 0;
                 if (($11 | 0) != ($10 | 0)) {
                  continue
                 }
                 break;
                };
               }
              }
              if (!$14 | HEAP32[HEAP32[$0 >> 2] >> 2] == 2) {
               break block112
              }
              break block113;
             }
             if ($3 >>> 0 <= 63) {
              if (!HEAP32[$2 + 3632 >> 2]) {
               FUNCTION_TABLE[HEAP32[$2 + 32 >> 2]]($0, 3, HEAP32[$2 + 48 >> 2]);
               break block94;
              }
              HEAP32[$2 + 6152 >> 2] = HEAP32[$2 + 6152 >> 2] + 1;
              break block94;
             }
             $4 = Math_imul($8, 292) + $2 | 0;
             HEAP32[$4 + 1176 >> 2] = 3;
             $10 = $8 << 2;
             $2 = HEAP32[($10 + $2 | 0) + 92 >> 2];
             $11 = $3 >>> 1 & 31;
             $5 = $11 + 1 | 0;
             HEAP32[$4 + 1192 >> 2] = $5;
             HEAP32[$4 + 1460 >> 2] = $2;
             $13 = $4 + 1332 | 0;
             $3 = $4 + 1180 | 0;
             $2 = 0;
             while (1) {
              if (!FLAC__bitreader_read_raw_int32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $6 + 16 | 0, $7)) {
               break block90
              }
              HEAP32[$13 + ($2 << 2) >> 2] = HEAP32[$6 + 16 >> 2];
              $4 = ($2 | 0) != ($11 | 0);
              $2 = $2 + 1 | 0;
              if ($4) {
               continue
              }
              break;
             };
             if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $6 + 32 | 0, $18)) {
              break block90
             }
             $4 = HEAP32[$6 + 32 >> 2];
             block118 : {
              if (($4 ^ $17) == -1) {
               $3 = HEAP32[$0 + 4 >> 2];
               if (!HEAP32[$3 + 3632 >> 2]) {
                FUNCTION_TABLE[HEAP32[$3 + 32 >> 2]]($0, 0, HEAP32[$3 + 48 >> 2])
               }
               HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
               break block118;
              }
              HEAP32[$3 + 16 >> 2] = $4 + 1;
              if (!FLAC__bitreader_read_raw_int32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $6 + 16 | 0, $19)) {
               break block90
              }
              $4 = HEAP32[$6 + 16 >> 2];
              if (($4 | 0) < 0) {
               $3 = HEAP32[$0 + 4 >> 2];
               if (!HEAP32[$3 + 3632 >> 2]) {
                FUNCTION_TABLE[HEAP32[$3 + 32 >> 2]]($0, 0, HEAP32[$3 + 48 >> 2])
               }
               HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
               break block118;
              }
              HEAP32[$3 + 20 >> 2] = $4;
              $9 = $3 + 24 | 0;
              $2 = 0;
              while (1) {
               if (!FLAC__bitreader_read_raw_int32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $6 + 16 | 0, HEAP32[$3 + 16 >> 2])) {
                break block90
               }
               HEAP32[$9 + ($2 << 2) >> 2] = HEAP32[$6 + 16 >> 2];
               $4 = ($2 | 0) != ($11 | 0);
               $2 = $2 + 1 | 0;
               if ($4) {
                continue
               }
               break;
              };
              $2 = $6 + 32 | 0;
              if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $2, $15)) {
               break block90
              }
              $12 = HEAP32[$6 + 32 >> 2];
              HEAP32[$3 >> 2] = $12;
              $4 = HEAP32[$0 + 4 >> 2];
              block122 : {
               if ($12 >>> 0 <= 1) {
                if (!FLAC__bitreader_read_raw_uint32(HEAP32[$4 + 56 >> 2], $2, $16)) {
                 break block90
                }
                $4 = HEAP32[$0 + 4 >> 2];
                $2 = HEAP32[$6 + 32 >> 2];
                if ($11 >>> 0 < HEAP32[$4 + 1136 >> 2] >>> $2 >>> 0) {
                 break block122
                }
                if (!HEAP32[$4 + 3632 >> 2]) {
                 FUNCTION_TABLE[HEAP32[$4 + 32 >> 2]]($0, 0, HEAP32[$4 + 48 >> 2])
                }
                HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
                break block118;
               }
               block125 : {
                if (!HEAP32[$4 + 3632 >> 2]) {
                 FUNCTION_TABLE[HEAP32[$4 + 32 >> 2]]($0, 3, HEAP32[$4 + 48 >> 2]);
                 break block125;
                }
                HEAP32[$4 + 6152 >> 2] = HEAP32[$4 + 6152 >> 2] + 1;
               }
               HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
               break block118;
              }
              HEAP32[$3 + 4 >> 2] = $2;
              $4 = Math_imul($8, 12);
              HEAP32[$3 + 8 >> 2] = ($4 + HEAP32[$0 + 4 >> 2] | 0) + 124;
              $11 = HEAP32[$3 >> 2];
              if ($11 >>> 0 < 2) {
               $12 = $2;
               $2 = HEAP32[$0 + 4 >> 2];
               if (!read_residual_partitioned_rice_($0, $5, $12, ($4 + $2 | 0) + 124 | 0, HEAP32[($2 + $10 | 0) + 92 >> 2], ($11 | 0) == 1)) {
                break block90
               }
              }
              $4 = $5 << 2;
              if ($4) {
               wasm2js_memory_copy(HEAP32[($10 + HEAP32[$0 + 4 >> 2] | 0) + 60 >> 2], $13, $4)
              }
              block129 : {
               $13 = HEAP32[$3 + 16 >> 2];
               if ($13 + ((Math_clz32($5) ^ 31) + $7 | 0) >>> 0 <= 32) {
                $2 = HEAP32[$0 + 4 >> 2];
                $11 = $10 + $2 | 0;
                $4 = $4 + HEAP32[$11 + 60 >> 2] | 0;
                $10 = HEAP32[$2 + 1136 >> 2] - $5 | 0;
                $11 = HEAP32[$11 + 92 >> 2];
                $3 = HEAP32[$3 + 20 >> 2];
                if ($7 >>> 0 > 16 | $13 >>> 0 > 16) {
                 break block129
                }
                FUNCTION_TABLE[HEAP32[$2 + 44 >> 2]]($11, $10, $9, $5, $3, $4);
                break block118;
               }
               $2 = HEAP32[$0 + 4 >> 2];
               $7 = $2 + $10 | 0;
               FUNCTION_TABLE[HEAP32[$2 + 40 >> 2]](HEAP32[$7 + 92 >> 2], HEAP32[$2 + 1136 >> 2] - $5 | 0, $9, $5, HEAP32[$3 + 20 >> 2], $4 + HEAP32[$7 + 60 >> 2] | 0);
               break block118;
              }
              FUNCTION_TABLE[HEAP32[$2 + 36 >> 2]]($11, $10, $9, $5, $3, $4);
             }
             if (!$14 | HEAP32[HEAP32[$0 >> 2] >> 2] == 2) {
              break block112
             }
             break block113;
            }
            $10 = 0;
            break block;
           }
           HEAP32[$2 + 6152 >> 2] = HEAP32[$2 + 6152 >> 2] + 1;
          }
          HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
          break block112;
         }
         if (!$14) {
          break block112
         }
        }
        $3 = HEAP32[$0 + 4 >> 2];
        HEAP32[$6 + 44 >> 2] = HEAP32[($3 + Math_imul($8, 292) | 0) + 1464 >> 2];
        if (!HEAP32[$3 + 1136 >> 2]) {
         break block112
        }
        $5 = HEAP32[($3 + ($8 << 2) | 0) + 60 >> 2];
        $2 = 0;
        while (1) {
         $4 = $5 + ($2 << 2) | 0;
         HEAP32[$4 >> 2] = HEAP32[$4 >> 2] << HEAP32[$6 + 44 >> 2];
         $2 = $2 + 1 | 0;
         if ($2 >>> 0 < HEAPU32[$3 + 1136 >> 2]) {
          continue
         }
         break;
        };
       }
       if (HEAP32[HEAP32[$0 >> 2] >> 2] == 2) {
        break block130
       }
       $8 = $8 + 1 | 0;
       $2 = HEAP32[$0 + 4 >> 2];
       if ($8 >>> 0 < HEAPU32[$2 + 1144 >> 2]) {
        continue
       }
       break;
      };
     }
     block131 : {
      if (FLAC__bitreader_is_consumed_byte_aligned(HEAP32[$2 + 56 >> 2])) {
       break block131
      }
      $10 = 0;
      HEAP32[$6 + 16 >> 2] = 0;
      $3 = HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2];
      $3 = FLAC__bitreader_read_raw_uint32($3, $6 + 16 | 0, FLAC__bitreader_bits_left_for_byte_alignment($3));
      if (!(!$3 | !HEAP32[$6 + 16 >> 2])) {
       $3 = HEAP32[$0 + 4 >> 2];
       if (!HEAP32[$3 + 3632 >> 2]) {
        FUNCTION_TABLE[HEAP32[$3 + 32 >> 2]]($0, 0, HEAP32[$3 + 48 >> 2])
       }
       HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
       break block131;
      }
      if (!$3) {
       break block
      }
     }
     $10 = 1;
     if (HEAP32[HEAP32[$0 >> 2] >> 2] == 2) {
      break block
     }
     $4 = HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2];
     $10 = HEAP32[$4 + 16 >> 2];
     $5 = HEAP32[$4 + 28 >> 2];
     block149 : {
      if ($10 >>> 0 <= $5 >>> 0) {
       $7 = HEAP32[$4 >> 2];
       $3 = $5;
       break block149;
      }
      $7 = HEAP32[$4 >> 2];
      $2 = HEAP32[$4 + 32 >> 2];
      if (!$2) {
       $3 = $5;
       break block149;
      }
      $3 = $5 + 1 | 0;
      HEAP32[$4 + 28 >> 2] = $3;
      $8 = HEAP32[$4 + 24 >> 2];
      $12 = $8;
      block350 : {
       if ($2 >>> 0 > 31) {
        break block350
       }
       $5 = HEAP32[($5 << 2) + $7 >> 2];
       $9 = HEAPU16[(($5 >>> 24 - $2 & 255 ^ $8 >>> 8) << 1) + 1280 >> 1];
       $8 = $9 ^ $8 << 8 & 65280;
       $12 = $8;
       if ($2 >>> 0 > 23) {
        break block350
       }
       $8 = HEAPU16[(($5 >>> 16 - $2 & 255 ^ $8 >>> 8) << 1) + 1280 >> 1];
       $9 = $8 ^ $9 << 8 & 65280;
       $12 = $9;
       if ($2 >>> 0 > 15) {
        break block350
       }
       $9 = HEAPU16[(($5 >>> 8 - $2 & 255 ^ $9 >>> 8) << 1) + 1280 >> 1];
       $8 = $9 ^ $8 << 8 & 65280;
       $12 = $8;
       if (($2 | 16) >>> 0 > 23) {
        break block350
       }
       $12 = HEAPU16[(($5 >>> 0 - $2 & 255 ^ $8 >>> 8) << 1) + 1280 >> 1] ^ $9 << 8 & 65280;
      }
      $5 = $12;
      HEAP32[$4 + 32 >> 2] = 0;
      HEAP32[$4 + 24 >> 2] = $5;
     }
     $3 = FLAC__crc16_update_words32(($3 << 2) + $7 | 0, $10 - $3 | 0, HEAPU16[$4 + 24 >> 1]);
     HEAP32[$4 + 28 >> 2] = 0;
     HEAP32[$4 + 24 >> 2] = $3;
     $2 = HEAP32[$4 + 20 >> 2];
     block451 : {
      if (!$2) {
       break block451
      }
      $5 = HEAP32[$4 + 32 >> 2];
      if ($2 >>> 0 <= $5 >>> 0) {
       break block451
      }
      $7 = HEAP32[HEAP32[$4 >> 2] + (HEAP32[$4 + 16 >> 2] << 2) >> 2];
      while (1) {
       $3 = HEAPU16[(($7 >>> 24 - $5 & 255 ^ $3 >>> 8) << 1) + 1280 >> 1] ^ $3 << 8 & 65280;
       $5 = $5 + 8 | 0;
       if ($2 >>> 0 > $5 >>> 0) {
        continue
       }
       break;
      };
      HEAP32[$4 + 32 >> 2] = $5;
      HEAP32[$4 + 24 >> 2] = $3;
     }
     $10 = 0;
     if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $6 + 16 | 0, HEAP32[1681])) {
      break block
     }
     block135 : {
      if (HEAP32[$6 + 16 >> 2] == ($3 | 0)) {
       block138 : {
        block136 : {
         block137 : {
          $2 = HEAP32[$0 + 4 >> 2];
          switch (HEAP32[$2 + 1148 >> 2] - 1 | 0) {
          case 0:
           break block136;
          case 1:
           break block137;
          case 2:
           break block138;
          default:
           break block135;
          };
         }
         if (!HEAP32[$2 + 1136 >> 2]) {
          break block135
         }
         $3 = HEAP32[$2 + 60 >> 2];
         $5 = HEAP32[$2 + 64 >> 2];
         $7 = 0;
         while (1) {
          $4 = $7 << 2;
          $8 = $4 + $3 | 0;
          HEAP32[$8 >> 2] = HEAP32[$8 >> 2] + HEAP32[$4 + $5 >> 2];
          $7 = $7 + 1 | 0;
          if ($7 >>> 0 < HEAPU32[$2 + 1136 >> 2]) {
           continue
          }
          break;
         };
         break block135;
        }
        if (!HEAP32[$2 + 1136 >> 2]) {
         break block135
        }
        $3 = HEAP32[$2 + 64 >> 2];
        $5 = HEAP32[$2 + 60 >> 2];
        $7 = 0;
        while (1) {
         $4 = $7 << 2;
         $8 = $4 + $3 | 0;
         HEAP32[$8 >> 2] = HEAP32[$4 + $5 >> 2] - HEAP32[$8 >> 2];
         $7 = $7 + 1 | 0;
         if ($7 >>> 0 < HEAPU32[$2 + 1136 >> 2]) {
          continue
         }
         break;
        };
        break block135;
       }
       if (!HEAP32[$2 + 1136 >> 2]) {
        break block135
       }
       $8 = HEAP32[$2 + 64 >> 2];
       $9 = HEAP32[$2 + 60 >> 2];
       $7 = 0;
       while (1) {
        $5 = $7 << 2;
        $3 = $5 + $9 | 0;
        $14 = $5 + $8 | 0;
        $5 = HEAP32[$14 >> 2];
        $4 = $5 & 1 | HEAP32[$3 >> 2] << 1;
        HEAP32[$3 >> 2] = $4 + $5 >> 1;
        HEAP32[$14 >> 2] = $4 - $5 >> 1;
        $7 = $7 + 1 | 0;
        if ($7 >>> 0 < HEAPU32[$2 + 1136 >> 2]) {
         continue
        }
        break;
       };
       break block135;
      }
      $2 = HEAP32[$0 + 4 >> 2];
      if (!HEAP32[$2 + 3632 >> 2]) {
       FUNCTION_TABLE[HEAP32[$2 + 32 >> 2]]($0, 2, HEAP32[$2 + 48 >> 2]);
       $2 = HEAP32[$0 + 4 >> 2];
      }
      if (!HEAP32[$2 + 1144 >> 2]) {
       break block135
      }
      $7 = 0;
      while (1) {
       $3 = HEAP32[$2 + 1136 >> 2] << 2;
       if ($3) {
        wasm2js_memory_fill(HEAP32[(($7 << 2) + $2 | 0) + 60 >> 2], 0, $3)
       }
       $7 = $7 + 1 | 0;
       $2 = HEAP32[$0 + 4 >> 2];
       if ($7 >>> 0 < HEAPU32[$2 + 1144 >> 2]) {
        continue
       }
       break;
      };
     }
     HEAP32[$1 >> 2] = 1;
     $1 = HEAP32[$2 + 232 >> 2];
     if ($1) {
      HEAP32[$2 + 228 >> 2] = $1
     }
     $1 = HEAP32[$0 >> 2];
     HEAP32[$1 + 8 >> 2] = HEAP32[$2 + 1144 >> 2];
     HEAP32[$1 + 12 >> 2] = HEAP32[$2 + 1148 >> 2];
     HEAP32[$1 + 16 >> 2] = HEAP32[$2 + 1152 >> 2];
     HEAP32[$1 + 20 >> 2] = HEAP32[$2 + 1140 >> 2];
     $5 = $1;
     $1 = HEAP32[$2 + 1136 >> 2];
     HEAP32[$5 + 24 >> 2] = $1;
     $3 = HEAP32[$2 + 1164 >> 2];
     $12 = $3 + 1 | 0;
     $5 = $3;
     $3 = HEAP32[$2 + 1160 >> 2] + $1 | 0;
     $1 = $1 >>> 0 > $3 >>> 0 ? $12 : $5;
     HEAP32[$2 + 240 >> 2] = $3;
     HEAP32[$2 + 244 >> 2] = $1;
     $3 = $2 + 1136 | 0;
     $5 = $2 + 60 | 0;
     $14 = 0;
     $2 = __stack_pointer - 32 | 0;
     __stack_pointer = $2;
     $1 = HEAP32[$0 + 4 >> 2];
     block253 : {
      if (HEAP32[$1 + 3632 >> 2]) {
       $11 = HEAP32[$3 >> 2];
       $8 = HEAP32[$3 + 24 >> 2];
       $4 = HEAP32[$3 + 28 >> 2];
       HEAP32[$1 + 6156 >> 2] = 1;
       $9 = HEAP32[$1 + 6144 >> 2];
       $7 = HEAP32[$1 + 6148 >> 2];
       wasm2js_memory_copy($1 + 3752 | 0, $3, 2384);
       $1 = 0;
       if (($4 | 0) == ($7 | 0) & $8 >>> 0 > $9 >>> 0 | $4 >>> 0 > $7 >>> 0) {
        break block253
       }
       $13 = $4 + 1 | 0;
       $12 = $4;
       $4 = $8 + $11 | 0;
       $11 = $11 >>> 0 > $4 >>> 0 ? $13 : $12;
       if (($11 | 0) == ($7 | 0) & $4 >>> 0 <= $9 >>> 0 | $7 >>> 0 > $11 >>> 0) {
        break block253
       }
       $4 = HEAP32[$0 + 4 >> 2];
       HEAP32[$4 + 3632 >> 2] = 0;
       $7 = $9 - $8 | 0;
       if ($7) {
        $8 = HEAP32[$3 + 8 >> 2];
        block454 : {
         if (!$8) {
          break block454
         }
         $11 = 0;
         if ($8 >>> 0 >= 4) {
          $16 = $8 & -4;
          while (1) {
           $3 = $1 << 2;
           $9 = $7 << 2;
           HEAP32[$3 + $2 >> 2] = $9 + HEAP32[$3 + $5 >> 2];
           $15 = $3 | 4;
           HEAP32[$15 + $2 >> 2] = HEAP32[$5 + $15 >> 2] + $9;
           $15 = $3 | 8;
           HEAP32[$15 + $2 >> 2] = HEAP32[$5 + $15 >> 2] + $9;
           $3 = $3 | 12;
           HEAP32[$3 + $2 >> 2] = HEAP32[$3 + $5 >> 2] + $9;
           $1 = $1 + 4 | 0;
           $14 = $14 + 4 | 0;
           if (($14 | 0) != ($16 | 0)) {
            continue
           }
           break;
          };
         }
         $3 = $8 & 3;
         if (!$3) {
          break block454
         }
         while (1) {
          $8 = $1 << 2;
          HEAP32[$8 + $2 >> 2] = HEAP32[$5 + $8 >> 2] + ($7 << 2);
          $1 = $1 + 1 | 0;
          $11 = $11 + 1 | 0;
          if (($11 | 0) != ($3 | 0)) {
           continue
          }
          break;
         };
        }
        HEAP32[$4 + 3752 >> 2] = HEAP32[$4 + 3752 >> 2] - $7;
        $1 = HEAP32[$4 + 3780 >> 2];
        $3 = $1 + 1 | 0;
        $5 = $1;
        $1 = $7 + HEAP32[$4 + 3776 >> 2] | 0;
        $3 = $1 >>> 0 < $7 >>> 0 ? $3 : $5;
        HEAP32[$4 + 3776 >> 2] = $1;
        HEAP32[$4 + 3780 >> 2] = $3;
        $1 = HEAP32[$0 + 4 >> 2];
        $1 = FUNCTION_TABLE[HEAP32[$1 + 24 >> 2]]($0, $1 + 3752 | 0, $2, HEAP32[$1 + 48 >> 2]) | 0;
        break block253;
       }
       $1 = FUNCTION_TABLE[HEAP32[$4 + 24 >> 2]]($0, $3, $5, HEAP32[$4 + 48 >> 2]) | 0;
       break block253;
      }
      block757 : {
       if (!HEAP32[$1 + 248 >> 2]) {
        HEAP32[$1 + 3624 >> 2] = 0;
        break block757;
       }
       if (!HEAP32[$1 + 3624 >> 2]) {
        break block757
       }
       if (!FLAC__MD5Accumulate($1 + 3636 | 0, $5, HEAP32[$3 + 8 >> 2], HEAP32[$3 >> 2], HEAP32[$3 + 16 >> 2] + 7 >>> 3 | 0)) {
        $1 = 1;
        break block253;
       }
       $1 = HEAP32[$0 + 4 >> 2];
      }
      $1 = FUNCTION_TABLE[HEAP32[$1 + 24 >> 2]]($0, $3, $5, HEAP32[$1 + 48 >> 2]) | 0;
     }
     __stack_pointer = $2 + 32 | 0;
     $0 = HEAP32[$0 >> 2];
     if ($1) {
      HEAP32[$0 >> 2] = 7;
      break block;
     }
     HEAP32[$0 >> 2] = 2;
    }
    $10 = 1;
    break block;
   }
   HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
   $10 = 0;
  }
  __stack_pointer = $6 + 48 | 0;
  return $10;
 }
 
 function read_residual_partitioned_rice_($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0;
  $13 = __stack_pointer - 16 | 0;
  __stack_pointer = $13;
  $6 = HEAP32[HEAP32[$0 + 4 >> 2] + 1136 >> 2];
  block2 : {
   if (FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size($3, $2 >>> 0 <= 6 ? 6 : $2)) {
    $24 = $2 ? $6 >>> $2 | 0 : $6 - $1 | 0;
    $27 = HEAP32[($5 ? 6752 : 6748) >> 2];
    $28 = HEAP32[($5 ? 6740 : 6736) >> 2];
    $29 = HEAP32[1686];
    $5 = 0;
    while (1) {
     if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $13 + 12 | 0, $28)) {
      $14 = 0;
      break block2;
     }
     $7 = $20 << 2;
     $6 = HEAP32[$13 + 12 >> 2];
     HEAP32[$7 + HEAP32[$3 >> 2] >> 2] = $6;
     block4 : {
      if ($6 >>> 0 < $27 >>> 0) {
       $14 = 0;
       HEAP32[$7 + HEAP32[$3 + 4 >> 2] >> 2] = 0;
       $8 = HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2];
       $11 = 0;
       $15 = 0;
       $22 = 0;
       $19 = 0;
       $21 = 0;
       $12 = __stack_pointer - 16 | 0;
       __stack_pointer = $12;
       $10 = ($5 << 2) + $4 | 0;
       $25 = $24 - ($2 ? ($20 ? 0 : $1) : 0) | 0;
       $6 = $25;
       $23 = $10 + ($6 << 2) | 0;
       block3 : {
        block1 : {
         $17 = HEAP32[$13 + 12 >> 2];
         if (!$17) {
          if (!$6) {
           break block1
          }
          while (1) {
           if (!FLAC__bitreader_read_unary_unsigned($8, $12 + 8 | 0)) {
            $22 = 0;
            break block3;
           }
           $22 = 1;
           $6 = HEAP32[$12 + 8 >> 2];
           HEAP32[$10 >> 2] = $6 >>> 1 ^ 0 - ($6 & 1);
           $10 = $10 + 4 | 0;
           if ($23 >>> 0 > $10 >>> 0) {
            continue
           }
           break;
          };
          break block3;
         }
         $7 = HEAP32[$8 + 16 >> 2];
         $18 = HEAP32[$8 + 8 >> 2];
         block6 : {
          if ($7 >>> 0 < $18 >>> 0) {
           $19 = HEAP32[$8 >> 2];
           $21 = HEAP32[$8 + 20 >> 2];
           $15 = HEAP32[$19 + ($7 << 2) >> 2] << $21;
           $6 = 0;
           break block6;
          }
          $6 = 1;
         }
         while (1) {
          block18 : {
           block16 : {
            block17 : {
             block15 : {
              if (!$6) {
               $9 = 32 - $21 | 0;
               block12 : {
                if ($10 >>> 0 < $23 >>> 0) {
                 $26 = 32 - $17 | 0;
                 while (1) {
                  $6 = $7;
                  $11 = $9;
                  block11 : {
                   if ($15) {
                    $11 = Math_clz32($15);
                    $16 = $11;
                    break block11;
                   }
                   while (1) {
                    $6 = $6 + 1 | 0;
                    if ($18 >>> 0 <= $6 >>> 0) {
                     break block12
                    }
                    $15 = HEAP32[($6 << 2) + $19 >> 2];
                    $16 = Math_clz32($15);
                    $11 = $16 + $11 | 0;
                    if (!$15) {
                     continue
                    }
                    break;
                   };
                  }
                  $7 = $15 << $16 << 1;
                  $16 = $7 >>> $26 | 0;
                  $9 = ($11 ^ -1) + $9 & 31;
                  block14 : {
                   if ($17 >>> 0 <= $9 >>> 0) {
                    $15 = $7 << $17;
                    $9 = $9 - $17 | 0;
                    $7 = $6;
                    break block14;
                   }
                   $7 = $6 + 1 | 0;
                   if ($18 >>> 0 <= $7 >>> 0) {
                    break block15
                   }
                   $6 = HEAP32[($7 << 2) + $19 >> 2];
                   $9 = $9 + $26 | 0;
                   $15 = $6 << 32 - $9;
                   $16 = $6 >>> $9 | $16;
                  }
                  HEAP32[$12 + 12 >> 2] = $16;
                  $6 = $11 << $17 | $16;
                  HEAP32[$10 >> 2] = $6 >>> 1 ^ 0 - ($6 & 1);
                  $10 = $10 + 4 | 0;
                  if ($23 >>> 0 > $10 >>> 0) {
                   continue
                  }
                  break;
                 };
                }
                $6 = $7 >>> 0 < $18 >>> 0;
                HEAP32[$8 + 16 >> 2] = ($6 & !$9) + $7;
                HEAP32[$8 + 20 >> 2] = 32 - ($9 ? $9 : $6 << 5);
                break block1;
               }
               HEAP32[$8 + 20 >> 2] = 0;
               $6 = $7 + 1 | 0;
               HEAP32[$8 + 16 >> 2] = $6 >>> 0 < $18 >>> 0 ? $18 : $6;
               break block16;
              }
              if (!FLAC__bitreader_read_unary_unsigned($8, $12 + 8 | 0)) {
               break block3
              }
              $11 = HEAP32[$12 + 8 >> 2] + $11 | 0;
              HEAP32[$12 + 8 >> 2] = $11;
              $16 = 0;
              $9 = 0;
              break block17;
             }
             HEAP32[$8 + 16 >> 2] = $7;
             HEAP32[$8 + 20 >> 2] = 0;
            }
            if (!FLAC__bitreader_read_raw_uint32($8, $12 + 12 | 0, $17 - $9 | 0)) {
             break block3
            }
            $7 = $11 << $17;
            $6 = HEAP32[$12 + 12 >> 2] | $16;
            HEAP32[$12 + 12 >> 2] = $6;
            $11 = 0;
            $6 = $6 | $7;
            HEAP32[$10 >> 2] = $6 >>> 1 ^ 0 - ($6 & 1);
            $7 = HEAP32[$8 + 16 >> 2];
            $18 = HEAP32[$8 + 8 >> 2];
            $10 = $10 + 4 | 0;
            if ($7 >>> 0 < $18 >>> 0 | $23 >>> 0 <= $10 >>> 0) {
             break block18
            }
           }
           $6 = 1;
           continue;
          }
          $19 = HEAP32[$8 >> 2];
          $21 = HEAP32[$8 + 20 >> 2];
          $15 = HEAP32[$19 + ($7 << 2) >> 2] << $21;
          $6 = 0;
          continue;
         };
        }
        $22 = 1;
       }
       __stack_pointer = $12 + 16 | 0;
       if (!$22) {
        break block2
       }
       $5 = $5 + $25 | 0;
       break block4;
      }
      if (!FLAC__bitreader_read_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $13 + 12 | 0, $29)) {
       $14 = 0;
       break block2;
      }
      HEAP32[$7 + HEAP32[$3 + 4 >> 2] >> 2] = HEAP32[$13 + 12 >> 2];
      $14 = $2 ? ($20 ? 0 : $1) : 0;
      if ($24 >>> 0 <= $14 >>> 0) {
       break block4
      }
      while (1) {
       if (!FLAC__bitreader_read_raw_int32(HEAP32[HEAP32[$0 + 4 >> 2] + 56 >> 2], $13 + 8 | 0, HEAP32[$13 + 12 >> 2])) {
        $14 = 0;
        break block2;
       }
       HEAP32[($5 << 2) + $4 >> 2] = HEAP32[$13 + 8 >> 2];
       $5 = $5 + 1 | 0;
       $14 = $14 + 1 | 0;
       if (($24 | 0) != ($14 | 0)) {
        continue
       }
       break;
      };
     }
     $14 = 1;
     $20 = $20 + 1 | 0;
     if (!($20 >>> $2 | 0)) {
      continue
     }
     break;
    };
    break block2;
   }
   HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
  }
  __stack_pointer = $13 + 16 | 0;
  return $14;
 }
 
 function FLAC__stream_decoder_process_until_end_of_metadata($0) {
  $0 = $0 | 0;
  var $1 = 0;
  block3 : {
   while (1) {
    block2 : {
     switch (HEAP32[HEAP32[$0 >> 2] >> 2]) {
     case 0:
      if (find_metadata_($0)) {
       continue
      }
      break block3;
     case 1:
      if (read_metadata_($0)) {
       continue
      }
      break block3;
     case 2:
     case 3:
     case 4:
     case 7:
      break block2;
     default:
      break block3;
     };
    }
    break;
   };
   $1 = 1;
  }
  return $1 | 0;
 }
 
 function FLAC__stream_decoder_process_until_end_of_stream($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  $1 = __stack_pointer - 16 | 0;
  __stack_pointer = $1;
  while (1) {
   block5 : {
    block3 : {
     switch (HEAP32[HEAP32[$0 >> 2] >> 2]) {
     case 0:
      if (find_metadata_($0)) {
       continue
      }
      break block5;
     case 1:
      if (read_metadata_($0)) {
       continue
      }
      break block5;
     case 2:
      if (frame_sync_($0)) {
       continue
      }
     case 4:
     case 7:
      $2 = 1;
      break block5;
     case 3:
      break block3;
     default:
      break block5;
     };
    }
    if (read_frame_($0, $1 + 12 | 0)) {
     continue
    }
   }
   break;
  };
  __stack_pointer = $1 + 16 | 0;
  return $2 | 0;
 }
 
 function read_callback_proxy_($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = FUNCTION_TABLE[HEAP32[HEAP32[$0 + 4 >> 2] + 4 >> 2]]($0, $1, $2, $3) | 0;
  return ($0 ? (($0 | 0) == 1 ? 1 : 5) : 0) | 0;
 }
 
 function FLAC__bitwriter_clear($0) {
  HEAP32[$0 + 12 >> 2] = 0;
  HEAP32[$0 + 16 >> 2] = 0;
 }
 
 function FLAC__bitwriter_get_buffer($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  $6 = HEAP32[$0 + 16 >> 2];
  block : {
   if ($6 & 7) {
    break block
   }
   block2 : {
    if (!$6) {
     $3 = HEAP32[$0 >> 2];
     $8 = 0;
     break block2;
    }
    $7 = HEAP32[$0 + 12 >> 2];
    block4 : {
     if (($7 | 0) != HEAP32[$0 + 8 >> 2]) {
      $3 = HEAP32[$0 >> 2];
      break block4;
     }
     $4 = HEAP32[$0 >> 2];
     $3 = $6 + 63 >>> 5 | 0;
     $5 = $3 + $7 | 0;
     if ($7 >>> 0 >= $5 >>> 0) {
      $3 = $4;
      break block4;
     }
     $3 = $3 & 1023;
     $5 = $3 ? ($5 - $3 | 0) + 1024 | 0 : $5;
     block7 : {
      if ($5) {
       if ($5 >>> 0 > 1073741823) {
        break block
       }
       $3 = emscripten_builtin_realloc($4, $5 << 2);
       if ($3) {
        break block7
       }
       emscripten_builtin_free($4);
       return 0;
      }
      $3 = emscripten_builtin_realloc($4, 0);
      if (!$3) {
       break block
      }
     }
     HEAP32[$0 + 8 >> 2] = $5;
     HEAP32[$0 >> 2] = $3;
     $7 = HEAP32[$0 + 12 >> 2];
     $6 = HEAP32[$0 + 16 >> 2];
    }
    $4 = HEAP32[$0 + 4 >> 2] << 32 - $6;
    HEAP32[($7 << 2) + $3 >> 2] = $4 << 24 | ($4 & 65280) << 8 | ($4 >>> 8 & 65280 | $4 >>> 24);
    $8 = HEAP32[$0 + 16 >> 2] >>> 3 | 0;
   }
   HEAP32[$1 >> 2] = $3;
   HEAP32[$2 >> 2] = (HEAP32[$0 + 12 >> 2] << 2) + $8;
   $8 = 1;
  }
  return $8;
 }
 
 function FLAC__bitwriter_write_zeroes($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  block3 : {
   block : {
    if (!$1) {
     break block
    }
    $4 = HEAP32[$0 + 8 >> 2];
    $2 = HEAP32[$0 + 12 >> 2];
    block1 : {
     if ($4 >>> 0 > $2 + $1 >>> 0) {
      break block1
     }
     $2 = $2 + ((HEAP32[$0 + 16 >> 2] + $1 | 0) + 31 >>> 5 | 0) | 0;
     if ($2 >>> 0 <= $4 >>> 0) {
      break block1
     }
     $3 = HEAP32[$0 >> 2];
     $4 = $2 - $4 & 1023;
     $2 = $4 ? ($2 - $4 | 0) + 1024 | 0 : $2;
     block4 : {
      if ($2) {
       $5 = 0;
       if ($2 >>> 0 > 1073741823) {
        break block3
       }
       $6 = emscripten_builtin_realloc($3, $2 << 2);
       if ($6) {
        break block4
       }
       emscripten_builtin_free($3);
       return 0;
      }
      $6 = emscripten_builtin_realloc($3, 0);
      $5 = 0;
      if (!$6) {
       break block3
      }
     }
     HEAP32[$0 + 8 >> 2] = $2;
     HEAP32[$0 >> 2] = $6;
    }
    $2 = HEAP32[$0 + 16 >> 2];
    if ($2) {
     $5 = $2;
     $2 = 32 - $2 | 0;
     $3 = $1 >>> 0 > $2 >>> 0 ? $2 : $1;
     $4 = $5 + $3 | 0;
     HEAP32[$0 + 16 >> 2] = $4;
     $2 = HEAP32[$0 + 4 >> 2] << $3;
     HEAP32[$0 + 4 >> 2] = $2;
     if (($4 | 0) != 32) {
      break block
     }
     $4 = HEAP32[$0 + 12 >> 2];
     HEAP32[$0 + 12 >> 2] = $4 + 1;
     HEAP32[HEAP32[$0 >> 2] + ($4 << 2) >> 2] = $2 << 24 | ($2 & 65280) << 8 | ($2 >>> 8 & 65280 | $2 >>> 24);
     HEAP32[$0 + 16 >> 2] = 0;
     $1 = $1 - $3 | 0;
    }
    block6 : {
     if ($1 >>> 0 < 32) {
      break block6
     }
     $2 = HEAP32[$0 >> 2];
     $3 = $1 - 32 | 0;
     if (($3 & 96) != 96) {
      $6 = ($3 >>> 5 | 0) + 1 & 3;
      $4 = 0;
      while (1) {
       $5 = HEAP32[$0 + 12 >> 2];
       HEAP32[$0 + 12 >> 2] = $5 + 1;
       HEAP32[$2 + ($5 << 2) >> 2] = 0;
       $1 = $1 - 32 | 0;
       $4 = $4 + 1 | 0;
       if (($6 | 0) != ($4 | 0)) {
        continue
       }
       break;
      };
     }
     if ($3 >>> 0 < 96) {
      break block6
     }
     while (1) {
      $3 = HEAP32[$0 + 12 >> 2];
      HEAP32[$0 + 12 >> 2] = $3 + 1;
      HEAP32[$2 + ($3 << 2) >> 2] = 0;
      $3 = HEAP32[$0 + 12 >> 2];
      HEAP32[$0 + 12 >> 2] = $3 + 1;
      HEAP32[$2 + ($3 << 2) >> 2] = 0;
      $3 = HEAP32[$0 + 12 >> 2];
      HEAP32[$0 + 12 >> 2] = $3 + 1;
      HEAP32[$2 + ($3 << 2) >> 2] = 0;
      $3 = HEAP32[$0 + 12 >> 2];
      HEAP32[$0 + 12 >> 2] = $3 + 1;
      HEAP32[$2 + ($3 << 2) >> 2] = 0;
      $1 = $1 - 128 | 0;
      if ($1 >>> 0 > 31) {
       continue
      }
      break;
     };
    }
    if (!$1) {
     break block
    }
    HEAP32[$0 + 16 >> 2] = $1;
    HEAP32[$0 + 4 >> 2] = 0;
   }
   $5 = 1;
  }
  return $5;
 }
 
 function FLAC__bitwriter_write_raw_uint32($0, $1, $2) {
  var $3 = 0;
  block1 : {
   if ($2 >>> 0 <= 31) {
    $3 = 0;
    if ($1 >>> $2 | 0) {
     break block1
    }
   }
   $3 = FLAC__bitwriter_write_raw_uint32_nocheck($0, $1, $2);
  }
  return $3;
 }
 
 function FLAC__bitwriter_write_raw_uint32_nocheck($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  block : {
   if (!$0 | $2 >>> 0 > 32) {
    break block
   }
   $4 = HEAP32[$0 >> 2];
   if (!$4) {
    break block
   }
   if (!$2) {
    return 1
   }
   $5 = HEAP32[$0 + 8 >> 2];
   $3 = HEAP32[$0 + 12 >> 2];
   block3 : {
    if ($5 >>> 0 > $3 + $2 >>> 0) {
     $3 = $4;
     break block3;
    }
    $6 = $3 + ((HEAP32[$0 + 16 >> 2] + $2 | 0) + 31 >>> 5 | 0) | 0;
    if ($5 >>> 0 >= $6 >>> 0) {
     $3 = $4;
     break block3;
    }
    $3 = $6 - $5 & 1023;
    $5 = $3 ? ($6 - $3 | 0) + 1024 | 0 : $6;
    block6 : {
     if ($5) {
      if ($5 >>> 0 > 1073741823) {
       break block
      }
      $3 = emscripten_builtin_realloc($4, $5 << 2);
      if ($3) {
       break block6
      }
      emscripten_builtin_free($4);
      return 0;
     }
     $3 = emscripten_builtin_realloc($4, 0);
     if (!$3) {
      break block
     }
    }
    HEAP32[$0 + 8 >> 2] = $5;
    HEAP32[$0 >> 2] = $3;
   }
   $4 = HEAP32[$0 + 16 >> 2];
   $5 = 32 - $4 | 0;
   if ($2 >>> 0 < $5 >>> 0) {
    HEAP32[$0 + 16 >> 2] = $2 + $4;
    HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] << $2 | $1;
    return 1;
   }
   if ($4) {
    $4 = $2 - $5 | 0;
    HEAP32[$0 + 16 >> 2] = $4;
    $2 = HEAP32[$0 + 12 >> 2];
    HEAP32[$0 + 12 >> 2] = $2 + 1;
    $3 = ($2 << 2) + $3 | 0;
    $2 = HEAP32[$0 + 4 >> 2] << $5 | $1 >>> $4;
    HEAP32[$3 >> 2] = $2 << 24 | ($2 & 65280) << 8 | ($2 >>> 8 & 65280 | $2 >>> 24);
    HEAP32[$0 + 4 >> 2] = $1;
    return 1;
   }
   $7 = 1;
   $2 = $0;
   $0 = HEAP32[$0 + 12 >> 2];
   HEAP32[$2 + 12 >> 2] = $0 + 1;
   HEAP32[($0 << 2) + $3 >> 2] = $1 << 24 | ($1 & 65280) << 8 | ($1 >>> 8 & 65280 | $1 >>> 24);
  }
  return $7;
 }
 
 function FLAC__bitwriter_write_raw_int32($0, $1, $2) {
  return FLAC__bitwriter_write_raw_uint32_nocheck($0, ($2 >>> 0 >= 32 ? -1 : -1 << $2 ^ -1) & $1, $2);
 }
 
 function FLAC__bitwriter_write_raw_uint64($0, $1, $2, $3) {
  var $4 = 0;
  block2 : {
   if ($3 >>> 0 >= 33) {
    $3 = $3 - 32 | 0;
    if ($2 >>> $3 | 0 ? $3 >>> 0 <= 31 : 0) {
     break block2
    }
    if (!FLAC__bitwriter_write_raw_uint32_nocheck($0, $2, $3)) {
     break block2
    }
    return FLAC__bitwriter_write_raw_uint32_nocheck($0, $1, 32);
   }
   if (($3 | 0) != 32) {
    if ($1 >>> $3 | 0) {
     break block2
    }
   }
   $4 = FLAC__bitwriter_write_raw_uint32_nocheck($0, $1, $3);
  }
  return $4;
 }
 
 function FLAC__bitwriter_write_raw_uint32_little_endian($0, $1) {
  var $2 = 0;
  block : {
   if (!FLAC__bitwriter_write_raw_uint32_nocheck($0, $1 & 255, 8)) {
    break block
   }
   if (!FLAC__bitwriter_write_raw_uint32_nocheck($0, $1 >>> 8 & 255, 8)) {
    break block
   }
   if (!FLAC__bitwriter_write_raw_uint32_nocheck($0, $1 >>> 16 & 255, 8)) {
    break block
   }
   $2 = FLAC__bitwriter_write_raw_uint32_nocheck($0, $1 >>> 24 | 0, 8);
  }
  return $2;
 }
 
 function FLAC__bitwriter_write_byte_block($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $4 = HEAP32[$0 + 8 >> 2];
  $3 = HEAP32[$0 + 12 >> 2];
  block2 : {
   block : {
    if ($4 >>> 0 > ($3 + ($2 >>> 2 | 0) | 0) + 1 >>> 0) {
     break block
    }
    $3 = $3 + ((HEAP32[$0 + 16 >> 2] + ($2 << 3) | 0) + 31 >>> 5 | 0) | 0;
    if ($3 >>> 0 <= $4 >>> 0) {
     break block
    }
    $6 = HEAP32[$0 >> 2];
    $4 = $3 - $4 & 1023;
    $4 = $4 ? ($3 - $4 | 0) + 1024 | 0 : $3;
    block3 : {
     if ($4) {
      $5 = 0;
      if ($4 >>> 0 > 1073741823) {
       break block2
      }
      $3 = emscripten_builtin_realloc($6, $4 << 2);
      if ($3) {
       break block3
      }
      emscripten_builtin_free($6);
      return 0;
     }
     $3 = emscripten_builtin_realloc($6, 0);
     $5 = 0;
     if (!$3) {
      break block2
     }
    }
    HEAP32[$0 + 8 >> 2] = $4;
    HEAP32[$0 >> 2] = $3;
   }
   $5 = 1;
   if (!$2) {
    break block2
   }
   $6 = 0;
   while (1) {
    if (FLAC__bitwriter_write_raw_uint32_nocheck($0, HEAPU8[$1 + $6 | 0], 8)) {
     $6 = $6 + 1 | 0;
     $5 = 1;
     if (($6 | 0) == ($2 | 0)) {
      break block2
     }
     continue;
    }
    break;
   };
   $5 = 0;
  }
  return $5;
 }
 
 function FLAC__bitwriter_write_unary_unsigned($0, $1) {
  var $2 = 0;
  block1 : {
   if ($1 >>> 0 <= 31) {
    $2 = $1 + 1 | 0;
    break block1;
   }
   $2 = 1;
   if (FLAC__bitwriter_write_zeroes($0, $1)) {
    break block1
   }
   return 0;
  }
  return FLAC__bitwriter_write_raw_uint32_nocheck($0, 1, $2);
 }
 
 function FLAC__bitwriter_write_rice_signed_block($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
  $5 = 1;
  block : {
   if (!$2) {
    break block
   }
   $11 = $3 + 1 | 0;
   $12 = -1 << $3;
   $13 = -1 >>> 31 - $3 | 0;
   while (1) {
    $4 = HEAP32[$1 >> 2];
    $10 = $4 << 1 ^ $4 >> 31;
    $6 = $10 >>> $3 | 0;
    $5 = $6 + $11 | 0;
    block2 : {
     block1 : {
      $4 = HEAP32[$0 + 16 >> 2];
      if (!$4) {
       break block1
      }
      $7 = $4 + $5 | 0;
      if ($7 >>> 0 > 31) {
       break block1
      }
      HEAP32[$0 + 16 >> 2] = $7;
      HEAP32[$0 + 4 >> 2] = ($10 | $12) & $13 | HEAP32[$0 + 4 >> 2] << $5;
      break block2;
     }
     $8 = HEAP32[$0 + 8 >> 2];
     $7 = HEAP32[$0 + 12 >> 2];
     block3 : {
      if ($8 >>> 0 > ($7 + ($4 + $6 | 0) | 0) + 1 >>> 0) {
       break block3
      }
      $5 = $7 + (($4 + $5 | 0) + 31 >>> 5 | 0) | 0;
      if ($5 >>> 0 <= $8 >>> 0) {
       break block3
      }
      $7 = HEAP32[$0 >> 2];
      $4 = $5 - $8 & 1023;
      $4 = $4 ? ($5 - $4 | 0) + 1024 | 0 : $5;
      block5 : {
       if ($4) {
        $5 = 0;
        if ($4 >>> 0 > 1073741823) {
         break block
        }
        $9 = emscripten_builtin_realloc($7, $4 << 2);
        if ($9) {
         break block5
        }
        emscripten_builtin_free($7);
        return 0;
       }
       $9 = emscripten_builtin_realloc($7, 0);
       $5 = 0;
       if (!$9) {
        break block
       }
      }
      HEAP32[$0 + 8 >> 2] = $4;
      HEAP32[$0 >> 2] = $9;
      $4 = HEAP32[$0 + 16 >> 2];
     }
     block7 : {
      if (!$6) {
       $6 = $4;
       break block7;
      }
      if ($4) {
       $8 = HEAP32[$0 + 4 >> 2];
       $7 = 32 - $4 | 0;
       if ($6 >>> 0 < $7 >>> 0) {
        HEAP32[$0 + 4 >> 2] = $8 << $6;
        $6 = $4 + $6 | 0;
        break block7;
       }
       $8 = $8 << $7;
       HEAP32[$0 + 4 >> 2] = $8;
       $4 = HEAP32[$0 + 12 >> 2];
       HEAP32[$0 + 12 >> 2] = $4 + 1;
       HEAP32[HEAP32[$0 >> 2] + ($4 << 2) >> 2] = $8 << 24 | ($8 & 65280) << 8 | ($8 >>> 8 & 65280 | $8 >>> 24);
       HEAP32[$0 + 16 >> 2] = 0;
       $6 = $6 - $7 | 0;
      }
      block10 : {
       if ($6 >>> 0 < 32) {
        break block10
       }
       $5 = HEAP32[$0 >> 2];
       $8 = $6 - 32 | 0;
       if (($8 & 96) != 96) {
        $7 = ($8 >>> 5 | 0) + 1 & 3;
        $9 = 0;
        while (1) {
         $4 = HEAP32[$0 + 12 >> 2];
         HEAP32[$0 + 12 >> 2] = $4 + 1;
         HEAP32[$5 + ($4 << 2) >> 2] = 0;
         $6 = $6 - 32 | 0;
         $9 = $9 + 1 | 0;
         if (($7 | 0) != ($9 | 0)) {
          continue
         }
         break;
        };
       }
       if ($8 >>> 0 < 96) {
        break block10
       }
       while (1) {
        $4 = HEAP32[$0 + 12 >> 2];
        HEAP32[$0 + 12 >> 2] = $4 + 1;
        HEAP32[$5 + ($4 << 2) >> 2] = 0;
        $4 = HEAP32[$0 + 12 >> 2];
        HEAP32[$0 + 12 >> 2] = $4 + 1;
        HEAP32[$5 + ($4 << 2) >> 2] = 0;
        $4 = HEAP32[$0 + 12 >> 2];
        HEAP32[$0 + 12 >> 2] = $4 + 1;
        HEAP32[$5 + ($4 << 2) >> 2] = 0;
        $4 = HEAP32[$0 + 12 >> 2];
        HEAP32[$0 + 12 >> 2] = $4 + 1;
        HEAP32[$5 + ($4 << 2) >> 2] = 0;
        $6 = $6 - 128 | 0;
        if ($6 >>> 0 > 31) {
         continue
        }
        break;
       };
      }
      if (!$6) {
       $6 = HEAP32[$0 + 16 >> 2];
       break block7;
      }
      HEAP32[$0 + 4 >> 2] = 0;
     }
     $10 = ($10 | $12) & $13;
     $8 = HEAP32[$0 + 4 >> 2];
     $7 = 32 - $6 | 0;
     if ($11 >>> 0 < $7 >>> 0) {
      HEAP32[$0 + 16 >> 2] = $6 + $11;
      HEAP32[$0 + 4 >> 2] = $10 | $8 << $11;
      break block2;
     }
     $6 = $11 - $7 | 0;
     HEAP32[$0 + 16 >> 2] = $6;
     $4 = HEAP32[$0 + 12 >> 2];
     HEAP32[$0 + 12 >> 2] = $4 + 1;
     $5 = HEAP32[$0 >> 2] + ($4 << 2) | 0;
     $4 = $8 << $7 | $10 >>> $6;
     HEAP32[$5 >> 2] = $4 << 24 | ($4 & 65280) << 8 | ($4 >>> 8 & 65280 | $4 >>> 24);
     HEAP32[$0 + 4 >> 2] = $10;
    }
    $1 = $1 + 4 | 0;
    $2 = $2 - 1 | 0;
    if ($2) {
     continue
    }
    break;
   };
   $5 = 1;
  }
  return $5;
 }
 
 function FLAC__ogg_encoder_aspect_set_defaults($0) {
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
 }
 
 function simple_ogg_page__init($0) {
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
  $0 = $0 + 8 | 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
 }
 
 function simple_ogg_page__clear($0) {
  var $1 = 0;
  $1 = HEAP32[$0 >> 2];
  if ($1) {
   emscripten_builtin_free($1)
  }
  $1 = HEAP32[$0 + 8 >> 2];
  if ($1) {
   emscripten_builtin_free($1)
  }
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
  $0 = $0 + 8 | 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$0 + 4 >> 2] = 0;
 }
 
 function simple_ogg_page__get_at($0, $1, $2, $3, $4, $5, $6) {
  var $7 = 0, $8 = 0;
  $7 = __stack_pointer - 16 | 0;
  __stack_pointer = $7;
  block : {
   if (!$4) {
    break block
   }
   block1 : {
    switch (FUNCTION_TABLE[$4 | 0]($0, $1, $2, $6) | 0) {
    case 1:
     HEAP32[HEAP32[$0 >> 2] >> 2] = 5;
     break block;
    case 0:
     break block1;
    default:
     break block;
    };
   }
   $4 = emscripten_builtin_malloc(282);
   HEAP32[$3 >> 2] = $4;
   if ($4) {
    $2 = 27;
    while (1) {
     HEAP32[$7 + 12 >> 2] = $2;
     $1 = 5;
     block7 : {
      block4 : {
       switch (FUNCTION_TABLE[$5 | 0]($0, $4, $7 + 12 | 0, $6) | 0) {
       case 1:
        $1 = HEAP32[$7 + 12 >> 2];
        if ($1) {
         break block7
        }
        $1 = 2;
       default:
        HEAP32[HEAP32[$0 >> 2] >> 2] = $1;
        break block;
       case 3:
        break block;
       case 0:
        break block4;
       };
      }
      $1 = HEAP32[$7 + 12 >> 2];
     }
     $4 = $1 + $4 | 0;
     $2 = $2 - $1 | 0;
     if ($2) {
      continue
     }
     break;
    };
    $1 = HEAP32[$3 >> 2];
    HEAP32[$3 + 4 >> 2] = HEAPU8[$1 + 26 | 0] + 27;
    block9 : {
     if (!(HEAP8[$1 + 5 | 0] & 1 | (HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24)) != 1399285583 | (HEAPU8[$1 + 6 | 0] | HEAPU8[$1 + 7 | 0] << 8 | (HEAPU8[$1 + 8 | 0] << 16 | HEAPU8[$1 + 9 | 0] << 24) | (HEAPU8[$1 + 10 | 0] | HEAPU8[$1 + 11 | 0] << 8 | (HEAPU8[$1 + 12 | 0] << 16 | HEAPU8[$1 + 13 | 0] << 24))) != 0)) {
      $2 = HEAPU8[$1 + 26 | 0];
      if ($2) {
       break block9
      }
     }
     HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
     break block;
    }
    if (!full_read_($0, $1 + 27 | 0, $2, $5, $6)) {
     break block
    }
    $2 = HEAP32[$3 >> 2];
    $1 = HEAPU8[$2 + 26 | 0] - 1 | 0;
    if ($1) {
     $8 = $2 + 27 | 0;
     $4 = 0;
     while (1) {
      if (HEAPU8[$4 + $8 | 0] != 255) {
       HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
       $8 = 0;
       break block;
      }
      $4 = $4 + 1 | 0;
      if (($1 | 0) != ($4 | 0)) {
       continue
      }
      break;
     };
    }
    $1 = HEAPU8[($1 + $2 | 0) + 27 | 0] + Math_imul($1, 255) | 0;
    HEAP32[$3 + 12 >> 2] = $1;
    $2 = emscripten_builtin_malloc($1 >>> 0 <= 1 ? 1 : $1);
    HEAP32[$3 + 8 >> 2] = $2;
    if (!$2) {
     HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
     $8 = 0;
     break block;
    }
    $8 = 0;
    if (!full_read_($0, $2, $1, $5, $6)) {
     break block
    }
    $1 = HEAP32[$3 >> 2];
    HEAP32[$7 + 8 >> 2] = HEAPU8[$1 + 22 | 0] | HEAPU8[$1 + 23 | 0] << 8 | (HEAPU8[$1 + 24 | 0] << 16 | HEAPU8[$1 + 25 | 0] << 24);
    ogg_page_checksum_set($3);
    $1 = HEAP32[$3 >> 2];
    if (HEAP32[$7 + 8 >> 2] == (HEAPU8[$1 + 22 | 0] | HEAPU8[$1 + 23 | 0] << 8 | (HEAPU8[$1 + 24 | 0] << 16 | HEAPU8[$1 + 25 | 0] << 24))) {
     $8 = 1;
     break block;
    }
    HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
    break block;
   }
   HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
  }
  __stack_pointer = $7 + 16 | 0;
  return $8;
 }
 
 function full_read_($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0;
  $6 = __stack_pointer - 16 | 0;
  __stack_pointer = $6;
  $7 = 1;
  block : {
   if (!$2) {
    break block
   }
   while (1) {
    HEAP32[$6 + 12 >> 2] = $2;
    $5 = 5;
    block5 : {
     block1 : {
      switch (FUNCTION_TABLE[$3 | 0]($0, $1, $6 + 12 | 0, $4) | 0) {
      case 1:
       $5 = HEAP32[$6 + 12 >> 2];
       if ($5) {
        break block5
       }
       $5 = 2;
      default:
       HEAP32[HEAP32[$0 >> 2] >> 2] = $5;
      case 3:
       $7 = 0;
       break block;
      case 0:
       break block1;
      };
     }
     $5 = HEAP32[$6 + 12 >> 2];
    }
    $1 = $1 + $5 | 0;
    $2 = $2 - $5 | 0;
    if ($2) {
     continue
    }
    break;
   };
  }
  __stack_pointer = $6 + 16 | 0;
  return $7;
 }
 
 function simple_ogg_page__set_at($0, $1, $2, $3, $4, $5, $6) {
  block : {
   if (!$4) {
    break block
   }
   block2 : {
    block1 : {
     switch (FUNCTION_TABLE[$4 | 0]($0, $1, $2, $6) | 0) {
     case 0:
      break block1;
     case 1:
      break block2;
     default:
      break block;
     };
    }
    ogg_page_checksum_set($3);
    if (FUNCTION_TABLE[$5 | 0]($0, HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2], 0, 0, $6) | 0) {
     break block2
    }
    if (FUNCTION_TABLE[$5 | 0]($0, HEAP32[$3 + 8 >> 2], HEAP32[$3 + 12 >> 2], 0, 0, $6) | 0) {
     break block2
    }
    return 1;
   }
   HEAP32[HEAP32[$0 >> 2] >> 2] = 5;
  }
  return 0;
 }
 
 function __emscripten_stdout_close($0) {
  $0 = $0 | 0;
  return 0;
 }
 
 function __emscripten_stdout_seek($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  i64toi32_i32$HIGH_BITS = 0;
  return 0;
 }
 
 function strcmp($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = HEAPU8[$0 | 0];
  $3 = HEAPU8[$1 | 0];
  block : {
   if (!$2 | ($3 | 0) != ($2 | 0)) {
    break block
   }
   while (1) {
    $3 = HEAPU8[$1 + 1 | 0];
    $2 = HEAPU8[$0 + 1 | 0];
    if (!$2) {
     break block
    }
    $1 = $1 + 1 | 0;
    $0 = $0 + 1 | 0;
    if (($2 | 0) == ($3 | 0)) {
     continue
    }
    break;
   };
  }
  return $2 - $3 | 0;
 }
 
 function FLAC__add_metadata_block($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
  $3 = strlen(HEAP32[4305]);
  block : {
   if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 4 >> 2], HEAP32[1668])) {
    break block
   }
   if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 >> 2], HEAP32[1669])) {
    break block
   }
   $2 = HEAP32[$0 + 8 >> 2];
   $2 = HEAP32[$0 >> 2] == 4 ? ($2 + $3 | 0) - HEAP32[$0 + 16 >> 2] | 0 : $2;
   $4 = HEAP32[1670];
   if ($2 >>> $4 | 0) {
    break block
   }
   if (!FLAC__bitwriter_write_raw_uint32($1, $2, $4)) {
    break block
   }
   block10 : {
    block9 : {
     block8 : {
      block7 : {
       block6 : {
        block11 : {
         block4 : {
          switch (HEAP32[$0 >> 2]) {
          case 3:
           if (!HEAP32[$0 + 16 >> 2]) {
            break block10
           }
           $4 = HEAP32[1644];
           $6 = HEAP32[1643];
           $7 = HEAP32[1642];
           $2 = 0;
           break block11;
          case 0:
           if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 16 >> 2], HEAP32[1633])) {
            break block
           }
           if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 20 >> 2], HEAP32[1634])) {
            break block
           }
           if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 24 >> 2], HEAP32[1635])) {
            break block
           }
           if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 28 >> 2], HEAP32[1636])) {
            break block
           }
           if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 32 >> 2], HEAP32[1637])) {
            break block
           }
           if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 36 >> 2] - 1 | 0, HEAP32[1638])) {
            break block
           }
           if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 40 >> 2] - 1 | 0, HEAP32[1639])) {
            break block
           }
           if (!FLAC__bitwriter_write_raw_uint64($1, HEAP32[$0 + 48 >> 2], HEAP32[$0 + 52 >> 2], HEAP32[1640])) {
            break block
           }
           if (FLAC__bitwriter_write_byte_block($1, $0 + 56 | 0, 16)) {
            break block10
           }
           break block;
          case 1:
           if (FLAC__bitwriter_write_zeroes($1, HEAP32[$0 + 8 >> 2] << 3)) {
            break block10
           }
           break block;
          case 2:
           break block4;
          case 4:
           break block6;
          case 5:
           break block7;
          case 6:
           break block8;
          default:
           break block9;
          };
         }
         $2 = HEAP32[1641] >>> 3 | 0;
         if (!FLAC__bitwriter_write_byte_block($1, $0 + 16 | 0, $2)) {
          break block
         }
         if (FLAC__bitwriter_write_byte_block($1, HEAP32[$0 + 20 >> 2], HEAP32[$0 + 8 >> 2] - $2 | 0)) {
          break block10
         }
         break block;
        }
        while (1) {
         $3 = Math_imul($2, 24);
         $5 = $3 + HEAP32[$0 + 20 >> 2] | 0;
         if (!FLAC__bitwriter_write_raw_uint64($1, HEAP32[$5 >> 2], HEAP32[$5 + 4 >> 2], $7)) {
          break block
         }
         $5 = $3 + HEAP32[$0 + 20 >> 2] | 0;
         if (!FLAC__bitwriter_write_raw_uint64($1, HEAP32[$5 + 8 >> 2], HEAP32[$5 + 12 >> 2], $6)) {
          break block
         }
         if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[($3 + HEAP32[$0 + 20 >> 2] | 0) + 16 >> 2], $4)) {
          break block
         }
         $2 = $2 + 1 | 0;
         if ($2 >>> 0 < HEAPU32[$0 + 16 >> 2]) {
          continue
         }
         break;
        };
        break block10;
       }
       if (!FLAC__bitwriter_write_raw_uint32_little_endian($1, $3)) {
        break block
       }
       if (!FLAC__bitwriter_write_byte_block($1, HEAP32[4305], $3)) {
        break block
       }
       if (!FLAC__bitwriter_write_raw_uint32_little_endian($1, HEAP32[$0 + 24 >> 2])) {
        break block
       }
       if (!HEAP32[$0 + 24 >> 2]) {
        break block10
       }
       $2 = 0;
       while (1) {
        $3 = $2 << 3;
        if (!FLAC__bitwriter_write_raw_uint32_little_endian($1, HEAP32[$3 + HEAP32[$0 + 28 >> 2] >> 2])) {
         break block
        }
        $3 = $3 + HEAP32[$0 + 28 >> 2] | 0;
        if (!FLAC__bitwriter_write_byte_block($1, HEAP32[$3 + 4 >> 2], HEAP32[$3 >> 2])) {
         break block
        }
        $2 = $2 + 1 | 0;
        if ($2 >>> 0 < HEAPU32[$0 + 24 >> 2]) {
         continue
        }
        break;
       };
       break block10;
      }
      if (!FLAC__bitwriter_write_byte_block($1, $0 + 16 | 0, HEAP32[1655] >>> 3 | 0)) {
       break block
      }
      if (!FLAC__bitwriter_write_raw_uint64($1, HEAP32[$0 + 152 >> 2], HEAP32[$0 + 156 >> 2], HEAP32[1656])) {
       break block
      }
      if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 160 >> 2] != 0, HEAP32[1657])) {
       break block
      }
      if (!FLAC__bitwriter_write_zeroes($1, HEAP32[1658])) {
       break block
      }
      if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 164 >> 2], HEAP32[1659])) {
       break block
      }
      if (!HEAP32[$0 + 164 >> 2]) {
       break block10
      }
      $6 = HEAP32[1650] >>> 3 | 0;
      $7 = HEAP32[1647];
      $5 = HEAP32[1646];
      $9 = HEAP32[1645];
      $10 = HEAP32[1654];
      $11 = HEAP32[1653];
      $12 = HEAP32[1652];
      $13 = HEAP32[1651];
      $14 = HEAP32[1649];
      $15 = HEAP32[1648];
      $3 = 0;
      while (1) {
       $2 = HEAP32[$0 + 168 >> 2] + ($3 << 5) | 0;
       if (!FLAC__bitwriter_write_raw_uint64($1, HEAP32[$2 >> 2], HEAP32[$2 + 4 >> 2], $15)) {
        break block
       }
       if (!FLAC__bitwriter_write_raw_uint32($1, HEAPU8[$2 + 8 | 0], $14)) {
        break block
       }
       if (!FLAC__bitwriter_write_byte_block($1, $2 + 9 | 0, $6)) {
        break block
       }
       if (!FLAC__bitwriter_write_raw_uint32($1, HEAP8[$2 + 22 | 0] & 1, $13)) {
        break block
       }
       if (!FLAC__bitwriter_write_raw_uint32($1, HEAPU8[$2 + 22 | 0] >>> 1 & 1, $12)) {
        break block
       }
       if (!FLAC__bitwriter_write_zeroes($1, $11)) {
        break block
       }
       if (!FLAC__bitwriter_write_raw_uint32($1, HEAPU8[$2 + 23 | 0], $10)) {
        break block
       }
       block12 : {
        if (!HEAPU8[$2 + 23 | 0]) {
         break block12
        }
        $4 = 0;
        while (1) {
         $8 = HEAP32[$2 + 24 >> 2] + ($4 << 4) | 0;
         if (!FLAC__bitwriter_write_raw_uint64($1, HEAP32[$8 >> 2], HEAP32[$8 + 4 >> 2], $9)) {
          return 0
         }
         if (!FLAC__bitwriter_write_raw_uint32($1, HEAPU8[$8 + 8 | 0], $5)) {
          return 0
         }
         if (FLAC__bitwriter_write_zeroes($1, $7)) {
          $4 = $4 + 1 | 0;
          if ($4 >>> 0 >= HEAPU8[$2 + 23 | 0]) {
           break block12
          }
          continue;
         }
         break;
        };
        return 0;
       }
       $3 = $3 + 1 | 0;
       if ($3 >>> 0 < HEAPU32[$0 + 164 >> 2]) {
        continue
       }
       break;
      };
      break block10;
     }
     if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 16 >> 2], HEAP32[1660])) {
      break block
     }
     $2 = strlen(HEAP32[$0 + 20 >> 2]);
     if (!FLAC__bitwriter_write_raw_uint32($1, $2, HEAP32[1661])) {
      break block
     }
     if (!FLAC__bitwriter_write_byte_block($1, HEAP32[$0 + 20 >> 2], $2)) {
      break block
     }
     $2 = strlen(HEAP32[$0 + 24 >> 2]);
     if (!FLAC__bitwriter_write_raw_uint32($1, $2, HEAP32[1662])) {
      break block
     }
     if (!FLAC__bitwriter_write_byte_block($1, HEAP32[$0 + 24 >> 2], $2)) {
      break block
     }
     if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 28 >> 2], HEAP32[1663])) {
      break block
     }
     if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 32 >> 2], HEAP32[1664])) {
      break block
     }
     if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 36 >> 2], HEAP32[1665])) {
      break block
     }
     if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 40 >> 2], HEAP32[1666])) {
      break block
     }
     if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 44 >> 2], HEAP32[1667])) {
      break block
     }
     if (FLAC__bitwriter_write_byte_block($1, HEAP32[$0 + 48 >> 2], HEAP32[$0 + 44 >> 2])) {
      break block10
     }
     break block;
    }
    if (!FLAC__bitwriter_write_byte_block($1, HEAP32[$0 + 16 >> 2], HEAP32[$0 + 8 >> 2])) {
     break block
    }
   }
   $16 = 1;
  }
  return $16;
 }
 
 function FLAC__frame_add_header($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
  $4 = __stack_pointer - 16 | 0;
  __stack_pointer = $4;
  block1 : {
   if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[1671], HEAP32[1672])) {
    break block1
   }
   if (!FLAC__bitwriter_write_raw_uint32($1, 0, HEAP32[1673])) {
    break block1
   }
   if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 20 >> 2] != 0, HEAP32[1674])) {
    break block1
   }
   $6 = 16;
   $7 = 1;
   block5 : {
    block7 : {
     block15 : {
      block11 : {
       block9 : {
        block6 : {
         block14 : {
          block12 : {
           block8 : {
            $2 = HEAP32[$0 >> 2];
            if (($2 | 0) <= 2047) {
             if (($2 | 0) <= 575) {
              $3 = 1;
              if (($2 | 0) == 192) {
               break block5
              }
              if (($2 | 0) == 256) {
               break block6
              }
              if (($2 | 0) != 512) {
               break block7
              }
              $3 = 9;
              break block5;
             }
             if (($2 | 0) == 576) {
              break block8
             }
             if (($2 | 0) == 1024) {
              break block9
             }
             if (($2 | 0) != 1152) {
              break block7
             }
             $3 = 3;
             break block5;
            }
            if (($2 | 0) <= 4607) {
             if (($2 | 0) == 2048) {
              break block11
             }
             if (($2 | 0) == 2304) {
              break block12
             }
             if (($2 | 0) != 4096) {
              break block7
             }
             $3 = 12;
             break block5;
            }
            if (($2 | 0) <= 16383) {
             if (($2 | 0) == 4608) {
              break block14
             }
             if (($2 | 0) != 8192) {
              break block7
             }
             $3 = 13;
             break block5;
            }
            if (($2 | 0) == 16384) {
             break block15
            }
            if (($2 | 0) != 32768) {
             break block7
            }
            $3 = 15;
            break block5;
           }
           $3 = 2;
           break block5;
          }
          $3 = 4;
          break block5;
         }
         $3 = 5;
         break block5;
        }
        $3 = 8;
        break block5;
       }
       $3 = 10;
       break block5;
      }
      $3 = 11;
      break block5;
     }
     $3 = 14;
     break block5;
    }
    $2 = $2 >>> 0 < 257;
    $6 = $2 ? 8 : 16;
    $7 = 0;
    $3 = $2 ? 6 : 7;
   }
   if (!FLAC__bitwriter_write_raw_uint32($1, $3, HEAP32[1675])) {
    break block1
   }
   block20 : {
    block19 : {
     block26 : {
      block25 : {
       block24 : {
        block22 : {
         block21 : {
          block18 : {
           $2 = HEAP32[$0 + 4 >> 2];
           if (($2 | 0) <= 44099) {
            if (($2 | 0) <= 22049) {
             if (($2 | 0) == 8e3) {
              break block18
             }
             if (($2 | 0) != 16e3) {
              break block19
             }
             $2 = 5;
             break block20;
            }
            if (($2 | 0) == 22050) {
             break block21
            }
            if (($2 | 0) == 24e3) {
             break block22
            }
            if (($2 | 0) != 32e3) {
             break block19
            }
            $2 = 8;
            break block20;
           }
           if (($2 | 0) <= 95999) {
            if (($2 | 0) == 44100) {
             break block24
            }
            if (($2 | 0) == 48e3) {
             break block25
            }
            if (($2 | 0) != 88200) {
             break block19
            }
            $2 = 1;
            break block20;
           }
           if (($2 | 0) == 96e3) {
            break block26
           }
           if (($2 | 0) != 192e3) {
            if (($2 | 0) != 176400) {
             break block19
            }
            $2 = 2;
            break block20;
           }
           $2 = 3;
           break block20;
          }
          $2 = 4;
          break block20;
         }
         $2 = 6;
         break block20;
        }
        $2 = 7;
        break block20;
       }
       $2 = 9;
       break block20;
      }
      $2 = 10;
      break block20;
     }
     $2 = 11;
     break block20;
    }
    if (!(($2 >>> 0) % 1e3 | $2 >>> 0 > 255e3)) {
     $2 = 12;
     $5 = 12;
     break block20;
    }
    if (!(($2 >>> 0) % 10 | 0)) {
     $2 = 14;
     $5 = 14;
     break block20;
    }
    $2 = $2 >>> 0 < 65536 ? 13 : 0;
    $5 = $2;
   }
   if (!FLAC__bitwriter_write_raw_uint32($1, $2, HEAP32[1676])) {
    break block1
   }
   block34 : {
    block33 : {
     switch (HEAP32[$0 + 12 >> 2]) {
     case 0:
      $2 = HEAP32[$0 + 8 >> 2] - 1 | 0;
      break block34;
     case 1:
      $2 = 8;
      break block34;
     case 2:
      $2 = 9;
      break block34;
     case 3:
      break block33;
     default:
      break block34;
     };
    }
    $2 = 10;
   }
   if (!FLAC__bitwriter_write_raw_uint32($1, $2, HEAP32[1677])) {
    break block1
   }
   $2 = __wasm_rotl_i32(HEAP32[$0 + 16 >> 2] - 8 | 0, 30);
   if ($2 >>> 0 <= 4) {
    $2 = HEAP32[($2 << 2) + 12104 >> 2]
   } else {
    $2 = 0
   }
   if (!FLAC__bitwriter_write_raw_uint32($1, $2, HEAP32[1678])) {
    break block1
   }
   if (!FLAC__bitwriter_write_raw_uint32($1, 0, HEAP32[1679])) {
    break block1
   }
   block37 : {
    if (!HEAP32[$0 + 20 >> 2]) {
     $2 = HEAP32[$0 + 24 >> 2];
     if (($2 | 0) >= 0) {
      __inlined_func$FLAC__bitwriter_write_utf8_uint32$61 : {
       if ($2 >>> 0 <= 127) {
        $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, $2, 8);
        break __inlined_func$FLAC__bitwriter_write_utf8_uint32$61;
       }
       if ($2 >>> 0 <= 2047) {
        $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 6 | 192, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 & 63 | 128, 8);
        break __inlined_func$FLAC__bitwriter_write_utf8_uint32$61;
       }
       if ($2 >>> 0 <= 65535) {
        $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 12 | 224, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 6 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 & 63 | 128, 8);
        break __inlined_func$FLAC__bitwriter_write_utf8_uint32$61;
       }
       if ($2 >>> 0 <= 2097151) {
        $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 18 | 240, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 12 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 6 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 & 63 | 128, 8);
        break __inlined_func$FLAC__bitwriter_write_utf8_uint32$61;
       }
       if ($2 >>> 0 <= 67108863) {
        $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 24 | 248, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 18 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 12 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 6 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 & 63 | 128, 8);
        break __inlined_func$FLAC__bitwriter_write_utf8_uint32$61;
       }
       $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 30 | 252, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 24 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 18 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 12 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 6 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 & 63 | 128, 8);
      }
     } else {
      $2 = 0
     }
     if ($2) {
      break block37
     }
     break block1;
    }
    $3 = HEAP32[$0 + 28 >> 2];
    if ($3 >>> 0 <= 15) {
     $2 = HEAP32[$0 + 24 >> 2];
     __inlined_func$FLAC__bitwriter_write_utf8_uint64$62 : {
      if (!(!$3 & $2 >>> 0 > 127 | ($3 | 0) != 0)) {
       $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, $2, 8);
       break __inlined_func$FLAC__bitwriter_write_utf8_uint64$62;
      }
      if (!(!$3 & $2 >>> 0 > 2047 | ($3 | 0) != 0)) {
       $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, ($3 & 63) << 26 | $2 >>> 6 | 192, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 & 63 | 128, 8);
       break __inlined_func$FLAC__bitwriter_write_utf8_uint64$62;
      }
      if (!(!$3 & $2 >>> 0 > 65535 | ($3 | 0) != 0)) {
       $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, ($3 & 4095) << 20 | $2 >>> 12 | 224, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 6 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 & 63 | 128, 8);
       break __inlined_func$FLAC__bitwriter_write_utf8_uint64$62;
      }
      if (!(!$3 & $2 >>> 0 > 2097151 | ($3 | 0) != 0)) {
       $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, ($3 & 262143) << 14 | $2 >>> 18 | 240, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 12 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 6 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 & 63 | 128, 8);
       break __inlined_func$FLAC__bitwriter_write_utf8_uint64$62;
      }
      if (!(!$3 & $2 >>> 0 > 67108863 | ($3 | 0) != 0)) {
       $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, ($3 & 16777215) << 8 | $2 >>> 24 | 248, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 18 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 12 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 6 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 & 63 | 128, 8);
       break __inlined_func$FLAC__bitwriter_write_utf8_uint64$62;
      }
      if (!(!$3 & $2 >>> 0 > 2147483647 | ($3 | 0) != 0)) {
       $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, ($3 & 1073741823) << 2 | $2 >>> 30 | 252, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 24 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 18 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 12 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 6 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 & 63 | 128, 8);
       break __inlined_func$FLAC__bitwriter_write_utf8_uint64$62;
      }
      $2 = FLAC__bitwriter_write_raw_uint32_nocheck($1, 254, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, ($3 & 1073741823) << 2 | $2 >>> 30 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 24 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 18 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 12 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 >>> 6 & 63 | 128, 8) & FLAC__bitwriter_write_raw_uint32_nocheck($1, $2 & 63 | 128, 8);
     }
    } else {
     $2 = 0
    }
    if (!$2) {
     break block1
    }
   }
   if (!$7) {
    if (!FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 >> 2] - 1 | 0, $6)) {
     break block1
    }
   }
   block42 : {
    block41 : {
     switch ($5 - 12 | 0) {
     case 0:
      if (FLAC__bitwriter_write_raw_uint32($1, HEAPU32[$0 + 4 >> 2] / 1e3 | 0, 8)) {
       break block42
      }
      break block1;
     case 1:
      if (FLAC__bitwriter_write_raw_uint32($1, HEAP32[$0 + 4 >> 2], 16)) {
       break block42
      }
      break block1;
     case 2:
      break block41;
     default:
      break block42;
     };
    }
    if (!FLAC__bitwriter_write_raw_uint32($1, HEAPU32[$0 + 4 >> 2] / 10 | 0, 16)) {
     break block1
    }
   }
   $2 = $4 + 15 | 0;
   $0 = __stack_pointer - 16 | 0;
   __stack_pointer = $0;
   if (FLAC__bitwriter_get_buffer($1, $0 + 12 | 0, $0 + 8 | 0)) {
    (wasm2js_i32$0 = $2, wasm2js_i32$1 = FLAC__crc8(HEAP32[$0 + 12 >> 2], HEAP32[$0 + 8 >> 2])), HEAP8[wasm2js_i32$0 | 0] = wasm2js_i32$1;
    $2 = 1;
   } else {
    $2 = 0
   }
   __stack_pointer = $0 + 16 | 0;
   if (!$2) {
    break block1
   }
   $8 = (FLAC__bitwriter_write_raw_uint32($1, HEAPU8[$4 + 15 | 0], HEAP32[1680]) | 0) != 0;
  }
  __stack_pointer = $4 + 16 | 0;
  return $8;
 }
 
 function add_residual_partitioned_rice_($0, $1, $2, $3, $4, $5, $6, $7) {
  var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
  $12 = HEAP32[($7 ? 6752 : 6748) >> 2];
  $9 = HEAP32[($7 ? 6740 : 6736) >> 2];
  block3 : {
   block2 : {
    if (!$6) {
     if (!HEAP32[$5 >> 2]) {
      if (!FLAC__bitwriter_write_raw_uint32($0, HEAP32[$4 >> 2], $9)) {
       break block2
      }
      if (!FLAC__bitwriter_write_rice_signed_block($0, $1, $2, HEAP32[$4 >> 2])) {
       break block2
      }
      break block3;
     }
     if (!FLAC__bitwriter_write_raw_uint32($0, $12, $9)) {
      break block2
     }
     if (!FLAC__bitwriter_write_raw_uint32($0, HEAP32[$5 >> 2], HEAP32[1686])) {
      break block2
     }
     if (!$2) {
      break block3
     }
     $7 = 0;
     while (1) {
      if (FLAC__bitwriter_write_raw_int32($0, HEAP32[($7 << 2) + $1 >> 2], HEAP32[$5 >> 2])) {
       $7 = $7 + 1 | 0;
       if (($2 | 0) != ($7 | 0)) {
        continue
       }
       break block3;
      }
      break;
     };
     return 0;
    }
    $15 = $2 + $3 >>> $6 | 0;
    $16 = HEAP32[1686];
    $2 = 0;
    while (1) {
     $7 = $2;
     $13 = $15 - ($10 ? 0 : $3) | 0;
     $2 = $7 + $13 | 0;
     $14 = $10 << 2;
     $8 = $14 + $5 | 0;
     block6 : {
      if (!HEAP32[$8 >> 2]) {
       $11 = 0;
       $8 = $4 + $14 | 0;
       if (!FLAC__bitwriter_write_raw_uint32($0, HEAP32[$8 >> 2], $9)) {
        break block2
       }
       if (FLAC__bitwriter_write_rice_signed_block($0, ($7 << 2) + $1 | 0, $13, HEAP32[$8 >> 2])) {
        break block6
       }
       break block2;
      }
      $11 = 0;
      if (!FLAC__bitwriter_write_raw_uint32($0, $12, $9)) {
       break block2
      }
      if (!FLAC__bitwriter_write_raw_uint32($0, HEAP32[$8 >> 2], $16)) {
       break block2
      }
      if ($2 >>> 0 <= $7 >>> 0) {
       break block6
      }
      while (1) {
       if (!FLAC__bitwriter_write_raw_int32($0, HEAP32[($7 << 2) + $1 >> 2], HEAP32[$8 >> 2])) {
        break block2
       }
       $7 = $7 + 1 | 0;
       if (($7 | 0) != ($2 | 0)) {
        continue
       }
       break;
      };
     }
     $11 = 1;
     $10 = $10 + 1 | 0;
     if (!($10 >>> $6 | 0)) {
      continue
     }
     break;
    };
   }
   return $11;
  }
  return 1;
 }
 
 function strncmp($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if (!$2) {
   return 0
  }
  $3 = HEAPU8[$0 | 0];
  if ($3) {
   block3 : {
    while (1) {
     $4 = HEAPU8[$1 | 0];
     if (($3 | 0) != ($4 | 0) | !$4) {
      break block3
     }
     $2 = $2 - 1 | 0;
     if (!$2) {
      break block3
     }
     $1 = $1 + 1 | 0;
     $3 = HEAPU8[$0 + 1 | 0];
     $0 = $0 + 1 | 0;
     if ($3) {
      continue
     }
     break;
    };
    $3 = 0;
   }
  } else {
   $3 = 0
  }
  return $3 - HEAPU8[$1 | 0] | 0;
 }
 
 function __shlim($0) {
  var $1 = 0;
  HEAP32[$0 + 112 >> 2] = 0;
  HEAP32[$0 + 116 >> 2] = 0;
  $1 = HEAP32[$0 + 44 >> 2] - HEAP32[$0 + 4 >> 2] | 0;
  HEAP32[$0 + 120 >> 2] = $1;
  HEAP32[$0 + 124 >> 2] = $1 >> 31;
  HEAP32[$0 + 104 >> 2] = HEAP32[$0 + 8 >> 2];
 }
 
 function __shgetc($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  $1 = HEAP32[$0 + 4 >> 2];
  $7 = HEAP32[$0 + 44 >> 2];
  $3 = $1 - $7 | 0;
  $5 = $3 + HEAP32[$0 + 120 >> 2] | 0;
  block2 : {
   $4 = HEAP32[$0 + 112 >> 2];
   $6 = HEAP32[$0 + 116 >> 2];
   $2 = HEAP32[$0 + 124 >> 2] + ($3 >> 31) | 0;
   $3 = $3 >>> 0 > $5 >>> 0 ? $2 + 1 | 0 : $2;
   if (!(($6 | 0) <= ($3 | 0) & $5 >>> 0 >= $4 >>> 0 | ($3 | 0) > ($6 | 0) ? $4 | $6 : 0)) {
    $1 = __stack_pointer - 16 | 0;
    __stack_pointer = $1;
    $7 = -1;
    $6 = HEAP32[$0 + 72 >> 2];
    HEAP32[$0 + 72 >> 2] = $6 - 1 | $6;
    if (HEAP32[$0 + 20 >> 2] != HEAP32[$0 + 28 >> 2]) {
     FUNCTION_TABLE[HEAP32[$0 + 36 >> 2]]($0, 0, 0) | 0
    }
    HEAP32[$0 + 28 >> 2] = 0;
    HEAP32[$0 + 16 >> 2] = 0;
    HEAP32[$0 + 20 >> 2] = 0;
    $6 = HEAP32[$0 >> 2];
    __inlined_func$__toread$64 : {
     if ($6 & 4) {
      HEAP32[$0 >> 2] = $6 | 32;
      $2 = -1;
      break __inlined_func$__toread$64;
     }
     $4 = HEAP32[$0 + 44 >> 2] + HEAP32[$0 + 48 >> 2] | 0;
     HEAP32[$0 + 8 >> 2] = $4;
     HEAP32[$0 + 4 >> 2] = $4;
     $2 = $6 << 27 >> 31;
    }
    block : {
     if ($2) {
      break block
     }
     if ((FUNCTION_TABLE[HEAP32[$0 + 32 >> 2]]($0, $1 + 15 | 0, 1) | 0) != 1) {
      break block
     }
     $7 = HEAPU8[$1 + 15 | 0];
    }
    __stack_pointer = $1 + 16 | 0;
    if (($7 | 0) >= 0) {
     break block2
    }
    $7 = HEAP32[$0 + 44 >> 2];
    $1 = HEAP32[$0 + 4 >> 2];
   }
   HEAP32[$0 + 112 >> 2] = -1;
   HEAP32[$0 + 116 >> 2] = -1;
   HEAP32[$0 + 104 >> 2] = $1;
   $2 = $5;
   $5 = $7 - $1 | 0;
   $1 = $2 + $5 | 0;
   HEAP32[$0 + 120 >> 2] = $1;
   $2 = $0;
   $0 = ($5 >> 31) + $3 | 0;
   HEAP32[$2 + 124 >> 2] = $1 >>> 0 < $5 >>> 0 ? $0 + 1 | 0 : $0;
   return -1;
  }
  $2 = $3;
  $1 = $3 + 1 | 0;
  $3 = $5 + 1 | 0;
  $6 = $3 ? $2 : $1;
  $5 = HEAP32[$0 + 4 >> 2];
  $1 = HEAP32[$0 + 8 >> 2];
  $4 = HEAP32[$0 + 112 >> 2];
  $2 = HEAP32[$0 + 116 >> 2];
  block3 : {
   if (!($4 | $2)) {
    break block3
   }
   $2 = $2 - ($6 + ($3 >>> 0 > $4 >>> 0) | 0) | 0;
   $8 = $1 - $5 | 0;
   $9 = $8 >> 31;
   $4 = $4 - $3 | 0;
   if (($2 | 0) >= ($9 | 0) & $4 >>> 0 >= $8 >>> 0 | ($2 | 0) > ($9 | 0)) {
    break block3
   }
   $1 = $5 + $4 | 0;
  }
  HEAP32[$0 + 104 >> 2] = $1;
  $2 = $3;
  $1 = HEAP32[$0 + 44 >> 2];
  $3 = $1 - $5 | 0;
  $4 = $2 + $3 | 0;
  HEAP32[$0 + 120 >> 2] = $4;
  $2 = $0;
  $0 = ($3 >> 31) + $6 | 0;
  HEAP32[$2 + 124 >> 2] = $3 >>> 0 > $4 >>> 0 ? $0 + 1 | 0 : $0;
  if ($1 >>> 0 >= $5 >>> 0) {
   HEAP8[$5 - 1 | 0] = $7
  }
  return $7;
 }
 
 function __floatsitf($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $3 = __stack_pointer - 16 | 0;
  __stack_pointer = $3;
  block1 : {
   if (!$1) {
    $1 = 0;
    $5 = 0;
    break block1;
   }
   $2 = $1 >> 31;
   $4 = ($2 ^ $1) - $2 | 0;
   $2 = Math_clz32($4);
   __ashlti3($3, $4, 0, 0, 0, $2 + 81 | 0);
   $4 = 0 + HEAP32[$3 + 8 >> 2] | 0;
   $2 = (HEAP32[$3 + 12 >> 2] ^ 65536) + (16414 - $2 << 16) | 0;
   $2 = $4 >>> 0 < $5 >>> 0 ? $2 + 1 | 0 : $2;
   $1 = $1 & -2147483648 | $2;
   $2 = HEAP32[$3 + 4 >> 2];
   $5 = HEAP32[$3 >> 2];
  }
  HEAP32[$0 >> 2] = $5;
  HEAP32[$0 + 4 >> 2] = $2;
  HEAP32[$0 + 8 >> 2] = $4;
  HEAP32[$0 + 12 >> 2] = $1;
  __stack_pointer = $3 + 16 | 0;
 }
 
 function __multf3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0;
  $10 = __stack_pointer - 96 | 0;
  __stack_pointer = $10;
  $14 = $8 & 65535;
  $13 = ($4 ^ $8) & -2147483648;
  $15 = $4 & 65535;
  $25 = $15;
  $42 = $8 >>> 16 & 32767;
  $43 = $4 >>> 16 & 32767;
  block3 : {
   block1 : {
    if ($43 - 32767 >>> 0 >= 4294934530) {
     if ($42 - 32767 >>> 0 > 4294934529) {
      break block1
     }
    }
    $11 = $4 & 2147483647;
    $16 = $11;
    $9 = $3;
    if (!(!$9 & ($11 | 0) == 2147418112 ? !($1 | $2) : $11 >>> 0 < 2147418112)) {
     $17 = $9;
     $13 = $4 | 32768;
     break block3;
    }
    $11 = $8 & 2147483647;
    $19 = $11;
    $4 = $7;
    if (!(!$4 & ($11 | 0) == 2147418112 ? !($5 | $6) : $11 >>> 0 < 2147418112)) {
     $17 = $4;
     $13 = $8 | 32768;
     $1 = $5;
     $2 = $6;
     break block3;
    }
    if (!($1 | $9 | ($16 ^ 2147418112 | $2))) {
     if (!($4 | $5 | ($6 | $19))) {
      $13 = 2147450880;
      $1 = 0;
      $2 = 0;
      break block3;
     }
     $13 = $13 | 2147418112;
     $1 = 0;
     $2 = 0;
     break block3;
    }
    if (!($4 | $5 | ($19 ^ 2147418112 | $6))) {
     $4 = $1 | $9;
     $3 = $2 | $16;
     $1 = 0;
     $2 = 0;
     if (!($3 | $4)) {
      $13 = 2147450880;
      break block3;
     }
     $13 = $13 | 2147418112;
     break block3;
    }
    if (!($1 | $9 | ($2 | $16))) {
     $1 = 0;
     $2 = 0;
     break block3;
    }
    if (!($4 | $5 | ($6 | $19))) {
     $1 = 0;
     $2 = 0;
     break block3;
    }
    if ($16 >>> 0 <= 65535) {
     $9 = !($3 | $15);
     $8 = $9 ? $1 : $3;
     $11 = $9 << 6;
     $4 = Math_clz32($8) + 32 | 0;
     $8 = Math_clz32($9 ? $2 : $15);
     $8 = $11 + (($8 | 0) == 32 ? $4 : $8) | 0;
     __ashlti3($10 + 80 | 0, $1, $2, $3, $15, $8 - 15 | 0);
     $36 = 16 - $8 | 0;
     $3 = HEAP32[$10 + 88 >> 2];
     $25 = HEAP32[$10 + 92 >> 2];
     $2 = HEAP32[$10 + 84 >> 2];
     $1 = HEAP32[$10 + 80 >> 2];
    }
    if ($19 >>> 0 > 65535) {
     break block1
    }
    $8 = !($7 | $14);
    $4 = $8 ? $5 : $7;
    $15 = $8 << 6;
    $9 = Math_clz32($4) + 32 | 0;
    $4 = Math_clz32($8 ? $6 : $14);
    $4 = $15 + (($4 | 0) == 32 ? $9 : $4) | 0;
    __ashlti3($10 - -64 | 0, $5, $6, $7, $14, $4 - 15 | 0);
    $36 = ($36 - $4 | 0) + 16 | 0;
    $7 = HEAP32[$10 + 72 >> 2];
    $14 = HEAP32[$10 + 76 >> 2];
    $5 = HEAP32[$10 + 64 >> 2];
    $6 = HEAP32[$10 + 68 >> 2];
   }
   $4 = $6 << 15 | $5 >>> 17;
   $8 = $5 << 15;
   $5 = 0;
   $20 = $8 & -32768;
   $37 = $2;
   $19 = __wasm_i64_mul($20, $5, $2, 0);
   $5 = i64toi32_i32$HIGH_BITS;
   $27 = $5;
   $38 = $4;
   $22 = $1;
   $1 = __wasm_i64_mul($4, 0, $1, 0);
   $4 = $1 + $19 | 0;
   $5 = i64toi32_i32$HIGH_BITS + $5 | 0;
   $5 = $1 >>> 0 > $4 >>> 0 ? $5 + 1 | 0 : $5;
   $2 = 0;
   $1 = __wasm_i64_mul($20, $23, $22, $23);
   $16 = $2 + $1 | 0;
   $9 = i64toi32_i32$HIGH_BITS + $4 | 0;
   $9 = $1 >>> 0 > $16 >>> 0 ? $9 + 1 | 0 : $9;
   $15 = $9;
   $21 = ($4 | 0) == ($9 | 0) & $2 >>> 0 > $16 >>> 0 | $4 >>> 0 > $9 >>> 0;
   $39 = $3;
   $26 = __wasm_i64_mul($20, $23, $3, 0);
   $40 = i64toi32_i32$HIGH_BITS;
   $1 = __wasm_i64_mul($38, $24, $37, $24);
   $18 = $1 + $26 | 0;
   $9 = i64toi32_i32$HIGH_BITS + $40 | 0;
   $9 = $1 >>> 0 > $18 >>> 0 ? $9 + 1 | 0 : $9;
   $11 = $9;
   $1 = $14 << 15 | $7 >>> 17;
   $28 = $7 << 15 | $6 >>> 17;
   $3 = __wasm_i64_mul($28, 0, $22, $23);
   $29 = $3 + $18 | 0;
   $9 = i64toi32_i32$HIGH_BITS + $9 | 0;
   $9 = $3 >>> 0 > $29 >>> 0 ? $9 + 1 | 0 : $9;
   $30 = $9;
   $3 = $9;
   $2 = 0;
   $9 = ($5 | 0) == ($27 | 0) & $4 >>> 0 < $19 >>> 0 | $5 >>> 0 < $27 >>> 0;
   $31 = $5 + $29 | 0;
   $4 = ($2 | $9) + $3 | 0;
   $4 = $5 >>> 0 > $31 >>> 0 ? $4 + 1 | 0 : $4;
   $8 = $4;
   $6 = $31;
   $32 = $25 | 65536;
   $25 = __wasm_i64_mul($20, $23, $32, $12);
   $41 = i64toi32_i32$HIGH_BITS;
   $3 = __wasm_i64_mul($38, $24, $39, $12);
   $33 = $3 + $25 | 0;
   $9 = i64toi32_i32$HIGH_BITS + $41 | 0;
   $9 = $3 >>> 0 > $33 >>> 0 ? $9 + 1 | 0 : $9;
   $7 = $9;
   $34 = $1 | -2147483648;
   $1 = __wasm_i64_mul($34, 0, $22, $23);
   $20 = $1 + $33 | 0;
   $9 = i64toi32_i32$HIGH_BITS + $9 | 0;
   $9 = $1 >>> 0 > $20 >>> 0 ? $9 + 1 | 0 : $9;
   $3 = __wasm_i64_mul($28, $12, $37, $24);
   $1 = $3 + $20 | 0;
   $35 = $9;
   $5 = $9 + i64toi32_i32$HIGH_BITS | 0;
   $27 = $1;
   $19 = $1 >>> 0 < $3 >>> 0 ? $5 + 1 | 0 : $5;
   $9 = $1;
   $1 = 0;
   $22 = $1 + $6 | 0;
   $9 = $4 + $9 | 0;
   $9 = $1 >>> 0 > $22 >>> 0 ? $9 + 1 | 0 : $9;
   $23 = $9;
   $1 = $21 + $22 | 0;
   $2 = $1 >>> 0 < $22 >>> 0 ? $9 + 1 | 0 : $9;
   $21 = (($42 + $43 | 0) + $36 | 0) - 16383 | 0;
   $4 = __wasm_i64_mul($34, $12, $37, $24);
   $6 = i64toi32_i32$HIGH_BITS;
   $5 = __wasm_i64_mul($38, $24, $32, $12);
   $3 = $5 + $4 | 0;
   $9 = i64toi32_i32$HIGH_BITS + $6 | 0;
   $9 = $3 >>> 0 < $5 >>> 0 ? $9 + 1 | 0 : $9;
   $14 = ($6 | 0) == ($9 | 0) & $3 >>> 0 < $4 >>> 0 | $6 >>> 0 > $9 >>> 0;
   $6 = __wasm_i64_mul($28, $12, $39, $12);
   $4 = $6 + $3 | 0;
   $5 = i64toi32_i32$HIGH_BITS + $9 | 0;
   $5 = $4 >>> 0 < $6 >>> 0 ? $5 + 1 | 0 : $5;
   $6 = $5;
   $3 = ($9 | 0) == ($5 | 0) & $3 >>> 0 > $4 >>> 0 | $5 >>> 0 < $9 >>> 0;
   $9 = 0;
   $5 = $3;
   $3 = $3 + $14 | 0;
   $9 = $5 >>> 0 > $3 >>> 0 ? 1 : $9;
   $5 = $3;
   $3 = __wasm_i64_mul($34, $12, $32, $12);
   $5 = $5 + $3 | 0;
   $9 = i64toi32_i32$HIGH_BITS + $9 | 0;
   $24 = $5;
   $3 = $3 >>> 0 > $5 >>> 0 ? $9 + 1 | 0 : $9;
   $9 = ($11 | 0) == ($40 | 0) & $18 >>> 0 < $26 >>> 0 | $11 >>> 0 < $40 >>> 0;
   $5 = 0;
   $11 = ($11 | 0) == ($30 | 0) & $18 >>> 0 > $29 >>> 0 | $11 >>> 0 > $30 >>> 0;
   $14 = $11;
   $11 = $9 + $11 | 0;
   $9 = ($14 >>> 0 > $11 >>> 0 ? 1 : $5) + $6 | 0;
   $5 = $4 + $11 | 0;
   $9 = $5 >>> 0 < $11 >>> 0 ? $9 + 1 | 0 : $9;
   $14 = $9;
   $26 = $5;
   $4 = ($6 | 0) == ($9 | 0) & $4 >>> 0 > $5 >>> 0 | $6 >>> 0 > $9 >>> 0;
   $9 = $3;
   $3 = $4 + $24 | 0;
   $9 = $3 >>> 0 < $4 >>> 0 ? $9 + 1 | 0 : $9;
   $11 = $3;
   $6 = __wasm_i64_mul($28, $12, $32, $12);
   $18 = i64toi32_i32$HIGH_BITS;
   $5 = __wasm_i64_mul($34, $12, $39, $12);
   $3 = $5 + $6 | 0;
   $4 = i64toi32_i32$HIGH_BITS + $18 | 0;
   $4 = $3 >>> 0 < $5 >>> 0 ? $4 + 1 | 0 : $4;
   $9 = (($18 | 0) == ($4 | 0) & $3 >>> 0 < $6 >>> 0 | $4 >>> 0 < $18 >>> 0) + $9 | 0;
   $11 = $4 + $11 | 0;
   $18 = $11;
   $6 = $11 >>> 0 < $4 >>> 0 ? $9 + 1 | 0 : $9;
   $4 = $3;
   $3 = 0;
   $12 = $3 + $26 | 0;
   $9 = $4 + $14 | 0;
   $4 = $6;
   $9 = $3 >>> 0 > $12 >>> 0 ? $9 + 1 | 0 : $9;
   $11 = $9;
   $3 = ($14 | 0) == ($9 | 0) & $12 >>> 0 < $26 >>> 0 | $9 >>> 0 < $14 >>> 0;
   $5 = $3;
   $3 = $3 + $18 | 0;
   $4 = $5 >>> 0 > $3 >>> 0 ? $4 + 1 | 0 : $4;
   $14 = $3;
   $3 = $4;
   $6 = $19;
   $4 = 0;
   $5 = ($7 | 0) == ($41 | 0) & $25 >>> 0 > $33 >>> 0 | $7 >>> 0 < $41 >>> 0;
   $7 = ($7 | 0) == ($35 | 0) & $20 >>> 0 < $33 >>> 0 | $7 >>> 0 > $35 >>> 0;
   $5 = $5 + $7 | 0;
   $7 = ($6 | 0) == ($35 | 0) & $20 >>> 0 > $27 >>> 0 | $6 >>> 0 < $35 >>> 0;
   $5 = $5 + $7 | 0;
   $7 = $6;
   $6 = $6 + $12 | 0;
   $4 = ($4 | $5) + $11 | 0;
   $9 = $3;
   $4 = $6 >>> 0 < $7 >>> 0 ? $4 + 1 | 0 : $4;
   $7 = $4;
   $4 = ($11 | 0) == ($4 | 0) & $6 >>> 0 < $12 >>> 0 | $4 >>> 0 < $11 >>> 0;
   $3 = $4 + $14 | 0;
   $9 = $4 >>> 0 > $3 >>> 0 ? $9 + 1 | 0 : $9;
   $12 = $3;
   $5 = $9;
   $9 = 0;
   $4 = ($8 | 0) == ($23 | 0) & $22 >>> 0 < $31 >>> 0 | $8 >>> 0 > $23 >>> 0;
   $3 = $4 + (($8 | 0) == ($30 | 0) & $29 >>> 0 > $31 >>> 0 | $8 >>> 0 < $30 >>> 0) | 0;
   $4 = ($4 >>> 0 > $3 >>> 0 ? 1 : $9) + $7 | 0;
   $9 = $5;
   $5 = $3;
   $3 = $3 + $6 | 0;
   $4 = $5 >>> 0 > $3 >>> 0 ? $4 + 1 | 0 : $4;
   $6 = ($7 | 0) == ($4 | 0) & $3 >>> 0 < $6 >>> 0 | $4 >>> 0 < $7 >>> 0;
   $7 = $6 + $12 | 0;
   $9 = $6 >>> 0 > $7 >>> 0 ? $9 + 1 | 0 : $9;
   $8 = $9;
   block13 : {
    if ($9 & 65536) {
     $21 = $21 + 1 | 0;
     break block13;
    }
    $12 = $15 >>> 31 | 0;
    $5 = 0;
    $9 = $8 << 1 | $7 >>> 31;
    $7 = $7 << 1 | $4 >>> 31;
    $8 = $9;
    $9 = $4 << 1 | $3 >>> 31;
    $3 = $3 << 1 | $2 >>> 31;
    $4 = $9;
    $9 = $15 << 1 | $16 >>> 31;
    $16 = $16 << 1;
    $15 = $9;
    $9 = $2 << 1 | $1 >>> 31;
    $1 = $1 << 1 | $12;
    $2 = $5 | $9;
   }
   if (($21 | 0) >= 32767) {
    $13 = $13 | 2147418112;
    $1 = 0;
    $2 = 0;
    break block3;
   }
   block17 : {
    if (($21 | 0) <= 0) {
     $6 = 1 - $21 | 0;
     if ($6 >>> 0 <= 127) {
      $5 = $21 + 127 | 0;
      __ashlti3($10 + 48 | 0, $16, $15, $1, $2, $5);
      __ashlti3($10 + 32 | 0, $3, $4, $7, $8, $5);
      __lshrti3($10 + 16 | 0, $16, $15, $1, $2, $6);
      __lshrti3($10, $3, $4, $7, $8, $6);
      $16 = HEAP32[$10 + 32 >> 2] | HEAP32[$10 + 16 >> 2] | (HEAP32[$10 + 48 >> 2] | HEAP32[$10 + 56 >> 2] | (HEAP32[$10 + 52 >> 2] | HEAP32[$10 + 60 >> 2])) != 0;
      $15 = HEAP32[$10 + 36 >> 2] | HEAP32[$10 + 20 >> 2];
      $1 = HEAP32[$10 + 40 >> 2] | HEAP32[$10 + 24 >> 2];
      $2 = HEAP32[$10 + 44 >> 2] | HEAP32[$10 + 28 >> 2];
      $8 = HEAP32[$10 + 12 >> 2];
      $3 = HEAP32[$10 >> 2];
      $4 = HEAP32[$10 + 4 >> 2];
      $7 = HEAP32[$10 + 8 >> 2];
      break block17;
     }
     $1 = 0;
     $2 = 0;
     break block3;
    }
    $8 = $8 & 65535 | $21 << 16;
   }
   $17 = $7 | $17;
   $13 = $8 | $13;
   if (!(!$1 & ($2 | 0) == -2147483648 ? !($16 | $15) : ($2 | 0) >= 0)) {
    $1 = $3 + 1 | 0;
    $4 = $1 ? $4 : $4 + 1 | 0;
    $2 = $4;
    $3 = !($4 | $1);
    $4 = $13;
    $17 = $3 + $17 | 0;
    $13 = $17 >>> 0 < $3 >>> 0 ? $4 + 1 | 0 : $4;
    break block3;
   }
   if ($1 | $16 | ($2 ^ -2147483648 | $15)) {
    $1 = $3;
    $2 = $4;
    break block3;
   }
   $9 = $13;
   $1 = $3 & 1;
   $2 = $1;
   $1 = $1 + $3 | 0;
   $2 = $2 >>> 0 > $1 >>> 0 ? $4 + 1 | 0 : $4;
   $3 = ($4 | 0) == ($2 | 0) & $1 >>> 0 < $3 >>> 0 | $2 >>> 0 < $4 >>> 0;
   $17 = $3 + $17 | 0;
   $13 = $3 >>> 0 > $17 >>> 0 ? $9 + 1 | 0 : $9;
  }
  HEAP32[$0 >> 2] = $1;
  HEAP32[$0 + 4 >> 2] = $2;
  HEAP32[$0 + 8 >> 2] = $17;
  HEAP32[$0 + 12 >> 2] = $13;
  __stack_pointer = $10 + 96 | 0;
 }
 
 function __addtf3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
  $10 = __stack_pointer - 112 | 0;
  __stack_pointer = $10;
  $9 = $8 & 2147483647;
  block3 : {
   block1 : {
    $11 = $4 & 2147483647;
    $14 = !($1 | $2);
    if (!($3 | $11 ? $11 - 2147418112 >>> 0 < 2147549184 : $14)) {
     $12 = $9 - 2147418112 | 0;
     if (!$7 & ($12 | 0) == -2147418112 ? $5 | $6 : ($12 | 0) == -2147418112 & ($7 | 0) != 0 | $12 >>> 0 > 2147549184) {
      break block1
     }
    }
    if (!(!$3 & ($11 | 0) == 2147418112 ? $14 : $11 >>> 0 < 2147418112)) {
     $7 = $3;
     $8 = $4 | 32768;
     $5 = $1;
     $6 = $2;
     break block3;
    }
    if (!(!$7 & ($9 | 0) == 2147418112 ? !($5 | $6) : $9 >>> 0 < 2147418112)) {
     $8 = $8 | 32768;
     break block3;
    }
    if (!($1 | $3 | ($11 ^ 2147418112 | $2))) {
     $9 = $3;
     $3 = !($1 ^ $5 | $3 ^ $7 | ($2 ^ $6 | $4 ^ $8 ^ -2147483648));
     $7 = $3 ? 0 : $9;
     $8 = $3 ? 2147450880 : $4;
     $5 = $3 ? 0 : $1;
     $6 = $3 ? 0 : $2;
     break block3;
    }
    $12 = $5 | $7;
    if (!($12 | ($9 ^ 2147418112 | $6))) {
     break block3
    }
    if (!($1 | $3 | ($2 | $11))) {
     if ($6 | $9 | $12) {
      break block3
     }
     $5 = $1 & $5;
     $6 = $2 & $6;
     $7 = $3 & $7;
     $8 = $4 & $8;
     break block3;
    }
    if ($5 | $7 | ($6 | $9)) {
     break block1
    }
    $5 = $1;
    $6 = $2;
    $7 = $3;
    $8 = $4;
    break block3;
   }
   $12 = ($9 | 0) == ($11 | 0);
   $12 = $12 & ($3 | 0) == ($7 | 0) ? ($2 | 0) == ($6 | 0) & $1 >>> 0 < $5 >>> 0 | $2 >>> 0 < $6 >>> 0 : $12 & $3 >>> 0 < $7 >>> 0 | $9 >>> 0 > $11 >>> 0;
   $9 = $12;
   $14 = $9 ? $5 : $1;
   $17 = $9 ? $6 : $2;
   $13 = $9 ? $8 : $4;
   $18 = $13;
   $11 = $9 ? $7 : $3;
   $3 = $9 ? $3 : $7;
   $7 = $9 ? $4 : $8;
   $16 = $7;
   $7 = $7 >>> 16 & 32767;
   $13 = $13 & 65535;
   $9 = $18 >>> 16 & 32767;
   block7 : {
    if ($9) {
     break block7
    }
    $15 = $11;
    $9 = !($11 | $13);
    $19 = Math_clz32($9 ? $14 : $11) + 32 | 0;
    $11 = Math_clz32($9 ? $17 : $13);
    $9 = (($11 | 0) == 32 ? $19 : $11) + ($9 << 6) | 0;
    __ashlti3($10 + 96 | 0, $14, $17, $15, $13, $9 - 15 | 0);
    $9 = 16 - $9 | 0;
    $11 = HEAP32[$10 + 104 >> 2];
    $14 = HEAP32[$10 + 96 >> 2];
    $17 = HEAP32[$10 + 100 >> 2];
    $13 = HEAP32[$10 + 108 >> 2];
   }
   $15 = $13;
   $5 = $12 ? $1 : $5;
   $6 = $12 ? $2 : $6;
   $1 = $3;
   $2 = $16 & 65535;
   if (!$7) {
    $7 = $2;
    $1 = !($1 | $2);
    $2 = Math_clz32($1 ? $6 : $2);
    $1 = (($2 | 0) == 32 ? Math_clz32($1 ? $5 : $3) + 32 | 0 : $2) + ($1 << 6) | 0;
    __ashlti3($10 + 80 | 0, $5, $6, $3, $7, $1 - 15 | 0);
    $7 = 16 - $1 | 0;
    $2 = HEAP32[$10 + 92 >> 2];
    $5 = HEAP32[$10 + 80 >> 2];
    $6 = HEAP32[$10 + 84 >> 2];
    $1 = HEAP32[$10 + 88 >> 2];
   }
   $2 = $2 << 3 | $1 >>> 29 | 524288;
   $13 = $11 << 3 | $17 >>> 29;
   $15 = $15 << 3 | $11 >>> 29;
   $11 = $5 << 3;
   $12 = $6 << 3 | $5 >>> 29;
   $4 = $4 ^ $8;
   $1 = $1 << 3 | $6 >>> 29;
   block9 : {
    if (($7 | 0) == ($9 | 0)) {
     break block9
    }
    $3 = $9 - $7 | 0;
    if ($3 >>> 0 > 127) {
     $2 = 0;
     $11 = 1;
     $12 = 0;
     $1 = 0;
     break block9;
    }
    __ashlti3($10 - -64 | 0, $11, $12, $1, $2, 128 - $3 | 0);
    __lshrti3($10 + 48 | 0, $11, $12, $1, $2, $3);
    $11 = HEAP32[$10 + 48 >> 2] | (HEAP32[$10 + 64 >> 2] | HEAP32[$10 + 72 >> 2] | (HEAP32[$10 + 68 >> 2] | HEAP32[$10 + 76 >> 2])) != 0;
    $12 = HEAP32[$10 + 52 >> 2];
    $2 = HEAP32[$10 + 60 >> 2];
    $1 = HEAP32[$10 + 56 >> 2];
   }
   $16 = $1;
   $15 = $15 | 524288;
   $1 = $14 << 3;
   $14 = $17 << 3 | $14 >>> 29;
   block12 : {
    if (($4 | 0) < 0) {
     $5 = 0;
     $6 = 0;
     $7 = 0;
     $8 = 0;
     if (!($1 ^ $11 | $13 ^ $16 | ($12 ^ $14 | $2 ^ $15))) {
      break block3
     }
     $3 = $1 - $11 | 0;
     $1 = $1 >>> 0 < $11 >>> 0;
     $4 = $14 - ($1 + $12 | 0) | 0;
     $5 = $13 - $16 | 0;
     $1 = $1 & ($12 | 0) == ($14 | 0) | $12 >>> 0 > $14 >>> 0;
     $7 = $5 - $1 | 0;
     $1 = ($15 - (($13 >>> 0 < $16 >>> 0) + $2 | 0) | 0) - ($1 >>> 0 > $5 >>> 0) | 0;
     $8 = $1;
     if ($1 >>> 0 > 524287) {
      break block12
     }
     $2 = !($1 | $7);
     $1 = Math_clz32($2 ? $4 : $1);
     $1 = ((($1 | 0) == 32 ? Math_clz32($2 ? $3 : $7) + 32 | 0 : $1) + ($2 << 6) | 0) - 12 | 0;
     __ashlti3($10 + 32 | 0, $3, $4, $7, $8, $1);
     $9 = $9 - $1 | 0;
     $7 = HEAP32[$10 + 40 >> 2];
     $8 = HEAP32[$10 + 44 >> 2];
     $3 = HEAP32[$10 + 32 >> 2];
     $4 = HEAP32[$10 + 36 >> 2];
     break block12;
    }
    $2 = $2 + $15 | 0;
    $4 = $2 + 1 | 0;
    $3 = $2;
    $2 = $13 + $16 | 0;
    $3 = $2 >>> 0 < $13 >>> 0 ? $4 : $3;
    $6 = $3 + 1 | 0;
    $5 = $3;
    $3 = $12 + $14 | 0;
    $7 = $3 + 1 | 0;
    $4 = $3;
    $3 = $1 + $11 | 0;
    $4 = $3 >>> 0 < $1 >>> 0 ? $7 : $4;
    $1 = ($12 | 0) == ($4 | 0) & $3 >>> 0 < $11 >>> 0 | $4 >>> 0 < $12 >>> 0;
    $7 = $1 + $2 | 0;
    $8 = $1 >>> 0 > $7 >>> 0 ? $6 : $5;
    if (!($8 & 1048576)) {
     break block12
    }
    $3 = $11 & 1 | (($4 & 1) << 31 | $3 >>> 1);
    $4 = $7 << 31 | $4 >>> 1;
    $9 = $9 + 1 | 0;
    $7 = ($8 & 1) << 31 | $7 >>> 1;
    $8 = $8 >>> 1 | 0;
   }
   $1 = $18 & -2147483648;
   $5 = $1;
   if (($9 | 0) >= 32767) {
    $7 = 0;
    $8 = $1 | 2147418112;
    $5 = 0;
    $6 = 0;
    break block3;
   }
   $2 = 0;
   block15 : {
    if (($9 | 0) > 0) {
     $2 = $9;
     break block15;
    }
    __ashlti3($10 + 16 | 0, $3, $4, $7, $8, $9 + 127 | 0);
    __lshrti3($10, $3, $4, $7, $8, 1 - $9 | 0);
    $3 = HEAP32[$10 >> 2] | (HEAP32[$10 + 16 >> 2] | HEAP32[$10 + 24 >> 2] | (HEAP32[$10 + 20 >> 2] | HEAP32[$10 + 28 >> 2])) != 0;
    $4 = HEAP32[$10 + 4 >> 2];
    $7 = HEAP32[$10 + 8 >> 2];
    $8 = HEAP32[$10 + 12 >> 2];
   }
   $9 = ($4 & 7) << 29 | $3 >>> 3;
   $1 = $7 << 29 | $4 >>> 3;
   $4 = ($8 & 7) << 29 | $7 >>> 3;
   $2 = $5 | ($8 >>> 3 & 65535 | $2 << 16);
   block21 : {
    block19 : {
     $3 = $3 & 7;
     if (($3 | 0) != 4) {
      $13 = $2 + 1 | 0;
      $8 = $2;
      $2 = $3 >>> 0 > 4;
      $5 = $2 + $9 | 0;
      $2 = $2 >>> 0 > $5 >>> 0 ? $1 + 1 | 0 : $1;
      $6 = $2;
      $1 = ($1 | 0) == ($2 | 0) & $5 >>> 0 < $9 >>> 0 | $1 >>> 0 > $2 >>> 0;
      $7 = $1 + $4 | 0;
      $8 = $1 >>> 0 > $7 >>> 0 ? $13 : $8;
      break block19;
     }
     $8 = $2 + 1 | 0;
     $3 = $2;
     $2 = $9 & 1;
     $5 = $2 + $9 | 0;
     $2 = $2 >>> 0 > $5 >>> 0 ? $1 + 1 | 0 : $1;
     $6 = $2;
     $1 = ($1 | 0) == ($2 | 0) & $5 >>> 0 < $9 >>> 0 | $1 >>> 0 > $2 >>> 0;
     $7 = $1 + $4 | 0;
     $8 = $1 >>> 0 > $7 >>> 0 ? $8 : $3;
     break block21;
    }
    if (!$3) {
     break block3
    }
   }
  }
  HEAP32[$0 >> 2] = $5;
  HEAP32[$0 + 4 >> 2] = $6;
  HEAP32[$0 + 8 >> 2] = $7;
  HEAP32[$0 + 12 >> 2] = $8;
  __stack_pointer = $10 + 112 | 0;
 }
 
 function __extenddftf2($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  $6 = __stack_pointer - 16 | 0;
  __stack_pointer = $6;
  wasm2js_scratch_store_f64(+$1);
  $4 = wasm2js_scratch_load_i32(1) | 0;
  $3 = wasm2js_scratch_load_i32(0) | 0;
  $9 = $4;
  $2 = $4 & 1048575;
  $5 = $4 >>> 20 & 2047;
  block2 : {
   if ($5 | 0) {
    if (!(!$7 & ($5 | 0) == 2047)) {
     $4 = $2 >>> 4 | 0;
     $8 = ($2 & 15) << 28 | $3 >>> 4;
     $3 = $3 << 28;
     $2 = $5 + 15360 | 0;
     $5 = $2 >>> 0 < 15360 ? $7 + 1 | 0 : $7;
     break block2;
    }
    $4 = $2 >>> 4 | 0;
    $8 = ($2 & 15) << 28 | $3 >>> 4;
    $3 = $3 << 28;
    $2 = 32767;
    $5 = 0;
    break block2;
   }
   if (!($2 | $3)) {
    $3 = 0;
    $4 = 0;
    $2 = 0;
    $5 = 0;
    break block2;
   }
   $4 = $2;
   $2 = Math_clz32($2);
   $2 = ($2 | 0) == 32 ? Math_clz32($3) + 32 | 0 : $2;
   __ashlti3($6, $3, $4, 0, 0, $2 + 49 | 0);
   $8 = HEAP32[$6 + 8 >> 2];
   $4 = HEAP32[$6 + 12 >> 2] ^ 65536;
   $2 = 15372 - $2 | 0;
   $7 = HEAP32[$6 >> 2];
   $3 = HEAP32[$6 + 4 >> 2];
   $5 = 0;
  }
  HEAP32[$0 >> 2] = $7;
  HEAP32[$0 + 4 >> 2] = $3;
  HEAP32[$0 + 8 >> 2] = $8;
  HEAP32[$0 + 12 >> 2] = $4 | ($9 & -2147483648 | $2 << 16);
  __stack_pointer = $6 + 16 | 0;
 }
 
 function __letf2($0, $1, $2, $3, $4, $5, $6, $7) {
  var $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  $9 = 1;
  $8 = $3 & 2147483647;
  $11 = $8;
  $10 = ($8 | 0) == 2147418112;
  block : {
   if ($10 & !$2 ? $0 | $1 : $10 & ($2 | 0) != 0 | $8 >>> 0 > 2147418112) {
    break block
   }
   $8 = $7 & 2147483647;
   if (!$6 & ($8 | 0) == 2147418112 ? $4 | $5 : ($8 | 0) == 2147418112 & ($6 | 0) != 0 | $8 >>> 0 > 2147418112) {
    break block
   }
   if (!($0 | $4 | ($2 | $6) | ($1 | $5 | ($8 | $11)))) {
    return 0
   }
   if (($3 & $7) >= 0) {
    if (($2 | 0) == ($6 | 0) & ($3 | 0) == ($7 | 0) ? ($1 | 0) == ($5 | 0) & $0 >>> 0 < $4 >>> 0 | $1 >>> 0 < $5 >>> 0 : $2 >>> 0 < $6 >>> 0 & ($3 | 0) <= ($7 | 0) | ($3 | 0) < ($7 | 0)) {
     return -1
    }
    return ($0 ^ $4 | $2 ^ $6 | ($1 ^ $5 | $3 ^ $7)) != 0;
   }
   if (($2 | 0) == ($6 | 0) & ($3 | 0) == ($7 | 0) ? ($1 | 0) == ($5 | 0) & $0 >>> 0 > $4 >>> 0 | $1 >>> 0 > $5 >>> 0 : $2 >>> 0 > $6 >>> 0 & ($3 | 0) >= ($7 | 0) | ($3 | 0) > ($7 | 0)) {
    return -1
   }
   $9 = ($0 ^ $4 | $2 ^ $6 | ($1 ^ $5 | $3 ^ $7)) != 0;
  }
  return $9;
 }
 
 function __getf2($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0;
  $7 = -1;
  $6 = $3 & 2147483647;
  $5 = ($6 | 0) == 2147418112;
  block : {
   if ($5 & !$2 ? $0 | $1 : $5 & ($2 | 0) != 0 | $6 >>> 0 > 2147418112) {
    break block
   }
   $5 = $4 & 2147483647;
   if ((($5 | 0) == 2147418112 & 0 | $5 >>> 0 > 2147418112) & ($5 | 0) != 2147418112) {
    break block
   }
   if (!($0 | $2 | ($1 | ($5 | $6)))) {
    return 0
   }
   if (($3 & $4) >= 0) {
    if (!$2 & ($3 | 0) == ($4 | 0) ? 0 : ($3 | 0) < ($4 | 0)) {
     break block
    }
    return ($0 | $2 | ($1 | $3 ^ $4)) != 0;
   }
   if (!$2 & ($3 | 0) == ($4 | 0) ? $1 | !$1 & ($0 | 0) != 0 : ($2 | 0) != 0 & ($3 | 0) >= ($4 | 0) | ($3 | 0) > ($4 | 0)) {
    break block
   }
   $7 = ($0 | $2 | ($1 | $3 ^ $4)) != 0;
  }
  return $7;
 }
 
 function scalbn($0, $1) {
  block2 : {
   if (($1 | 0) >= 1024) {
    $0 = $0 * 8988465674311579538646525.0e283;
    if ($1 >>> 0 < 2047) {
     $1 = $1 - 1023 | 0;
     break block2;
    }
    $0 = $0 * 8988465674311579538646525.0e283;
    $1 = ($1 >>> 0 >= 3069 ? 3069 : $1) - 2046 | 0;
    break block2;
   }
   if (($1 | 0) > -1023) {
    break block2
   }
   $0 = $0 * 2.004168360008973e-292;
   if ($1 >>> 0 > 4294965304) {
    $1 = $1 + 969 | 0;
    break block2;
   }
   $0 = $0 * 2.004168360008973e-292;
   $1 = ($1 >>> 0 <= 4294964336 ? -2960 : $1) + 1938 | 0;
  }
  wasm2js_scratch_store_i32(0, 0);
  wasm2js_scratch_store_i32(1, $1 + 1023 << 20);
  return $0 * +wasm2js_scratch_load_f64();
 }
 
 function copysignl($0, $1, $2, $3, $4, $5) {
  HEAP32[$0 >> 2] = $1;
  HEAP32[$0 + 4 >> 2] = $2;
  HEAP32[$0 + 8 >> 2] = $3;
  HEAP32[$0 + 12 >> 2] = $4 & 65535 | ($5 >>> 16 & 32768 | ($4 & 2147418112) >>> 16) << 16;
 }
 
 function __floatunsitf($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $2 = __stack_pointer - 16 | 0;
  __stack_pointer = $2;
  block1 : {
   if (!$1) {
    $1 = 0;
    $3 = 0;
    break block1;
   }
   $3 = $1;
   $1 = Math_clz32($1);
   __ashlti3($2, $3, 0, 0, 0, 112 - ($1 ^ 31) | 0);
   $4 = 0 + HEAP32[$2 + 8 >> 2] | 0;
   $1 = (HEAP32[$2 + 12 >> 2] ^ 65536) + (16414 - $1 << 16) | 0;
   $1 = $5 >>> 0 > $4 >>> 0 ? $1 + 1 | 0 : $1;
   $5 = HEAP32[$2 + 4 >> 2];
   $3 = HEAP32[$2 >> 2];
  }
  HEAP32[$0 >> 2] = $3;
  HEAP32[$0 + 4 >> 2] = $5;
  HEAP32[$0 + 8 >> 2] = $4;
  HEAP32[$0 + 12 >> 2] = $1;
  __stack_pointer = $2 + 16 | 0;
 }
 
 function __subtf3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0;
  $9 = __stack_pointer - 16 | 0;
  __stack_pointer = $9;
  __addtf3($9, $1, $2, $3, $4, $5, $6, $7, $8 ^ -2147483648);
  $3 = HEAP32[$9 >> 2];
  $2 = HEAP32[$9 + 4 >> 2];
  $1 = HEAP32[$9 + 12 >> 2];
  HEAP32[$0 + 8 >> 2] = HEAP32[$9 + 8 >> 2];
  HEAP32[$0 + 12 >> 2] = $1;
  HEAP32[$0 >> 2] = $3;
  HEAP32[$0 + 4 >> 2] = $2;
  __stack_pointer = $9 + 16 | 0;
 }
 
 function scalbnl($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = __stack_pointer - 80 | 0;
  __stack_pointer = $6;
  block2 : {
   if (($5 | 0) >= 16384) {
    __multf3($6 + 32 | 0, $1, $2, $3, $4, 0, 0, 0, 2147352576);
    $3 = HEAP32[$6 + 40 >> 2];
    $4 = HEAP32[$6 + 44 >> 2];
    $1 = HEAP32[$6 + 32 >> 2];
    $2 = HEAP32[$6 + 36 >> 2];
    if ($5 >>> 0 < 32767) {
     $5 = $5 - 16383 | 0;
     break block2;
    }
    __multf3($6 + 16 | 0, $1, $2, $3, $4, 0, 0, 0, 2147352576);
    $5 = ($5 >>> 0 >= 49149 ? 49149 : $5) - 32766 | 0;
    $3 = HEAP32[$6 + 24 >> 2];
    $4 = HEAP32[$6 + 28 >> 2];
    $1 = HEAP32[$6 + 16 >> 2];
    $2 = HEAP32[$6 + 20 >> 2];
    break block2;
   }
   if (($5 | 0) > -16383) {
    break block2
   }
   __multf3($6 - -64 | 0, $1, $2, $3, $4, 0, 0, 0, 7471104);
   $3 = HEAP32[$6 + 72 >> 2];
   $4 = HEAP32[$6 + 76 >> 2];
   $1 = HEAP32[$6 + 64 >> 2];
   $2 = HEAP32[$6 + 68 >> 2];
   if ($5 >>> 0 > 4294934644) {
    $5 = $5 + 16269 | 0;
    break block2;
   }
   __multf3($6 + 48 | 0, $1, $2, $3, $4, 0, 0, 0, 7471104);
   $5 = ($5 >>> 0 <= 4294918376 ? -48920 : $5) + 32538 | 0;
   $3 = HEAP32[$6 + 56 >> 2];
   $4 = HEAP32[$6 + 60 >> 2];
   $1 = HEAP32[$6 + 48 >> 2];
   $2 = HEAP32[$6 + 52 >> 2];
  }
  __multf3($6, $1, $2, $3, $4, 0, 0, 0, $5 + 16383 << 16);
  $1 = HEAP32[$6 + 12 >> 2];
  HEAP32[$0 + 8 >> 2] = HEAP32[$6 + 8 >> 2];
  HEAP32[$0 + 12 >> 2] = $1;
  $1 = HEAP32[$6 + 4 >> 2];
  HEAP32[$0 >> 2] = HEAP32[$6 >> 2];
  HEAP32[$0 + 4 >> 2] = $1;
  __stack_pointer = $6 + 80 | 0;
 }
 
 function __multi3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0, $10 = 0, $11 = 0, $12 = 0;
  $7 = __wasm_i64_mul($7, $8, $1, $2);
  $8 = i64toi32_i32$HIGH_BITS;
  $9 = $7;
  $7 = __wasm_i64_mul($3, $4, $5, $6);
  $3 = $9 + $7 | 0;
  $4 = i64toi32_i32$HIGH_BITS + $8 | 0;
  $4 = $3 >>> 0 < $7 >>> 0 ? $4 + 1 | 0 : $4;
  $7 = $3;
  $10 = $6;
  $3 = 0;
  $6 = $3;
  $9 = $2;
  $8 = __wasm_i64_mul($10, $3, $2, 0);
  $7 = $8 + $7 | 0;
  $2 = i64toi32_i32$HIGH_BITS + $4 | 0;
  $11 = $7;
  $4 = $7 >>> 0 < $8 >>> 0 ? $2 + 1 | 0 : $2;
  $7 = $1;
  $8 = __wasm_i64_mul($5, 0, $7, 0);
  $1 = i64toi32_i32$HIGH_BITS;
  $2 = 0;
  $5 = __wasm_i64_mul($5, $2, $9, $3);
  $3 = $1 + $5 | 0;
  $1 = i64toi32_i32$HIGH_BITS + $2 | 0;
  $2 = $3;
  $5 = $2 >>> 0 < $5 >>> 0 ? $1 + 1 | 0 : $1;
  $1 = $5 + $11 | 0;
  $9 = $1;
  $5 = $1 >>> 0 < $5 >>> 0 ? $4 + 1 | 0 : $4;
  $2 = __wasm_i64_mul($10, $6, $7, $12);
  $1 = $3 + $2 | 0;
  $3 = i64toi32_i32$HIGH_BITS;
  $7 = $1 >>> 0 < $2 >>> 0 ? $3 + 1 | 0 : $3;
  $6 = $7 + $9 | 0;
  $2 = $5;
  HEAP32[$0 + 8 >> 2] = $6;
  HEAP32[$0 + 12 >> 2] = $6 >>> 0 < $7 >>> 0 ? $2 + 1 | 0 : $2;
  HEAP32[$0 >> 2] = $8;
  HEAP32[$0 + 4 >> 2] = $1;
 }
 
 function __divtf3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0;
  $10 = __stack_pointer - 336 | 0;
  __stack_pointer = $10;
  $11 = $7;
  $12 = $8 & 65535;
  $13 = $3;
  $15 = $4 & 65535;
  $19 = ($4 ^ $8) & -2147483648;
  $16 = $8 >>> 16 & 32767;
  $24 = $4 >>> 16 & 32767;
  block3 : {
   block1 : {
    if ($24 - 32767 >>> 0 >= 4294934530) {
     if ($16 - 32767 >>> 0 > 4294934529) {
      break block1
     }
    }
    $9 = $4 & 2147483647;
    if (!(!$3 & ($9 | 0) == 2147418112 ? !($1 | $2) : $9 >>> 0 < 2147418112)) {
     $22 = $3;
     $19 = $4 | 32768;
     break block3;
    }
    $4 = $8 & 2147483647;
    if (!(!$7 & ($4 | 0) == 2147418112 ? !($5 | $6) : $4 >>> 0 < 2147418112)) {
     $22 = $7;
     $19 = $8 | 32768;
     $1 = $5;
     $2 = $6;
     break block3;
    }
    if (!($1 | $3 | ($9 ^ 2147418112 | $2))) {
     if (!($5 | $7 | ($4 ^ 2147418112 | $6))) {
      $1 = 0;
      $2 = 0;
      $19 = 2147450880;
      break block3;
     }
     $19 = $19 | 2147418112;
     $1 = 0;
     $2 = 0;
     break block3;
    }
    if (!($5 | $7 | ($4 ^ 2147418112 | $6))) {
     $1 = 0;
     $2 = 0;
     break block3;
    }
    if (!($1 | $3 | ($2 | $9))) {
     $1 = !($5 | $7 | ($4 | $6));
     $22 = $1 ? 0 : $22;
     $19 = $1 ? 2147450880 : $19;
     $1 = 0;
     $2 = 0;
     break block3;
    }
    if (!($5 | $7 | ($4 | $6))) {
     $19 = $19 | 2147418112;
     $1 = 0;
     $2 = 0;
     break block3;
    }
    if ($9 >>> 0 <= 65535) {
     $3 = !($13 | $15);
     $8 = $3;
     $9 = $3 ? $1 : $13;
     $3 = $3 << 6;
     $8 = Math_clz32($8 ? $2 : $15);
     $3 = $3 + (($8 | 0) == 32 ? Math_clz32($9) + 32 | 0 : $8) | 0;
     __ashlti3($10 + 320 | 0, $1, $2, $13, $15, $3 - 15 | 0);
     $17 = 16 - $3 | 0;
     $13 = HEAP32[$10 + 328 >> 2];
     $15 = HEAP32[$10 + 332 >> 2];
     $2 = HEAP32[$10 + 324 >> 2];
     $1 = HEAP32[$10 + 320 >> 2];
    }
    if ($4 >>> 0 > 65535) {
     break block1
    }
    $3 = !($11 | $12);
    $7 = $3;
    $8 = $3 ? $5 : $11;
    $3 = $3 << 6;
    $7 = Math_clz32($7 ? $6 : $12);
    $3 = $3 + (($7 | 0) == 32 ? Math_clz32($8) + 32 | 0 : $7) | 0;
    __ashlti3($10 + 304 | 0, $5, $6, $11, $12, $3 - 15 | 0);
    $17 = ($3 + $17 | 0) - 16 | 0;
    $11 = HEAP32[$10 + 312 >> 2];
    $12 = HEAP32[$10 + 316 >> 2];
    $5 = HEAP32[$10 + 304 >> 2];
    $6 = HEAP32[$10 + 308 >> 2];
   }
   $4 = 0;
   $7 = $12 | 65536;
   $25 = $7;
   $26 = $11;
   $3 = $11;
   $9 = $7 << 15 | $3 >>> 17;
   $3 = $3 << 15 | $6 >>> 17;
   $7 = 0 - $3 | 0;
   $4 = $4 | $9;
   $8 = 1963258675 - ($4 + (($3 | 0) != 0) | 0) | 0;
   __multi3($10 + 288 | 0, $3, $4, 0, 0, $7, $8, 0, 0);
   $9 = HEAP32[$10 + 296 >> 2];
   __multi3($10 + 272 | 0, 0 - $9 | 0, 0 - (HEAP32[$10 + 300 >> 2] + (($9 | 0) != 0) | 0) | 0, 0, 0, $7, $8, 0, 0);
   $12 = HEAP32[$10 + 276 >> 2] >>> 31 | 0;
   $8 = 0;
   $7 = HEAP32[$10 + 280 >> 2];
   $9 = HEAP32[$10 + 284 >> 2] << 1 | $7 >>> 31;
   $7 = $7 << 1 | $12;
   $8 = $8 | $9;
   __multi3($10 + 256 | 0, $7, $8, 0, 0, $3, $4, 0, 0);
   $9 = HEAP32[$10 + 264 >> 2];
   __multi3($10 + 240 | 0, $7, $8, 0, 0, 0 - $9 | 0, 0 - (HEAP32[$10 + 268 >> 2] + (($9 | 0) != 0) | 0) | 0, 0, 0);
   $12 = HEAP32[$10 + 244 >> 2] >>> 31 | 0;
   $8 = 0;
   $7 = HEAP32[$10 + 248 >> 2];
   $9 = HEAP32[$10 + 252 >> 2] << 1 | $7 >>> 31;
   $7 = $7 << 1 | $12;
   $8 = $8 | $9;
   __multi3($10 + 224 | 0, $7, $8, 0, 0, $3, $4, 0, 0);
   $9 = HEAP32[$10 + 232 >> 2];
   __multi3($10 + 208 | 0, $7, $8, 0, 0, 0 - $9 | 0, 0 - (HEAP32[$10 + 236 >> 2] + (($9 | 0) != 0) | 0) | 0, 0, 0);
   $12 = HEAP32[$10 + 212 >> 2] >>> 31 | 0;
   $8 = 0;
   $7 = HEAP32[$10 + 216 >> 2];
   $9 = HEAP32[$10 + 220 >> 2] << 1 | $7 >>> 31;
   $7 = $7 << 1 | $12;
   $8 = $8 | $9;
   __multi3($10 + 192 | 0, $7, $8, 0, 0, $3, $4, 0, 0);
   $9 = HEAP32[$10 + 200 >> 2];
   __multi3($10 + 176 | 0, $7, $8, 0, 0, 0 - $9 | 0, 0 - (HEAP32[$10 + 204 >> 2] + (($9 | 0) != 0) | 0) | 0, 0, 0);
   $12 = $10 + 160 | 0;
   $7 = $3;
   $11 = $4;
   $4 = HEAP32[$10 + 180 >> 2] >>> 31 | 0;
   $3 = HEAP32[$10 + 184 >> 2];
   $8 = (HEAP32[$10 + 188 >> 2] << 1 | $3 >>> 31) - 1 | 0;
   $4 = ($3 << 1 | $4) - 1 | 0;
   $8 = ($4 | 0) != -1 ? $8 + 1 | 0 : $8;
   $3 = $8;
   __multi3($12, $7, $11, 0, 0, $4, $3, 0, 0);
   __multi3($10 + 144 | 0, $5 << 15, $6 << 15 | $5 >>> 17, 0, 0, $4, $3, 0, 0);
   $28 = HEAP32[$10 + 168 >> 2];
   $8 = HEAP32[$10 + 172 >> 2];
   $12 = HEAP32[$10 + 160 >> 2];
   $7 = HEAP32[$10 + 152 >> 2];
   $11 = $12 + $7 | 0;
   $14 = HEAP32[$10 + 164 >> 2];
   $9 = $14 + HEAP32[$10 + 156 >> 2] | 0;
   $9 = $7 >>> 0 > $11 >>> 0 ? $9 + 1 | 0 : $9;
   $7 = $9;
   $12 = ($14 | 0) == ($9 | 0) & $11 >>> 0 < $12 >>> 0 | $9 >>> 0 < $14 >>> 0;
   $9 = $8;
   $14 = $12 + $28 | 0;
   $8 = $14 >>> 0 < $12 >>> 0 ? $9 + 1 | 0 : $9;
   $12 = !$7 & $11 >>> 0 > 1 | ($7 | 0) != 0;
   $9 = $12 + $14 | 0;
   $8 = $12 >>> 0 > $9 >>> 0 ? $8 + 1 | 0 : $8;
   __multi3($10 + 112 | 0, $4, $3, 0, 0, 0 - $9 | 0, 0 - ((($9 | 0) != 0) + $8 | 0) | 0, 0, 0);
   __multi3($10 + 128 | 0, 1 - $11 | 0, 0 - (($11 >>> 0 > 1) + $7 | 0) | 0, 0, 0, $4, $3, 0, 0);
   $34 = ($24 - $16 | 0) + $17 | 0;
   $4 = HEAP32[$10 + 116 >> 2];
   $20 = $4;
   $3 = HEAP32[$10 + 112 >> 2];
   $9 = $4 << 1 | $3 >>> 31;
   $7 = $3 << 1;
   $11 = $9;
   $4 = $9;
   $8 = 0;
   $9 = HEAP32[$10 + 140 >> 2];
   $29 = $9;
   $3 = HEAP32[$10 + 136 >> 2];
   $9 = $9 << 1 | $3 >>> 31;
   $12 = $3 << 1 | HEAP32[$10 + 132 >> 2] >>> 31;
   $3 = $12 + $7 | 0;
   $9 = ($8 | $9) + $4 | 0;
   $9 = $3 >>> 0 < $12 >>> 0 ? $9 + 1 | 0 : $9;
   $4 = $9;
   $8 = $9 - 1 | 0;
   $14 = $3;
   $12 = $3 - 13927 | 0;
   $8 = $12 >>> 0 < 4294953369 ? $8 + 1 | 0 : $8;
   $18 = $8;
   $24 = $8;
   $3 = 0;
   $8 = $15 | 65536;
   $35 = $8;
   $36 = $13;
   $9 = $13;
   $8 = $8 << 1 | $9 >>> 31;
   $38 = $9 << 1;
   $39 = $8;
   $27 = $8;
   $3 = __wasm_i64_mul($18, $3, $8, 0);
   $8 = i64toi32_i32$HIGH_BITS;
   $23 = $3;
   $21 = $8;
   $31 = $1 << 1;
   $9 = $2 << 1 | $1 >>> 31;
   $17 = $9;
   $8 = 0;
   $28 = $8;
   $16 = $8;
   $3 = HEAP32[$10 + 120 >> 2];
   $8 = HEAP32[$10 + 124 >> 2] << 1 | $3 >>> 31;
   $3 = $3 << 1 | $20 >>> 31;
   $20 = $29 >>> 31 | 0;
   $3 = $3 + $20 | 0;
   $9 = $8;
   $9 = $3 >>> 0 < $20 >>> 0 ? $9 + 1 | 0 : $9;
   $7 = ($4 | 0) == ($11 | 0) & $7 >>> 0 > $14 >>> 0 | $4 >>> 0 < $11 >>> 0;
   $8 = $7;
   $7 = $3 + $7 | 0;
   $9 = $8 >>> 0 > $7 >>> 0 ? $9 + 1 | 0 : $9;
   $3 = ($4 | 0) == ($18 | 0) & $12 >>> 0 < $14 >>> 0 | $4 >>> 0 > $18 >>> 0;
   $4 = $3;
   $3 = $3 + $7 | 0;
   $9 = ($4 >>> 0 > $3 >>> 0 ? $9 + 1 | 0 : $9) - 1 | 0;
   $4 = $3 - 1 | 0;
   $30 = ($4 | 0) != -1 ? $9 + 1 | 0 : $9;
   $18 = 0;
   $7 = __wasm_i64_mul($17, $16, $30, $18);
   $3 = $7 + $23 | 0;
   $9 = i64toi32_i32$HIGH_BITS + $21 | 0;
   $8 = $3;
   $9 = $3 >>> 0 < $7 >>> 0 ? $9 + 1 | 0 : $9;
   $14 = ($21 | 0) == ($9 | 0) & $3 >>> 0 < $23 >>> 0 | $9 >>> 0 < $21 >>> 0;
   $7 = $9;
   $9 = 0;
   $20 = $4;
   $37 = $2 >>> 31 | 0;
   $23 = $37 | $13 << 1;
   $21 = 0;
   $9 = __wasm_i64_mul($4, $9, $23, $21);
   $4 = $9 + $3 | 0;
   $3 = i64toi32_i32$HIGH_BITS + $7 | 0;
   $3 = $4 >>> 0 < $9 >>> 0 ? $3 + 1 | 0 : $3;
   $15 = $4;
   $9 = 0;
   $11 = $3;
   $3 = ($7 | 0) == ($3 | 0) & $4 >>> 0 < $8 >>> 0 | $3 >>> 0 < $7 >>> 0;
   $4 = $3;
   $3 = $3 + $14 | 0;
   $9 = $4 >>> 0 > $3 >>> 0 ? 1 : $9;
   $4 = __wasm_i64_mul($30, $18, $27, $16);
   $3 = $4 + $3 | 0;
   $8 = i64toi32_i32$HIGH_BITS + $9 | 0;
   $8 = $3 >>> 0 < $4 >>> 0 ? $8 + 1 | 0 : $8;
   $14 = $3;
   $3 = __wasm_i64_mul($20, $21, $27, $16);
   $13 = i64toi32_i32$HIGH_BITS;
   $9 = $3;
   $4 = __wasm_i64_mul($23, $21, $30, $18);
   $7 = $9 + $4 | 0;
   $3 = i64toi32_i32$HIGH_BITS + $13 | 0;
   $3 = $4 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
   $4 = $3;
   $3 = ($13 | 0) == ($3 | 0) & $7 >>> 0 < $9 >>> 0 | $3 >>> 0 < $13 >>> 0;
   $13 = $14 + $4 | 0;
   $9 = $3 + $8 | 0;
   $8 = $13;
   $3 = $8 >>> 0 < $4 >>> 0 ? $9 + 1 | 0 : $9;
   $4 = 0;
   $13 = $4 + $15 | 0;
   $9 = $7 + $11 | 0;
   $9 = $4 >>> 0 > $13 >>> 0 ? $9 + 1 | 0 : $9;
   $4 = $9;
   $7 = ($11 | 0) == ($9 | 0) & $13 >>> 0 < $15 >>> 0 | $9 >>> 0 < $11 >>> 0;
   $9 = $7;
   $7 = $7 + $8 | 0;
   $3 = $9 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
   $14 = $7;
   $29 = $12;
   $7 = __wasm_i64_mul($12, 0, $23, $21);
   $15 = i64toi32_i32$HIGH_BITS;
   $9 = $7;
   $11 = __wasm_i64_mul($24, $16, $17, $16);
   $7 = $9 + $11 | 0;
   $8 = i64toi32_i32$HIGH_BITS + $15 | 0;
   $8 = $7 >>> 0 < $11 >>> 0 ? $8 + 1 | 0 : $8;
   $11 = $7;
   $12 = ($8 | 0) == ($15 | 0) & $7 >>> 0 < $9 >>> 0 | $8 >>> 0 < $15 >>> 0;
   $32 = $31 & -2;
   $7 = __wasm_i64_mul($20, $21, $32, 0);
   $15 = $11 + $7 | 0;
   $9 = i64toi32_i32$HIGH_BITS + $8 | 0;
   $9 = $7 >>> 0 > $15 >>> 0 ? $9 + 1 | 0 : $9;
   $7 = $9;
   $8 = ($8 | 0) == ($9 | 0) & $11 >>> 0 > $15 >>> 0 | $8 >>> 0 > $9 >>> 0;
   $9 = 0;
   $11 = $8;
   $8 = $8 + $12 | 0;
   $9 = ($11 >>> 0 > $8 >>> 0 ? 1 : $9) + $4 | 0;
   $12 = $8 + $13 | 0;
   $9 = $12 >>> 0 < $8 >>> 0 ? $9 + 1 | 0 : $9;
   $8 = $9;
   $4 = ($4 | 0) == ($9 | 0) & $12 >>> 0 < $13 >>> 0 | $4 >>> 0 > $9 >>> 0;
   $9 = $3;
   $3 = $4 + $14 | 0;
   $9 = $3 >>> 0 < $4 >>> 0 ? $9 + 1 | 0 : $9;
   $40 = $3;
   $14 = $9;
   $3 = __wasm_i64_mul($29, $22, $27, $16);
   $33 = i64toi32_i32$HIGH_BITS;
   $27 = $3;
   $9 = __wasm_i64_mul($32, $22, $30, $18);
   $4 = $3 + $9 | 0;
   $3 = i64toi32_i32$HIGH_BITS + $33 | 0;
   $3 = $4 >>> 0 < $9 >>> 0 ? $3 + 1 | 0 : $3;
   $18 = $4;
   $11 = __wasm_i64_mul($24, $16, $23, $21);
   $4 = $4 + $11 | 0;
   $13 = $3;
   $9 = $3 + i64toi32_i32$HIGH_BITS | 0;
   $9 = $4 >>> 0 < $11 >>> 0 ? $9 + 1 | 0 : $9;
   $23 = $4;
   $3 = __wasm_i64_mul($20, $21, $17, $16);
   $4 = $4 + $3 | 0;
   $16 = $9;
   $9 = $9 + i64toi32_i32$HIGH_BITS | 0;
   $9 = $3 >>> 0 > $4 >>> 0 ? $9 + 1 | 0 : $9;
   $11 = $9;
   $20 = 0;
   $3 = ($13 | 0) == ($16 | 0) & $18 >>> 0 > $23 >>> 0 | $13 >>> 0 > $16 >>> 0;
   $13 = $3 + (($13 | 0) == ($33 | 0) & $18 >>> 0 < $27 >>> 0 | $13 >>> 0 < $33 >>> 0) | 0;
   $3 = ($11 | 0) == ($16 | 0) & $4 >>> 0 < $23 >>> 0 | $11 >>> 0 < $16 >>> 0;
   $3 = $3 + $13 | 0;
   $16 = $11 + $12 | 0;
   $9 = ($3 | $20) + $8 | 0;
   $9 = $11 >>> 0 > $16 >>> 0 ? $9 + 1 | 0 : $9;
   $13 = $9;
   $3 = ($8 | 0) == ($9 | 0) & $12 >>> 0 > $16 >>> 0 | $8 >>> 0 > $9 >>> 0;
   $9 = $14;
   $8 = $3;
   $3 = $3 + $40 | 0;
   $9 = $8 >>> 0 > $3 >>> 0 ? $9 + 1 | 0 : $9;
   $20 = $3;
   $12 = $9;
   $3 = __wasm_i64_mul($24, $28, $32, $22);
   $18 = i64toi32_i32$HIGH_BITS;
   $14 = $3;
   $8 = __wasm_i64_mul($29, $22, $17, $28);
   $3 = $3 + $8 | 0;
   $9 = i64toi32_i32$HIGH_BITS + $18 | 0;
   $9 = $3 >>> 0 < $8 >>> 0 ? $9 + 1 | 0 : $9;
   $24 = 0;
   $8 = ($9 | 0) == ($18 | 0) & $3 >>> 0 < $14 >>> 0 | $9 >>> 0 < $18 >>> 0;
   $14 = $9;
   $3 = $9 + $15 | 0;
   $9 = ($8 | $24) + $7 | 0;
   $9 = $3 >>> 0 < $14 >>> 0 ? $9 + 1 | 0 : $9;
   $8 = $9;
   $15 = ($7 | 0) == ($9 | 0) & $3 >>> 0 < $15 >>> 0 | $7 >>> 0 > $9 >>> 0;
   $9 = $4;
   $11 = 0;
   $4 = $11 + $3 | 0;
   $9 = $8 + $9 | 0;
   $9 = $4 >>> 0 < $11 >>> 0 ? $9 + 1 | 0 : $9;
   $3 = ($8 | 0) == ($9 | 0) & $3 >>> 0 > $4 >>> 0 | $8 >>> 0 > $9 >>> 0;
   $9 = 0;
   $4 = $3;
   $3 = $3 + $15 | 0;
   $9 = ($4 >>> 0 > $3 >>> 0 ? 1 : $9) + $13 | 0;
   $4 = $3;
   $3 = $3 + $16 | 0;
   $9 = $4 >>> 0 > $3 >>> 0 ? $9 + 1 | 0 : $9;
   $4 = $9;
   $7 = ($13 | 0) == ($9 | 0) & $3 >>> 0 < $16 >>> 0 | $9 >>> 0 < $13 >>> 0;
   $9 = $12;
   $8 = $7;
   $7 = $7 + $20 | 0;
   $9 = $8 >>> 0 > $7 >>> 0 ? $9 + 1 | 0 : $9;
   $8 = $9;
   block12 : {
    if ($9 >>> 0 <= 131071) {
     $36 = $38 | $37;
     $35 = $21 | $39;
     __multi3($10 + 80 | 0, $3, $4, $7, $9, $5, $6, $26, $25);
     $11 = HEAP32[$10 + 84 >> 2];
     $14 = $11;
     $9 = $1 << 17;
     $15 = 0;
     $12 = HEAP32[$10 + 88 >> 2];
     $2 = $15 - $12 | 0;
     $1 = HEAP32[$10 + 80 >> 2];
     $13 = ($11 | $1) != 0;
     $11 = $2 - $13 | 0;
     $12 = ($9 - (HEAP32[$10 + 92 >> 2] + ($12 >>> 0 > $15 >>> 0) | 0) | 0) - ($2 >>> 0 < $13 >>> 0) | 0;
     $16 = $34 + 16382 | 0;
     $13 = 0 - $1 | 0;
     $15 = 0 - ((($1 | 0) != 0) + $14 | 0) | 0;
     break block12;
    }
    $3 = ($4 & 1) << 31 | $3 >>> 1;
    $4 = $7 << 31 | $4 >>> 1;
    $7 = ($8 & 1) << 31 | $7 >>> 1;
    $8 = $8 >>> 1 | 0;
    __multi3($10 + 96 | 0, $3, $4, $7, $8, $5, $6, $26, $25);
    $11 = HEAP32[$10 + 100 >> 2];
    $14 = $11;
    $17 = 0;
    $16 = HEAP32[$10 + 104 >> 2];
    $13 = $17 - $16 | 0;
    $15 = HEAP32[$10 + 96 >> 2];
    $12 = ($11 | $15) != 0;
    $11 = $13 - $12 | 0;
    $12 = (($1 << 16) - (HEAP32[$10 + 108 >> 2] + ($16 >>> 0 > $17 >>> 0) | 0) | 0) - ($12 >>> 0 > $13 >>> 0) | 0;
    $16 = $34 + 16383 | 0;
    $13 = 0 - $15 | 0;
    $31 = $1;
    $17 = $2;
    $15 = 0 - ((($15 | 0) != 0) + $14 | 0) | 0;
   }
   if (($16 | 0) >= 32767) {
    $19 = $19 | 2147418112;
    $1 = 0;
    $2 = 0;
    break block3;
   }
   block15 : {
    if (($16 | 0) > 0) {
     $1 = $11 << 1 | $15 >>> 31;
     $2 = $12 << 1 | $11 >>> 31;
     $11 = $7;
     $12 = $8 & 65535 | $16 << 16;
     $8 = $15 << 1 | $13 >>> 31;
     $14 = $13 << 1;
     break block15;
    }
    if (($16 | 0) <= -113) {
     $1 = 0;
     $2 = 0;
     break block3;
    }
    __lshrti3($10 - -64 | 0, $3, $4, $7, $8, 1 - $16 | 0);
    __ashlti3($10 + 48 | 0, $31, $17, $36, $35, $16 + 112 | 0);
    $3 = HEAP32[$10 + 64 >> 2];
    $4 = HEAP32[$10 + 68 >> 2];
    $11 = HEAP32[$10 + 72 >> 2];
    $12 = HEAP32[$10 + 76 >> 2];
    __multi3($10 + 32 | 0, $5, $6, $26, $25, $3, $4, $11, $12);
    $1 = HEAP32[$10 + 40 >> 2];
    $2 = HEAP32[$10 + 56 >> 2];
    $8 = HEAP32[$10 + 36 >> 2];
    $17 = $1 << 1 | $8 >>> 31;
    $13 = $2 - $17 | 0;
    $7 = HEAP32[$10 + 60 >> 2] - ((HEAP32[$10 + 44 >> 2] << 1 | $1 >>> 31) + ($2 >>> 0 < $17 >>> 0) | 0) | 0;
    $2 = HEAP32[$10 + 52 >> 2];
    $17 = $2;
    $1 = HEAP32[$10 + 32 >> 2];
    $8 = $8 << 1 | $1 >>> 31;
    $15 = $1 << 1;
    $1 = $15;
    $9 = HEAP32[$10 + 48 >> 2];
    $2 = ($2 | 0) == ($8 | 0) & $1 >>> 0 > $9 >>> 0 | $2 >>> 0 < $8 >>> 0;
    $1 = $13 - $2 | 0;
    $2 = $7 - ($2 >>> 0 > $13 >>> 0) | 0;
    $8 = $17 - (($9 >>> 0 < $15 >>> 0) + $8 | 0) | 0;
    $14 = $9 - $15 | 0;
   }
   $7 = $14;
   __multi3($10 + 16 | 0, $5, $6, $26, $25, 3, 0, 0, 0);
   __multi3($10, $5, $6, $26, $25, 5, 0, 0, 0);
   $9 = 0;
   $8 = $8 + $9 | 0;
   $13 = $3 & 1;
   $7 = $7 + $13 | 0;
   $8 = $14 >>> 0 > $7 >>> 0 ? $8 + 1 | 0 : $8;
   $6 = ($6 | 0) == ($8 | 0) & $5 >>> 0 < $7 >>> 0 | $6 >>> 0 < $8 >>> 0;
   $5 = ($8 | 0) == ($9 | 0) & $7 >>> 0 < $13 >>> 0 | $8 >>> 0 < $9 >>> 0;
   $9 = $2;
   $2 = $5;
   $5 = $1 + $5 | 0;
   $9 = $2 >>> 0 > $5 >>> 0 ? $9 + 1 | 0 : $9;
   $2 = $9;
   $1 = ($5 | 0) == ($26 | 0) & ($9 | 0) == ($25 | 0) ? $6 : ($25 | 0) == ($9 | 0) & $5 >>> 0 > $26 >>> 0 | $9 >>> 0 > $25 >>> 0;
   $9 = $4;
   $6 = $1 + $3 | 0;
   $9 = $6 >>> 0 < $1 >>> 0 ? $9 + 1 | 0 : $9;
   $1 = $9;
   $3 = ($4 | 0) == ($9 | 0) & $3 >>> 0 > $6 >>> 0 | $4 >>> 0 > $9 >>> 0;
   $9 = $12;
   $4 = $3;
   $3 = $3 + $11 | 0;
   $9 = $4 >>> 0 > $3 >>> 0 ? $9 + 1 | 0 : $9;
   $4 = $3;
   $11 = HEAP32[$10 + 20 >> 2];
   $14 = ($11 | 0) == ($8 | 0) & HEAPU32[$10 + 16 >> 2] < $7 >>> 0 | $8 >>> 0 > $11 >>> 0;
   $11 = HEAP32[$10 + 28 >> 2];
   $3 = HEAP32[$10 + 24 >> 2];
   $11 = $9 >>> 0 < 2147418112 & (($3 | 0) == ($5 | 0) & ($2 | 0) == ($11 | 0) ? $14 : ($11 | 0) == ($2 | 0) & $3 >>> 0 < $5 >>> 0 | $2 >>> 0 > $11 >>> 0);
   $3 = $1;
   $14 = $11;
   $11 = $6 + $11 | 0;
   $3 = $14 >>> 0 > $11 >>> 0 ? $3 + 1 | 0 : $3;
   $1 = ($1 | 0) == ($3 | 0) & $6 >>> 0 > $11 >>> 0 | $1 >>> 0 > $3 >>> 0;
   $6 = $1;
   $1 = $1 + $4 | 0;
   $9 = $6 >>> 0 > $1 >>> 0 ? $9 + 1 | 0 : $9;
   $6 = $1;
   $4 = $9;
   $14 = $9 >>> 0 < 2147418112;
   $9 = HEAP32[$10 + 4 >> 2];
   $8 = ($9 | 0) == ($8 | 0) & HEAPU32[$10 >> 2] < $7 >>> 0 | $8 >>> 0 > $9 >>> 0;
   $7 = HEAP32[$10 + 12 >> 2];
   $1 = HEAP32[$10 + 8 >> 2];
   $1 = $14 & (($1 | 0) == ($5 | 0) & ($2 | 0) == ($7 | 0) ? $8 : ($7 | 0) == ($2 | 0) & $1 >>> 0 < $5 >>> 0 | $2 >>> 0 > $7 >>> 0);
   $9 = $3;
   $2 = $1;
   $1 = $1 + $11 | 0;
   $9 = $2 >>> 0 > $1 >>> 0 ? $9 + 1 | 0 : $9;
   $2 = $9;
   $5 = ($3 | 0) == ($9 | 0) & $1 >>> 0 < $11 >>> 0 | $3 >>> 0 > $9 >>> 0;
   $3 = $4;
   $4 = $5 + $6 | 0;
   $3 = $4 >>> 0 < $5 >>> 0 ? $3 + 1 | 0 : $3;
   $22 = $4 | $22;
   $19 = $3 | $19;
  }
  HEAP32[$0 >> 2] = $1;
  HEAP32[$0 + 4 >> 2] = $2;
  HEAP32[$0 + 8 >> 2] = $22;
  HEAP32[$0 + 12 >> 2] = $19;
  __stack_pointer = $10 + 336 | 0;
 }
 
 function fmodl($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0;
  $9 = __stack_pointer - 128 | 0;
  __stack_pointer = $9;
  block2 : {
   block1 : {
    block : {
     if (!__letf2($5, $6, $7, $8, 0, 0, 0, 0)) {
      break block
     }
     $13 = $8 & 65535;
     $11 = $8 >>> 16 & 32767;
     __inlined_func$__fpclassifyl$67 : {
      block10 : {
       if (($11 | 0) != 32767) {
        $12 = 4;
        if ($11) {
         break block10
        }
        $12 = $5 | $7 | ($6 | $13) ? 3 : 2;
        break __inlined_func$__fpclassifyl$67;
       }
       $12 = !($5 | $7 | ($6 | $13));
      }
     }
     if (!$12) {
      break block
     }
     $18 = $4 >>> 16 | 0;
     $14 = $18 & 32767;
     if (($14 | 0) != 32767) {
      break block1
     }
    }
    __multf3($9 + 16 | 0, $1, $2, $3, $4, $5, $6, $7, $8);
    $4 = HEAP32[$9 + 16 >> 2];
    $3 = HEAP32[$9 + 20 >> 2];
    $2 = HEAP32[$9 + 24 >> 2];
    $1 = HEAP32[$9 + 28 >> 2];
    __divtf3($9, $4, $3, $2, $1, $4, $3, $2, $1);
    $3 = HEAP32[$9 + 8 >> 2];
    $4 = HEAP32[$9 + 12 >> 2];
    $7 = HEAP32[$9 >> 2];
    $8 = HEAP32[$9 + 4 >> 2];
    break block2;
   }
   $12 = $3;
   $13 = $4 & 2147483647;
   $11 = $7;
   $10 = $8 & 2147483647;
   if ((__letf2($1, $2, $12, $13, $5, $6, $7, $10) | 0) <= 0) {
    if (__letf2($1, $2, $12, $13, $5, $6, $7, $10)) {
     $7 = $1;
     $8 = $2;
     break block2;
    }
    __multf3($9 + 112 | 0, $1, $2, $3, $4, 0, 0, 0, 0);
    $3 = HEAP32[$9 + 120 >> 2];
    $4 = HEAP32[$9 + 124 >> 2];
    $7 = HEAP32[$9 + 112 >> 2];
    $8 = HEAP32[$9 + 116 >> 2];
    break block2;
   }
   $15 = $8 >>> 16 & 32767;
   block6 : {
    if ($14) {
     $8 = $2;
     $7 = $1;
     break block6;
    }
    __multf3($9 + 96 | 0, $1, $2, $12, $13, 0, 0, 0, 1081540608);
    $12 = HEAP32[$9 + 104 >> 2];
    $7 = HEAP32[$9 + 108 >> 2];
    $13 = $7;
    $14 = ($7 >>> 16 | 0) - 120 | 0;
    $8 = HEAP32[$9 + 100 >> 2];
    $7 = HEAP32[$9 + 96 >> 2];
   }
   if (!$15) {
    __multf3($9 + 80 | 0, $5, $6, $11, $10, 0, 0, 0, 1081540608);
    $11 = HEAP32[$9 + 88 >> 2];
    $5 = HEAP32[$9 + 92 >> 2];
    $10 = $5;
    $15 = ($10 >>> 16 | 0) - 120 | 0;
    $6 = HEAP32[$9 + 84 >> 2];
    $5 = HEAP32[$9 + 80 >> 2];
   }
   $16 = $11;
   $19 = $10 & 65535 | 65536;
   $13 = $13 & 65535 | 65536;
   if (($14 | 0) > ($15 | 0)) {
    while (1) {
     $10 = $12 - $16 | 0;
     $11 = ($6 | 0) == ($8 | 0) & $5 >>> 0 > $7 >>> 0 | $6 >>> 0 > $8 >>> 0;
     $17 = $10 - $11 | 0;
     $10 = ($13 - (($12 >>> 0 < $16 >>> 0) + $19 | 0) | 0) - ($10 >>> 0 < $11 >>> 0) | 0;
     block11 : {
      if (($10 | 0) >= 0) {
       $11 = $7;
       $7 = $7 - $5 | 0;
       $8 = $8 - (($5 >>> 0 > $11 >>> 0) + $6 | 0) | 0;
       if (!($7 | $17 | ($8 | $10))) {
        __multf3($9 + 32 | 0, $1, $2, $3, $4, 0, 0, 0, 0);
        $3 = HEAP32[$9 + 40 >> 2];
        $4 = HEAP32[$9 + 44 >> 2];
        $7 = HEAP32[$9 + 32 >> 2];
        $8 = HEAP32[$9 + 36 >> 2];
        break block2;
       }
       $13 = $10 << 1 | $17 >>> 31;
       $12 = $17 << 1 | $8 >>> 31;
       break block11;
      }
      $13 = $13 << 1 | $12 >>> 31;
      $12 = $12 << 1 | $8 >>> 31;
     }
     $8 = $8 << 1 | $7 >>> 31;
     $7 = $7 << 1;
     $14 = $14 - 1 | 0;
     if (($15 | 0) < ($14 | 0)) {
      continue
     }
     break;
    };
    $14 = $15;
   }
   $15 = $12 - $16 | 0;
   $10 = ($6 | 0) == ($8 | 0) & $5 >>> 0 > $7 >>> 0 | $6 >>> 0 > $8 >>> 0;
   $11 = $15 - $10 | 0;
   block13 : {
    $10 = ($13 - (($12 >>> 0 < $16 >>> 0) + $19 | 0) | 0) - ($10 >>> 0 > $15 >>> 0) | 0;
    if (!(($10 | 0) > 0 | ($10 | 0) >= 0)) {
     $11 = $12;
     $10 = $13;
     break block13;
    }
    $13 = $7;
    $7 = $7 - $5 | 0;
    $8 = $8 - (($5 >>> 0 > $13 >>> 0) + $6 | 0) | 0;
    if ($7 | $11 | ($8 | $10)) {
     break block13
    }
    __multf3($9 + 48 | 0, $1, $2, $3, $4, 0, 0, 0, 0);
    $3 = HEAP32[$9 + 56 >> 2];
    $4 = HEAP32[$9 + 60 >> 2];
    $7 = HEAP32[$9 + 48 >> 2];
    $8 = HEAP32[$9 + 52 >> 2];
    break block2;
   }
   if ($10 >>> 0 <= 65535) {
    while (1) {
     $1 = $8 >>> 31 | 0;
     $14 = $14 - 1 | 0;
     $8 = $8 << 1 | $7 >>> 31;
     $7 = $7 << 1;
     $10 = $10 << 1 | $11 >>> 31;
     $11 = $1 | $11 << 1;
     if ($10 >>> 0 < 65536) {
      continue
     }
     break;
    }
   }
   $1 = $18 & 32768;
   if (($14 | 0) <= 0) {
    __multf3($9 - -64 | 0, $7, $8, $11, $10 & 65535 | ($1 | $14 + 120) << 16, 0, 0, 0, 1065811968);
    $3 = HEAP32[$9 + 72 >> 2];
    $4 = HEAP32[$9 + 76 >> 2];
    $7 = HEAP32[$9 + 64 >> 2];
    $8 = HEAP32[$9 + 68 >> 2];
    break block2;
   }
   $3 = $11;
   $4 = $10 & 65535 | ($1 | $14) << 16;
  }
  HEAP32[$0 >> 2] = $7;
  HEAP32[$0 + 4 >> 2] = $8;
  HEAP32[$0 + 8 >> 2] = $3;
  HEAP32[$0 + 12 >> 2] = $4;
  __stack_pointer = $9 + 128 | 0;
 }
 
 function scanexp($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  block18 : {
   block7 : {
    block6 : {
     block3 : {
      block2 : {
       $2 = HEAP32[$0 + 4 >> 2];
       block1 : {
        if (($2 | 0) != HEAP32[$0 + 104 >> 2]) {
         HEAP32[$0 + 4 >> 2] = $2 + 1;
         $1 = HEAPU8[$2 | 0];
         break block1;
        }
        $1 = __shgetc($0);
       }
       switch ($1 - 43 | 0) {
       case 0:
       case 2:
        break block2;
       default:
        break block3;
       };
      }
      $5 = ($1 | 0) == 45;
      $2 = HEAP32[$0 + 4 >> 2];
      block5 : {
       if (($2 | 0) != HEAP32[$0 + 104 >> 2]) {
        HEAP32[$0 + 4 >> 2] = $2 + 1;
        $1 = HEAPU8[$2 | 0];
        break block5;
       }
       $1 = __shgetc($0);
      }
      $2 = $1 - 58 | 0;
      if ($2 >>> 0 > 4294967285) {
       break block6
      }
      if (HEAP32[$0 + 116 >> 2] < 0) {
       break block7
      }
      HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - 1;
      break block7;
     }
     $2 = $1 - 58 | 0;
     $5 = 0;
    }
    if ($2 >>> 0 < 4294967286) {
     break block7
    }
    $2 = 0;
    block8 : {
     if ($1 - 48 >>> 0 >= 10) {
      break block8
     }
     while (1) {
      $3 = (Math_imul($3, 10) + $1 | 0) - 48 | 0;
      $6 = ($3 | 0) < 214748364;
      $2 = HEAP32[$0 + 4 >> 2];
      block10 : {
       if (($2 | 0) != HEAP32[$0 + 104 >> 2]) {
        HEAP32[$0 + 4 >> 2] = $2 + 1;
        $1 = HEAPU8[$2 | 0];
        break block10;
       }
       $1 = __shgetc($0);
      }
      $4 = $1 - 48 | 0;
      if ($6 & $4 >>> 0 <= 9) {
       continue
      }
      break;
     };
     $2 = $3;
     $3 = $2 >> 31;
     if ($4 >>> 0 >= 10) {
      break block8
     }
     while (1) {
      $3 = __wasm_i64_mul($2, $3, 10, 0);
      $2 = $1 + $3 | 0;
      $1 = i64toi32_i32$HIGH_BITS;
      $3 = ($2 >>> 0 < $3 >>> 0 ? $1 + 1 | 0 : $1) - 1 | 0;
      $2 = $2 - 48 | 0;
      $3 = $2 >>> 0 < 4294967248 ? $3 + 1 | 0 : $3;
      $1 = HEAP32[$0 + 4 >> 2];
      block13 : {
       if (($1 | 0) != HEAP32[$0 + 104 >> 2]) {
        HEAP32[$0 + 4 >> 2] = $1 + 1;
        $1 = HEAPU8[$1 | 0];
        break block13;
       }
       $1 = __shgetc($0);
      }
      $4 = $1 - 48 | 0;
      if ($4 >>> 0 <= 9) {
       if ($2 >>> 0 < 2061584302 & ($3 | 0) <= 21474836 | ($3 | 0) < 21474836) {
        continue
       }
      }
      break;
     };
     if ($4 >>> 0 >= 10) {
      break block8
     }
     while (1) {
      $1 = HEAP32[$0 + 4 >> 2];
      block16 : {
       if (($1 | 0) != HEAP32[$0 + 104 >> 2]) {
        HEAP32[$0 + 4 >> 2] = $1 + 1;
        $1 = HEAPU8[$1 | 0];
        break block16;
       }
       $1 = __shgetc($0);
      }
      if ($1 - 48 >>> 0 < 10) {
       continue
      }
      break;
     };
    }
    if (HEAP32[$0 + 116 >> 2] >= 0) {
     HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - 1
    }
    $0 = $2;
    $2 = $5 ? 0 - $0 | 0 : $0;
    $3 = $5 ? 0 - ($3 + (($0 | 0) != 0) | 0) | 0 : $3;
    break block18;
   }
   $2 = 0;
   $3 = -2147483648;
   if (HEAP32[$0 + 116 >> 2] < 0) {
    break block18
   }
   HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - 1;
   i64toi32_i32$HIGH_BITS = -2147483648;
   return 0;
  }
  i64toi32_i32$HIGH_BITS = $3;
  return $2;
 }
 
 function strtod($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0.0;
  $26 = __stack_pointer - 16 | 0;
  __stack_pointer = $26;
  $17 = __stack_pointer - 160 | 0;
  __stack_pointer = $17;
  HEAP32[$17 + 60 >> 2] = $0;
  HEAP32[$17 + 20 >> 2] = $0;
  HEAP32[$17 + 24 >> 2] = -1;
  $0 = $17 + 16 | 0;
  __shlim($0);
  $19 = __stack_pointer - 48 | 0;
  __stack_pointer = $19;
  $23 = HEAP32[3048];
  $6 = HEAP32[3045];
  while (1) {
   $2 = HEAP32[$0 + 4 >> 2];
   block2 : {
    if (($2 | 0) != HEAP32[$0 + 104 >> 2]) {
     HEAP32[$0 + 4 >> 2] = $2 + 1;
     $8 = HEAPU8[$2 | 0];
     break block2;
    }
    $8 = __shgetc($0);
   }
   $2 = $8;
   if (($2 | 0) == 32 | $2 - 9 >>> 0 < 5) {
    continue
   }
   break;
  };
  $2 = 1;
  block4 : {
   block3 : {
    switch ($8 - 43 | 0) {
    case 0:
    case 2:
     break block3;
    default:
     break block4;
    };
   }
   $2 = ($8 | 0) == 45 ? -1 : 1;
   $12 = HEAP32[$0 + 4 >> 2];
   if (($12 | 0) != HEAP32[$0 + 104 >> 2]) {
    HEAP32[$0 + 4 >> 2] = $12 + 1;
    $8 = HEAPU8[$12 | 0];
    break block4;
   }
   $8 = __shgetc($0);
  }
  block14 : {
   block11 : {
    block7 : {
     if (($8 & -33) == 73) {
      while (1) {
       if (($3 | 0) == 7) {
        break block7
       }
       $12 = $3 + 5377 | 0;
       $3 = $3 + 1 | 0;
       $11 = HEAP32[$0 + 4 >> 2];
       block9 : {
        if (($11 | 0) != HEAP32[$0 + 104 >> 2]) {
         HEAP32[$0 + 4 >> 2] = $11 + 1;
         $8 = HEAPU8[$11 | 0];
         break block9;
        }
        $8 = __shgetc($0);
       }
       if (($8 | 32) == HEAP8[$12 | 0]) {
        continue
       }
       break;
      }
     }
     if (($3 | 0) != 3) {
      $12 = ($3 | 0) == 8;
      if ($12) {
       break block7
      }
      if ($3 >>> 0 < 4) {
       break block11
      }
      if ($12) {
       break block7
      }
     }
     $6 = HEAP32[$0 + 116 >> 2];
     if (($6 | 0) >= 0) {
      HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - 1
     }
     if ($3 >>> 0 < 4) {
      break block7
     }
     $6 = ($6 | 0) < 0;
     while (1) {
      if (!$6) {
       HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - 1
      }
      $3 = $3 - 1 | 0;
      if ($3 >>> 0 > 3) {
       continue
      }
      break;
     };
    }
    $10 = __stack_pointer - 16 | 0;
    __stack_pointer = $10;
    $9 = (wasm2js_scratch_store_f32(Math_fround(Math_fround($2 | 0) * Math_fround(Infinity))), wasm2js_scratch_load_i32(2));
    $3 = $9 & 8388607;
    $6 = $9 >>> 23 | 0;
    $0 = $6 & 255;
    block20 : {
     if ($0) {
      if (($0 | 0) != 255) {
       $2 = $3 << 25;
       $0 = $3 >>> 7 | 0;
       $3 = ($6 & 255) + 16256 | 0;
       $8 = 0;
       break block20;
      }
      $2 = $3 << 25;
      $0 = $3 >>> 7 | 0;
      $3 = 32767;
      $8 = 0;
      break block20;
     }
     if (!$3) {
      $3 = 0;
      $2 = 0;
      $0 = 0;
      $8 = 0;
      break block20;
     }
     $0 = Math_clz32($3);
     __ashlti3($10, $3, 0, 0, 0, $0 + 81 | 0);
     $3 = 16265 - $0 | 0;
     $2 = HEAP32[$10 + 8 >> 2];
     $0 = HEAP32[$10 + 12 >> 2] ^ 65536;
     $7 = HEAP32[$10 + 4 >> 2];
     $8 = HEAP32[$10 >> 2];
    }
    HEAP32[$19 >> 2] = $8;
    HEAP32[$19 + 4 >> 2] = $7;
    HEAP32[$19 + 8 >> 2] = $2;
    HEAP32[$19 + 12 >> 2] = $0 | ($9 & -2147483648 | $3 << 16);
    __stack_pointer = $10 + 16 | 0;
    $2 = HEAP32[$19 + 8 >> 2];
    $8 = HEAP32[$19 + 12 >> 2];
    $5 = HEAP32[$19 >> 2];
    $9 = HEAP32[$19 + 4 >> 2];
    break block14;
   }
   block : {
    block19 : {
     block201 : {
      block16 : {
       block15 : {
        if ($3) {
         break block15
        }
        $3 = 0;
        if (($8 & -33) != 78) {
         break block15
        }
        while (1) {
         if (($3 | 0) == 2) {
          break block16
         }
         $12 = $3 + 5827 | 0;
         $3 = $3 + 1 | 0;
         $11 = HEAP32[$0 + 4 >> 2];
         block18 : {
          if (($11 | 0) != HEAP32[$0 + 104 >> 2]) {
           HEAP32[$0 + 4 >> 2] = $11 + 1;
           $8 = HEAPU8[$11 | 0];
           break block18;
          }
          $8 = __shgetc($0);
         }
         if (($8 | 32) == HEAP8[$12 | 0]) {
          continue
         }
         break;
        };
       }
       switch ($3 | 0) {
       case 3:
        break block16;
       case 0:
        break block19;
       default:
        break block201;
       };
      }
      block24 : {
       $2 = HEAP32[$0 + 4 >> 2];
       block22 : {
        if (($2 | 0) != HEAP32[$0 + 104 >> 2]) {
         HEAP32[$0 + 4 >> 2] = $2 + 1;
         $2 = HEAPU8[$2 | 0];
         break block22;
        }
        $2 = __shgetc($0);
       }
       if (($2 | 0) == 40) {
        $3 = 1;
        break block24;
       }
       $2 = 0;
       $8 = 2147450880;
       if (HEAP32[$0 + 116 >> 2] < 0) {
        break block14
       }
       HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - 1;
       break block14;
      }
      while (1) {
       $2 = HEAP32[$0 + 4 >> 2];
       block26 : {
        if (($2 | 0) != HEAP32[$0 + 104 >> 2]) {
         HEAP32[$0 + 4 >> 2] = $2 + 1;
         $6 = HEAPU8[$2 | 0];
         break block26;
        }
        $6 = __shgetc($0);
       }
       if (!(!($6 - 48 >>> 0 < 10 | $6 - 65 >>> 0 < 26 | ($6 | 0) == 95) & $6 - 97 >>> 0 >= 26)) {
        $3 = $3 + 1 | 0;
        continue;
       }
       break;
      };
      $2 = 0;
      $8 = 2147450880;
      if (($6 | 0) == 41) {
       break block14
      }
      $6 = HEAP32[$0 + 116 >> 2];
      if (($6 | 0) >= 0) {
       HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - 1
      }
      if (!$3) {
       break block14
      }
      while (1) {
       if (($6 | 0) >= 0) {
        HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - 1
       }
       $3 = $3 - 1 | 0;
       if ($3) {
        continue
       }
       break;
      };
      break block14;
     }
     if (HEAP32[$0 + 116 >> 2] >= 0) {
      HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - 1
     }
     HEAP32[4484] = 28;
     __shlim($0);
     break block;
    }
    block36 : {
     if (($8 | 0) != 48) {
      break block36
     }
     $3 = HEAP32[$0 + 4 >> 2];
     block38 : {
      if (($3 | 0) != HEAP32[$0 + 104 >> 2]) {
       HEAP32[$0 + 4 >> 2] = $3 + 1;
       $3 = HEAPU8[$3 | 0];
       break block38;
      }
      $3 = __shgetc($0);
     }
     if (($3 & -33) == 88) {
      $22 = $19 + 16 | 0;
      $12 = $2;
      $2 = 0;
      $3 = 0;
      $8 = 0;
      $4 = __stack_pointer - 432 | 0;
      __stack_pointer = $4;
      $11 = $0;
      $10 = HEAP32[$0 + 4 >> 2];
      block1 : {
       if (($10 | 0) != HEAP32[$0 + 104 >> 2]) {
        HEAP32[$0 + 4 >> 2] = $10 + 1;
        $5 = HEAPU8[$10 | 0];
        break block1;
       }
       $5 = __shgetc($11);
      }
      block32 : {
       block5 : {
        while (1) {
         if (($5 | 0) != 48) {
          block47 : {
           if (($5 | 0) != 46) {
            break block32
           }
           $0 = HEAP32[$11 + 4 >> 2];
           if (($0 | 0) == HEAP32[$11 + 104 >> 2]) {
            break block47
           }
           HEAP32[$11 + 4 >> 2] = $0 + 1;
           $5 = HEAPU8[$0 | 0];
           break block5;
          }
         } else {
          $0 = HEAP32[$11 + 4 >> 2];
          if (($0 | 0) != HEAP32[$11 + 104 >> 2]) {
           $28 = 1;
           HEAP32[$11 + 4 >> 2] = $0 + 1;
           $5 = HEAPU8[$0 | 0];
          } else {
           $28 = 1;
           $5 = __shgetc($11);
          }
          continue;
         }
         break;
        };
        $5 = __shgetc($11);
       }
       if (($5 | 0) != 48) {
        $24 = 1;
        break block32;
       }
       while (1) {
        $0 = $8 - 1 | 0;
        $9 = $9 - 1 | 0;
        $8 = ($9 | 0) != -1 ? $0 + 1 | 0 : $0;
        $0 = HEAP32[$11 + 4 >> 2];
        block99 : {
         if (($0 | 0) != HEAP32[$11 + 104 >> 2]) {
          HEAP32[$11 + 4 >> 2] = $0 + 1;
          $5 = HEAPU8[$0 | 0];
          break block99;
         }
         $5 = __shgetc($11);
        }
        if (($5 | 0) == 48) {
         continue
        }
        break;
       };
       $24 = 1;
       $28 = 1;
      }
      $7 = 1073676288;
      $0 = 0;
      while (1) {
       block12 : {
        $10 = $5;
        block13 : {
         block10 : {
          $13 = $5 - 48 | 0;
          if ($13 >>> 0 < 10) {
           break block10
          }
          $14 = ($5 | 0) != 46;
          $10 = $5 | 32;
          if ($14 & $10 - 97 >>> 0 > 5) {
           break block12
          }
          if ($14) {
           break block10
          }
          if ($24) {
           break block12
          }
          $24 = 1;
          $9 = $2;
          $8 = $0;
          break block13;
         }
         $10 = ($5 | 0) > 57 ? $10 - 87 | 0 : $13;
         block1511 : {
          if (!($2 >>> 0 > 7 & ($0 | 0) >= 0 | ($0 | 0) > 0)) {
           $16 = $10 + ($16 << 4) | 0;
           break block1511;
          }
          if (!(!$0 & $2 >>> 0 > 28 | ($0 | 0) != 0)) {
           __floatsitf($4 + 48 | 0, $10);
           __multf3($4 + 32 | 0, $1, $25, $3, $7, 0, 0, 0, 1073414144);
           $1 = HEAP32[$4 + 32 >> 2];
           $25 = HEAP32[$4 + 36 >> 2];
           $3 = HEAP32[$4 + 40 >> 2];
           $7 = HEAP32[$4 + 44 >> 2];
           __multf3($4 + 16 | 0, HEAP32[$4 + 48 >> 2], HEAP32[$4 + 52 >> 2], HEAP32[$4 + 56 >> 2], HEAP32[$4 + 60 >> 2], $1, $25, $3, $7);
           __addtf3($4, HEAP32[$4 + 16 >> 2], HEAP32[$4 + 20 >> 2], HEAP32[$4 + 24 >> 2], HEAP32[$4 + 28 >> 2], $20, $21, $27, $15);
           $27 = HEAP32[$4 + 8 >> 2];
           $15 = HEAP32[$4 + 12 >> 2];
           $20 = HEAP32[$4 >> 2];
           $21 = HEAP32[$4 + 4 >> 2];
           break block1511;
          }
          if ($18 | !$10) {
           break block1511
          }
          __multf3($4 + 80 | 0, $1, $25, $3, $7, 0, 0, 0, 1073610752);
          __addtf3($4 - -64 | 0, HEAP32[$4 + 80 >> 2], HEAP32[$4 + 84 >> 2], HEAP32[$4 + 88 >> 2], HEAP32[$4 + 92 >> 2], $20, $21, $27, $15);
          $18 = 1;
          $27 = HEAP32[$4 + 72 >> 2];
          $15 = HEAP32[$4 + 76 >> 2];
          $20 = HEAP32[$4 + 64 >> 2];
          $21 = HEAP32[$4 + 68 >> 2];
         }
         $2 = $2 + 1 | 0;
         $0 = $2 ? $0 : $0 + 1 | 0;
         $28 = 1;
        }
        $10 = HEAP32[$11 + 4 >> 2];
        if (($10 | 0) != HEAP32[$11 + 104 >> 2]) {
         HEAP32[$11 + 4 >> 2] = $10 + 1;
         $5 = HEAPU8[$10 | 0];
        } else {
         $5 = __shgetc($11)
        }
        continue;
       }
       break;
      };
      block2212 : {
       if (!$28) {
        if (HEAP32[$11 + 116 >> 2] >= 0) {
         block21 : {
          $0 = HEAP32[$11 + 4 >> 2];
          HEAP32[$11 + 4 >> 2] = $0 - 1;
          HEAP32[$11 + 4 >> 2] = $0 - 2;
          if (!$24) {
           break block21
          }
          HEAP32[$11 + 4 >> 2] = $0 - 3;
         }
        }
        wasm2js_scratch_store_f64(0.0);
        $2 = wasm2js_scratch_load_i32(1) | 0;
        $8 = wasm2js_scratch_load_i32(0) | 0;
        wasm2js_scratch_store_f64(+($12 | 0));
        $0 = wasm2js_scratch_load_i32(1) | 0;
        wasm2js_scratch_load_i32(0) | 0;
        wasm2js_scratch_store_i32(0, $8 | 0);
        wasm2js_scratch_store_i32(1, $2 & 2147483647 | $0 & -2147483648);
        __extenddftf2($4 + 96 | 0, +wasm2js_scratch_load_f64());
        $0 = HEAP32[$4 + 108 >> 2];
        $20 = HEAP32[$4 + 96 >> 2];
        $21 = HEAP32[$4 + 100 >> 2];
        $2 = HEAP32[$4 + 104 >> 2];
        break block2212;
       }
       if (!($2 >>> 0 > 7 & ($0 | 0) >= 0 | ($0 | 0) > 0)) {
        $3 = $2;
        $7 = $0;
        while (1) {
         $16 = $16 << 4;
         $3 = $3 + 1 | 0;
         $7 = $3 ? $7 : $7 + 1 | 0;
         if ($7 | ($3 | 0) != 8) {
          continue
         }
         break;
        };
       }
       block25 : {
        block28 : {
         block27 : {
          if (($5 & -33) == 80) {
           $3 = scanexp($11);
           $7 = i64toi32_i32$HIGH_BITS;
           if ($3 | ($7 | 0) != -2147483648) {
            break block25
           }
           if (HEAP32[$11 + 116 >> 2] >= 0) {
            break block27
           }
           break block28;
          }
          $3 = 0;
          $7 = 0;
          if (HEAP32[$11 + 116 >> 2] < 0) {
           break block25
          }
         }
         HEAP32[$11 + 4 >> 2] = HEAP32[$11 + 4 >> 2] - 1;
        }
        $3 = 0;
        $7 = 0;
       }
       if (!$16) {
        wasm2js_scratch_store_f64(0.0);
        $2 = wasm2js_scratch_load_i32(1) | 0;
        $8 = wasm2js_scratch_load_i32(0) | 0;
        wasm2js_scratch_store_f64(+($12 | 0));
        $0 = wasm2js_scratch_load_i32(1) | 0;
        wasm2js_scratch_load_i32(0) | 0;
        wasm2js_scratch_store_i32(0, $8 | 0);
        wasm2js_scratch_store_i32(1, $2 & 2147483647 | $0 & -2147483648);
        __extenddftf2($4 + 112 | 0, +wasm2js_scratch_load_f64());
        $0 = HEAP32[$4 + 124 >> 2];
        $20 = HEAP32[$4 + 112 >> 2];
        $21 = HEAP32[$4 + 116 >> 2];
        $2 = HEAP32[$4 + 120 >> 2];
        break block2212;
       }
       $2 = $24 ? $9 : $2;
       $9 = $3 + ($2 << 2) | 0;
       $0 = (($24 ? $8 : $0) << 2 | $2 >>> 30) + $7 | 0;
       $0 = ($3 >>> 0 > $9 >>> 0 ? $0 + 1 | 0 : $0) - 1 | 0;
       $2 = $9 - 32 | 0;
       $0 = $2 >>> 0 < 4294967264 ? $0 + 1 | 0 : $0;
       if (!(($0 | 0) <= 0 & 0 - $23 >>> 0 >= $2 >>> 0 | ($0 | 0) < 0)) {
        HEAP32[4484] = 68;
        __floatsitf($4 + 160 | 0, $12);
        __multf3($4 + 144 | 0, HEAP32[$4 + 160 >> 2], HEAP32[$4 + 164 >> 2], HEAP32[$4 + 168 >> 2], HEAP32[$4 + 172 >> 2], -1, -1, -1, 2147418111);
        __multf3($4 + 128 | 0, HEAP32[$4 + 144 >> 2], HEAP32[$4 + 148 >> 2], HEAP32[$4 + 152 >> 2], HEAP32[$4 + 156 >> 2], -1, -1, -1, 2147418111);
        $0 = HEAP32[$4 + 140 >> 2];
        $20 = HEAP32[$4 + 128 >> 2];
        $21 = HEAP32[$4 + 132 >> 2];
        $2 = HEAP32[$4 + 136 >> 2];
        break block2212;
       }
       $3 = $23 - 226 | 0;
       $8 = $3 >>> 0 > $2 >>> 0;
       $3 = $3 >> 31;
       if (!($8 & ($3 | 0) >= ($0 | 0) | ($0 | 0) < ($3 | 0))) {
        if (($16 | 0) >= 0) {
         while (1) {
          __addtf3($4 + 416 | 0, $20, $21, $27, $15, 0, 0, 0, -1073807360);
          $3 = __getf2($20, $21, $27, $15, 1073610752);
          $9 = ($3 | 0) >= 0;
          __addtf3($4 + 400 | 0, $20, $21, $27, $15, $9 ? HEAP32[$4 + 416 >> 2] : $20, $9 ? HEAP32[$4 + 420 >> 2] : $21, $9 ? HEAP32[$4 + 424 >> 2] : $27, $9 ? HEAP32[$4 + 428 >> 2] : $15);
          $3 = $16 << 1;
          $16 = $9 | $3;
          $0 = $0 - 1 | 0;
          $2 = $2 - 1 | 0;
          $0 = ($2 | 0) != -1 ? $0 + 1 | 0 : $0;
          $27 = HEAP32[$4 + 408 >> 2];
          $15 = HEAP32[$4 + 412 >> 2];
          $20 = HEAP32[$4 + 400 >> 2];
          $21 = HEAP32[$4 + 404 >> 2];
          if (($3 | 0) >= 0) {
           continue
          }
          break;
         }
        }
        $5 = $0 + 1 | 0;
        $8 = $0;
        $0 = 32 - $23 | 0;
        $3 = $0 + $2 | 0;
        $0 = $0 >>> 0 > $3 >>> 0 ? $5 : $8;
        $10 = $3 >>> 0 < $6 >>> 0 & ($0 | 0) <= 0 | ($0 | 0) < 0 ? (($3 | 0) > 0 ? $3 : 0) : $6;
        block34 : {
         if ($10 >>> 0 >= 113) {
          __floatsitf($4 + 384 | 0, $12);
          $9 = 0;
          $8 = 0;
          $3 = HEAP32[$4 + 392 >> 2];
          $7 = HEAP32[$4 + 396 >> 2];
          $1 = HEAP32[$4 + 384 >> 2];
          $25 = HEAP32[$4 + 388 >> 2];
          $6 = 0;
          $0 = 0;
          break block34;
         }
         __extenddftf2($4 + 352 | 0, scalbn(1.0, 144 - $10 | 0));
         __floatsitf($4 + 336 | 0, $12);
         $1 = HEAP32[$4 + 336 >> 2];
         $25 = HEAP32[$4 + 340 >> 2];
         $3 = HEAP32[$4 + 344 >> 2];
         $7 = HEAP32[$4 + 348 >> 2];
         copysignl($4 + 368 | 0, HEAP32[$4 + 352 >> 2], HEAP32[$4 + 356 >> 2], HEAP32[$4 + 360 >> 2], HEAP32[$4 + 364 >> 2], $7);
         $6 = HEAP32[$4 + 380 >> 2];
         $9 = HEAP32[$4 + 368 >> 2];
         $8 = HEAP32[$4 + 372 >> 2];
         $0 = HEAP32[$4 + 376 >> 2];
        }
        $10 = !($16 & 1) & ((__letf2($20, $21, $27, $15, 0, 0, 0, 0) | 0) != 0 & $10 >>> 0 < 32);
        __floatunsitf($4 + 320 | 0, $10 | $16);
        __multf3($4 + 304 | 0, $1, $25, $3, $7, HEAP32[$4 + 320 >> 2], HEAP32[$4 + 324 >> 2], HEAP32[$4 + 328 >> 2], HEAP32[$4 + 332 >> 2]);
        __addtf3($4 + 272 | 0, HEAP32[$4 + 304 >> 2], HEAP32[$4 + 308 >> 2], HEAP32[$4 + 312 >> 2], HEAP32[$4 + 316 >> 2], $9, $8, $0, $6);
        __multf3($4 + 288 | 0, $1, $25, $3, $7, $10 ? 0 : $20, $10 ? 0 : $21, $10 ? 0 : $27, $10 ? 0 : $15);
        __addtf3($4 + 256 | 0, HEAP32[$4 + 288 >> 2], HEAP32[$4 + 292 >> 2], HEAP32[$4 + 296 >> 2], HEAP32[$4 + 300 >> 2], HEAP32[$4 + 272 >> 2], HEAP32[$4 + 276 >> 2], HEAP32[$4 + 280 >> 2], HEAP32[$4 + 284 >> 2]);
        __subtf3($4 + 240 | 0, HEAP32[$4 + 256 >> 2], HEAP32[$4 + 260 >> 2], HEAP32[$4 + 264 >> 2], HEAP32[$4 + 268 >> 2], $9, $8, $0, $6);
        $9 = HEAP32[$4 + 240 >> 2];
        $3 = HEAP32[$4 + 244 >> 2];
        $6 = HEAP32[$4 + 248 >> 2];
        $0 = HEAP32[$4 + 252 >> 2];
        if (!__letf2($9, $3, $6, $0, 0, 0, 0, 0)) {
         HEAP32[4484] = 68
        }
        scalbnl($4 + 224 | 0, $9, $3, $6, $0, $2);
        $0 = HEAP32[$4 + 236 >> 2];
        $20 = HEAP32[$4 + 224 >> 2];
        $21 = HEAP32[$4 + 228 >> 2];
        $2 = HEAP32[$4 + 232 >> 2];
        break block2212;
       }
       HEAP32[4484] = 68;
       __floatsitf($4 + 208 | 0, $12);
       __multf3($4 + 192 | 0, HEAP32[$4 + 208 >> 2], HEAP32[$4 + 212 >> 2], HEAP32[$4 + 216 >> 2], HEAP32[$4 + 220 >> 2], 0, 0, 0, 65536);
       __multf3($4 + 176 | 0, HEAP32[$4 + 192 >> 2], HEAP32[$4 + 196 >> 2], HEAP32[$4 + 200 >> 2], HEAP32[$4 + 204 >> 2], 0, 0, 0, 65536);
       $0 = HEAP32[$4 + 188 >> 2];
       $20 = HEAP32[$4 + 176 >> 2];
       $21 = HEAP32[$4 + 180 >> 2];
       $2 = HEAP32[$4 + 184 >> 2];
      }
      HEAP32[$22 >> 2] = $20;
      HEAP32[$22 + 4 >> 2] = $21;
      HEAP32[$22 + 8 >> 2] = $2;
      HEAP32[$22 + 12 >> 2] = $0;
      __stack_pointer = $4 + 432 | 0;
      $2 = HEAP32[$19 + 24 >> 2];
      $8 = HEAP32[$19 + 28 >> 2];
      $5 = HEAP32[$19 + 16 >> 2];
      $9 = HEAP32[$19 + 20 >> 2];
      break block14;
     }
     if (HEAP32[$0 + 116 >> 2] < 0) {
      break block36
     }
     HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] - 1;
    }
    $25 = $19 + 32 | 0;
    $7 = $0;
    $11 = $2;
    $2 = 0;
    $3 = 0;
    $1 = __stack_pointer - 8976 | 0;
    __stack_pointer = $1;
    $18 = 0 - $23 | 0;
    $12 = $6;
    $28 = $18 - $6 | 0;
    block115 : {
     block316 : {
      while (1) {
       if (($8 | 0) != 48) {
        block218 : {
         if (($8 | 0) != 46) {
          break block115
         }
         $0 = HEAP32[$7 + 4 >> 2];
         if (($0 | 0) == HEAP32[$7 + 104 >> 2]) {
          break block218
         }
         HEAP32[$7 + 4 >> 2] = $0 + 1;
         $8 = HEAPU8[$0 | 0];
         break block316;
        }
       } else {
        $0 = HEAP32[$7 + 4 >> 2];
        if (($0 | 0) != HEAP32[$7 + 104 >> 2]) {
         HEAP32[$7 + 4 >> 2] = $0 + 1;
         $8 = HEAPU8[$0 | 0];
        } else {
         $8 = __shgetc($7)
        }
        $3 = 1;
        continue;
       }
       break;
      };
      $8 = __shgetc($7);
     }
     if (($8 | 0) == 48) {
      while (1) {
       $0 = $5 - 1 | 0;
       $2 = $2 - 1 | 0;
       $5 = ($2 | 0) != -1 ? $0 + 1 | 0 : $0;
       $0 = HEAP32[$7 + 4 >> 2];
       block720 : {
        if (($0 | 0) != HEAP32[$7 + 104 >> 2]) {
         HEAP32[$7 + 4 >> 2] = $0 + 1;
         $8 = HEAPU8[$0 | 0];
         break block720;
        }
        $8 = __shgetc($7);
       }
       if (($8 | 0) == 48) {
        continue
       }
       break;
      };
      $3 = 1;
     }
     $24 = 1;
    }
    HEAP32[$1 + 784 >> 2] = 0;
    block23 : {
     block2121 : {
      $0 = ($8 | 0) == 46;
      $6 = $8 - 48 | 0;
      block2222 : {
       block1323 : {
        if ($0 | $6 >>> 0 <= 9) {
         while (1) {
          block1225 : {
           if ($0 & 1) {
            if (!$24) {
             $2 = $13;
             $5 = $9;
             $24 = 1;
             break block1225;
            }
            $0 = !$3;
            break block1323;
           }
           $13 = $13 + 1 | 0;
           $9 = $13 ? $9 : $9 + 1 | 0;
           if (($10 | 0) <= 2044) {
            $15 = ($8 | 0) == 48 ? $15 : $13;
            $0 = ($1 + 784 | 0) + ($10 << 2) | 0;
            HEAP32[$0 >> 2] = $14 ? (Math_imul(HEAP32[$0 >> 2], 10) + $8 | 0) - 48 | 0 : $6;
            $3 = 1;
            $0 = $14 + 1 | 0;
            $6 = ($0 | 0) == 9;
            $14 = $6 ? 0 : $0;
            $10 = $6 + $10 | 0;
            break block1225;
           }
           if (($8 | 0) == 48) {
            break block1225
           }
           HEAP32[$1 + 8960 >> 2] = HEAP32[$1 + 8960 >> 2] | 1;
           $15 = 18396;
          }
          $0 = HEAP32[$7 + 4 >> 2];
          block17 : {
           if (($0 | 0) != HEAP32[$7 + 104 >> 2]) {
            HEAP32[$7 + 4 >> 2] = $0 + 1;
            $8 = HEAPU8[$0 | 0];
            break block17;
           }
           $8 = __shgetc($7);
          }
          $0 = ($8 | 0) == 46;
          $6 = $8 - 48 | 0;
          if ($0 | $6 >>> 0 < 10) {
           continue
          }
          break;
         }
        }
        $2 = $24 ? $2 : $13;
        $5 = $24 ? $5 : $9;
        if (!(!$3 | ($8 & -33) != 69)) {
         $8 = scanexp($7);
         $0 = i64toi32_i32$HIGH_BITS;
         $6 = $0;
         block1926 : {
          if ($8 | ($0 | 0) != -2147483648) {
           break block1926
          }
          $8 = 0;
          $6 = 0;
          if (HEAP32[$7 + 116 >> 2] < 0) {
           break block1926
          }
          HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] - 1;
         }
         $0 = $5 + $6 | 0;
         $5 = $2;
         $2 = $2 + $8 | 0;
         $5 = $5 >>> 0 > $2 >>> 0 ? $0 + 1 | 0 : $0;
         break block2121;
        }
        $0 = !$3;
        if (($8 | 0) < 0) {
         break block2222
        }
       }
       if (HEAP32[$7 + 116 >> 2] < 0) {
        break block2222
       }
       HEAP32[$7 + 4 >> 2] = HEAP32[$7 + 4 >> 2] - 1;
      }
      if (!$0) {
       break block2121
      }
      HEAP32[4484] = 28;
      $13 = 0;
      $9 = 0;
      __shlim($7);
      $5 = 0;
      $0 = 0;
      break block23;
     }
     $0 = HEAP32[$1 + 784 >> 2];
     if (!$0) {
      wasm2js_scratch_store_f64(0.0);
      $2 = wasm2js_scratch_load_i32(1) | 0;
      $8 = wasm2js_scratch_load_i32(0) | 0;
      wasm2js_scratch_store_f64(+($11 | 0));
      $0 = wasm2js_scratch_load_i32(1) | 0;
      wasm2js_scratch_load_i32(0) | 0;
      wasm2js_scratch_store_i32(0, $8 | 0);
      wasm2js_scratch_store_i32(1, $2 & 2147483647 | $0 & -2147483648);
      __extenddftf2($1, +wasm2js_scratch_load_f64());
      $5 = HEAP32[$1 + 12 >> 2];
      $13 = HEAP32[$1 >> 2];
      $9 = HEAP32[$1 + 4 >> 2];
      $0 = HEAP32[$1 + 8 >> 2];
      break block23;
     }
     if (!($13 >>> 0 > 9 & ($9 | 0) >= 0 | ($9 | 0) > 0 | (($2 | 0) != ($13 | 0) | ($5 | 0) != ($9 | 0)) | ($0 >>> $12 | 0 ? $12 >>> 0 <= 30 : 0))) {
      __floatsitf($1 + 48 | 0, $11);
      __floatunsitf($1 + 32 | 0, $0);
      __multf3($1 + 16 | 0, HEAP32[$1 + 48 >> 2], HEAP32[$1 + 52 >> 2], HEAP32[$1 + 56 >> 2], HEAP32[$1 + 60 >> 2], HEAP32[$1 + 32 >> 2], HEAP32[$1 + 36 >> 2], HEAP32[$1 + 40 >> 2], HEAP32[$1 + 44 >> 2]);
      $5 = HEAP32[$1 + 28 >> 2];
      $13 = HEAP32[$1 + 16 >> 2];
      $9 = HEAP32[$1 + 20 >> 2];
      $0 = HEAP32[$1 + 24 >> 2];
      break block23;
     }
     if (!(($5 | 0) <= 0 & $18 >>> 1 >>> 0 >= $2 >>> 0 | ($5 | 0) < 0)) {
      HEAP32[4484] = 68;
      __floatsitf($1 + 96 | 0, $11);
      __multf3($1 + 80 | 0, HEAP32[$1 + 96 >> 2], HEAP32[$1 + 100 >> 2], HEAP32[$1 + 104 >> 2], HEAP32[$1 + 108 >> 2], -1, -1, -1, 2147418111);
      __multf3($1 - -64 | 0, HEAP32[$1 + 80 >> 2], HEAP32[$1 + 84 >> 2], HEAP32[$1 + 88 >> 2], HEAP32[$1 + 92 >> 2], -1, -1, -1, 2147418111);
      $5 = HEAP32[$1 + 76 >> 2];
      $13 = HEAP32[$1 + 64 >> 2];
      $9 = HEAP32[$1 + 68 >> 2];
      $0 = HEAP32[$1 + 72 >> 2];
      break block23;
     }
     $6 = $23 - 226 | 0;
     $0 = $6 >> 31;
     if (!(($0 | 0) <= ($5 | 0) & $2 >>> 0 >= $6 >>> 0 | ($0 | 0) < ($5 | 0))) {
      HEAP32[4484] = 68;
      __floatsitf($1 + 144 | 0, $11);
      __multf3($1 + 128 | 0, HEAP32[$1 + 144 >> 2], HEAP32[$1 + 148 >> 2], HEAP32[$1 + 152 >> 2], HEAP32[$1 + 156 >> 2], 0, 0, 0, 65536);
      __multf3($1 + 112 | 0, HEAP32[$1 + 128 >> 2], HEAP32[$1 + 132 >> 2], HEAP32[$1 + 136 >> 2], HEAP32[$1 + 140 >> 2], 0, 0, 0, 65536);
      $5 = HEAP32[$1 + 124 >> 2];
      $13 = HEAP32[$1 + 112 >> 2];
      $9 = HEAP32[$1 + 116 >> 2];
      $0 = HEAP32[$1 + 120 >> 2];
      break block23;
     }
     if ($14) {
      if (($14 | 0) <= 8) {
       $0 = ($1 + 784 | 0) + ($10 << 2) | 0;
       $7 = HEAP32[$0 >> 2];
       while (1) {
        $7 = Math_imul($7, 10);
        $14 = $14 + 1 | 0;
        if (($14 | 0) != 9) {
         continue
        }
        break;
       };
       HEAP32[$0 >> 2] = $7;
      }
      $10 = $10 + 1 | 0;
     }
     $14 = $2;
     block31 : {
      if ($2 >>> 0 > 17 & ($5 | 0) >= 0 | ($5 | 0) > 0 | ($15 | 0) >= 9 | ($2 | 0) < ($15 | 0)) {
       break block31
      }
      if (!(($2 | 0) != 9 | ($5 | 0) != 0)) {
       __floatsitf($1 + 192 | 0, $11);
       __floatunsitf($1 + 176 | 0, HEAP32[$1 + 784 >> 2]);
       __multf3($1 + 160 | 0, HEAP32[$1 + 192 >> 2], HEAP32[$1 + 196 >> 2], HEAP32[$1 + 200 >> 2], HEAP32[$1 + 204 >> 2], HEAP32[$1 + 176 >> 2], HEAP32[$1 + 180 >> 2], HEAP32[$1 + 184 >> 2], HEAP32[$1 + 188 >> 2]);
       $5 = HEAP32[$1 + 172 >> 2];
       $13 = HEAP32[$1 + 160 >> 2];
       $9 = HEAP32[$1 + 164 >> 2];
       $0 = HEAP32[$1 + 168 >> 2];
       break block23;
      }
      if (!($2 >>> 0 > 8 & ($5 | 0) >= 0 | ($5 | 0) > 0)) {
       __floatsitf($1 + 272 | 0, $11);
       __floatunsitf($1 + 256 | 0, HEAP32[$1 + 784 >> 2]);
       __multf3($1 + 240 | 0, HEAP32[$1 + 272 >> 2], HEAP32[$1 + 276 >> 2], HEAP32[$1 + 280 >> 2], HEAP32[$1 + 284 >> 2], HEAP32[$1 + 256 >> 2], HEAP32[$1 + 260 >> 2], HEAP32[$1 + 264 >> 2], HEAP32[$1 + 268 >> 2]);
       __floatsitf($1 + 224 | 0, HEAP32[(0 - $14 << 2) + 12176 >> 2]);
       __divtf3($1 + 208 | 0, HEAP32[$1 + 240 >> 2], HEAP32[$1 + 244 >> 2], HEAP32[$1 + 248 >> 2], HEAP32[$1 + 252 >> 2], HEAP32[$1 + 224 >> 2], HEAP32[$1 + 228 >> 2], HEAP32[$1 + 232 >> 2], HEAP32[$1 + 236 >> 2]);
       $5 = HEAP32[$1 + 220 >> 2];
       $13 = HEAP32[$1 + 208 >> 2];
       $9 = HEAP32[$1 + 212 >> 2];
       $0 = HEAP32[$1 + 216 >> 2];
       break block23;
      }
      $2 = (Math_imul($14, -3) + $12 | 0) + 27 | 0;
      $0 = HEAP32[$1 + 784 >> 2];
      if ($0 >>> $2 | 0 ? ($2 | 0) <= 30 : 0) {
       break block31
      }
      __floatsitf($1 + 352 | 0, $11);
      __floatunsitf($1 + 336 | 0, $0);
      __multf3($1 + 320 | 0, HEAP32[$1 + 352 >> 2], HEAP32[$1 + 356 >> 2], HEAP32[$1 + 360 >> 2], HEAP32[$1 + 364 >> 2], HEAP32[$1 + 336 >> 2], HEAP32[$1 + 340 >> 2], HEAP32[$1 + 344 >> 2], HEAP32[$1 + 348 >> 2]);
      __floatsitf($1 + 304 | 0, HEAP32[($14 << 2) + 12104 >> 2]);
      __multf3($1 + 288 | 0, HEAP32[$1 + 320 >> 2], HEAP32[$1 + 324 >> 2], HEAP32[$1 + 328 >> 2], HEAP32[$1 + 332 >> 2], HEAP32[$1 + 304 >> 2], HEAP32[$1 + 308 >> 2], HEAP32[$1 + 312 >> 2], HEAP32[$1 + 316 >> 2]);
      $5 = HEAP32[$1 + 300 >> 2];
      $13 = HEAP32[$1 + 288 >> 2];
      $9 = HEAP32[$1 + 292 >> 2];
      $0 = HEAP32[$1 + 296 >> 2];
      break block23;
     }
     while (1) {
      $0 = $10;
      $10 = $0 - 1 | 0;
      if (!HEAP32[($1 + 784 | 0) + ($10 << 2) >> 2]) {
       continue
      }
      break;
     };
     $15 = 0;
     $2 = ($14 | 0) % 9 | 0;
     block3629 : {
      if (!$2) {
       $6 = 0;
       break block3629;
      }
      $22 = ($5 | 0) < 0 ? $2 + 9 | 0 : $2;
      block3830 : {
       if (!$0) {
        $6 = 0;
        $0 = 0;
        break block3830;
       }
       $18 = HEAP32[(0 - $22 << 2) + 12176 >> 2];
       $5 = 1e9 / ($18 | 0) | 0;
       $8 = 0;
       $7 = 0;
       $6 = 0;
       while (1) {
        $10 = $1 + 784 | 0;
        $2 = $10 + ($7 << 2) | 0;
        $9 = HEAP32[$2 >> 2];
        $3 = ($9 >>> 0) / ($18 >>> 0) | 0;
        $13 = $8 + $3 | 0;
        HEAP32[$2 >> 2] = $13;
        $2 = !$13 & ($6 | 0) == ($7 | 0);
        $6 = $2 ? $6 + 1 & 2047 : $6;
        $14 = $2 ? $14 - 9 | 0 : $14;
        $8 = Math_imul($5, $9 - Math_imul($3, $18) | 0);
        $7 = $7 + 1 | 0;
        if (($0 | 0) != ($7 | 0)) {
         continue
        }
        break;
       };
       if (!$8) {
        break block3830
       }
       HEAP32[($0 << 2) + $10 >> 2] = $8;
       $0 = $0 + 1 | 0;
      }
      $14 = ($14 - $22 | 0) + 9 | 0;
     }
     while (1) {
      $8 = ($1 + 784 | 0) + ($6 << 2) | 0;
      $13 = ($14 | 0) < 36;
      block40 : {
       while (1) {
        if (!$13 & (($14 | 0) != 36 | HEAPU32[$8 >> 2] >= 10384593)) {
         break block40
        }
        $10 = $0 + 2047 | 0;
        $3 = 0;
        while (1) {
         $9 = $0;
         $18 = $10 & 2047;
         $7 = ($1 + 784 | 0) + ($18 << 2) | 0;
         $2 = HEAP32[$7 >> 2];
         $0 = $2 >>> 3 | 0;
         $2 = $3 + ($2 << 29) | 0;
         $5 = $3 >>> 0 > $2 >>> 0 ? $0 + 1 | 0 : $0;
         block42 : {
          if (!(!$5 & $2 >>> 0 >= 1000000001 | ($5 | 0) != 0)) {
           $3 = 0;
           break block42;
          }
          $0 = $2;
          $3 = __wasm_i64_udiv($0, $5, 1e9);
          $10 = __wasm_i64_mul($3, i64toi32_i32$HIGH_BITS, 1e9, 0);
          $2 = $0 - $10 | 0;
          $5 = $5 - (i64toi32_i32$HIGH_BITS + ($0 >>> 0 < $10 >>> 0) | 0) | 0;
         }
         HEAP32[$7 >> 2] = $2;
         $0 = ($6 | 0) == ($18 | 0) ? $9 : $2 | $5 ? $9 : $18;
         $2 = $9 - 1 & 2047;
         $0 = ($2 | 0) != ($18 | 0) ? $9 : $0;
         $10 = $18 - 1 | 0;
         if (($6 | 0) != ($18 | 0)) {
          continue
         }
         break;
        };
        $15 = $15 - 29 | 0;
        $0 = $9;
        if (!$3) {
         continue
        }
        break;
       };
       $6 = $6 - 1 & 2047;
       if (($0 | 0) == ($6 | 0)) {
        $9 = $1 + 784 | 0;
        $0 = $9 + (($0 + 2046 & 2047) << 2) | 0;
        HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | HEAP32[($2 << 2) + $9 >> 2];
        $0 = $2;
       }
       $14 = $14 + 9 | 0;
       HEAP32[($1 + 784 | 0) + ($6 << 2) >> 2] = $3;
       continue;
      }
      break;
     };
     block49 : {
      label14 : while (1) {
       $2 = $0 + 1 & 2047;
       $18 = ($1 + 784 | 0) + (($0 - 1 & 2047) << 2) | 0;
       while (1) {
        $22 = ($14 | 0) > 45 ? 9 : 1;
        block48 : {
         while (1) {
          $3 = $6;
          $7 = 0;
          block46 : {
           while (1) {
            block45 : {
             $6 = $3 + $7 & 2047;
             if (($6 | 0) == ($0 | 0)) {
              break block45
             }
             $9 = HEAP32[($1 + 784 | 0) + ($6 << 2) >> 2];
             $6 = HEAP32[($7 << 2) + 12128 >> 2];
             if ($9 >>> 0 < $6 >>> 0) {
              break block45
             }
             if ($6 >>> 0 < $9 >>> 0) {
              break block46
             }
             $7 = $7 + 1 | 0;
             if (($7 | 0) != 4) {
              continue
             }
            }
            break;
           };
           if (($14 | 0) != 36) {
            break block46
           }
           $2 = 0;
           $5 = 0;
           $7 = 0;
           $13 = 0;
           $9 = 0;
           while (1) {
            $6 = $3 + $7 & 2047;
            if (($0 | 0) == ($6 | 0)) {
             $0 = $0 + 1 & 2047;
             HEAP32[($1 + ($0 << 2) | 0) + 780 >> 2] = 0;
            }
            __floatunsitf($1 + 768 | 0, HEAP32[($1 + 784 | 0) + ($6 << 2) >> 2]);
            __multf3($1 + 752 | 0, $2, $5, $13, $9, 0, 0, 1342177280, 1075633366);
            __addtf3($1 + 736 | 0, HEAP32[$1 + 752 >> 2], HEAP32[$1 + 756 >> 2], HEAP32[$1 + 760 >> 2], HEAP32[$1 + 764 >> 2], HEAP32[$1 + 768 >> 2], HEAP32[$1 + 772 >> 2], HEAP32[$1 + 776 >> 2], HEAP32[$1 + 780 >> 2]);
            $13 = HEAP32[$1 + 744 >> 2];
            $9 = HEAP32[$1 + 748 >> 2];
            $2 = HEAP32[$1 + 736 >> 2];
            $5 = HEAP32[$1 + 740 >> 2];
            $7 = $7 + 1 | 0;
            if (($7 | 0) != 4) {
             continue
            }
            break;
           };
           __floatsitf($1 + 720 | 0, $11);
           __multf3($1 + 704 | 0, $2, $5, $13, $9, HEAP32[$1 + 720 >> 2], HEAP32[$1 + 724 >> 2], HEAP32[$1 + 728 >> 2], HEAP32[$1 + 732 >> 2]);
           $2 = 0;
           $5 = 0;
           $13 = HEAP32[$1 + 712 >> 2];
           $9 = HEAP32[$1 + 716 >> 2];
           $8 = HEAP32[$1 + 704 >> 2];
           $6 = HEAP32[$1 + 708 >> 2];
           $18 = $15 + 113 | 0;
           $22 = $18 - $23 | 0;
           $23 = ($22 | 0) < ($12 | 0);
           $12 = $23 ? (($22 | 0) > 0 ? $22 : 0) : $12;
           if ($12 >>> 0 <= 112) {
            break block48
           }
           $7 = 0;
           $24 = 0;
           $14 = 0;
           break block49;
          }
          $15 = $15 + $22 | 0;
          $6 = $0;
          if (($3 | 0) == ($0 | 0)) {
           continue
          }
          break;
         };
         $8 = 1e9 >>> $22 | 0;
         $13 = -1 << $22 ^ -1;
         $7 = 0;
         $6 = $3;
         while (1) {
          $5 = $1 + 784 | 0;
          $9 = $5 + ($3 << 2) | 0;
          $10 = HEAP32[$9 >> 2];
          $7 = $7 + ($10 >>> $22 | 0) | 0;
          HEAP32[$9 >> 2] = $7;
          $9 = !$7 & ($3 | 0) == ($6 | 0);
          $6 = $9 ? $6 + 1 & 2047 : $6;
          $14 = $9 ? $14 - 9 | 0 : $14;
          $7 = Math_imul($8, $10 & $13);
          $3 = $3 + 1 & 2047;
          if (($0 | 0) != ($3 | 0)) {
           continue
          }
          break;
         };
         if (!$7) {
          continue
         }
         if (($2 | 0) != ($6 | 0)) {
          HEAP32[($0 << 2) + $5 >> 2] = $7;
          $0 = $2;
          continue label14;
         }
         HEAP32[$18 >> 2] = HEAP32[$18 >> 2] | 1;
         continue;
        }
        break;
       };
       break;
      };
      __extenddftf2($1 + 656 | 0, scalbn(1.0, 225 - $12 | 0));
      copysignl($1 + 688 | 0, HEAP32[$1 + 656 >> 2], HEAP32[$1 + 660 >> 2], HEAP32[$1 + 664 >> 2], HEAP32[$1 + 668 >> 2], $9);
      $24 = HEAP32[$1 + 696 >> 2];
      $14 = HEAP32[$1 + 700 >> 2];
      $20 = HEAP32[$1 + 688 >> 2];
      $21 = HEAP32[$1 + 692 >> 2];
      __extenddftf2($1 + 640 | 0, scalbn(1.0, 113 - $12 | 0));
      fmodl($1 + 672 | 0, $8, $6, $13, $9, HEAP32[$1 + 640 >> 2], HEAP32[$1 + 644 >> 2], HEAP32[$1 + 648 >> 2], HEAP32[$1 + 652 >> 2]);
      $2 = HEAP32[$1 + 672 >> 2];
      $5 = HEAP32[$1 + 676 >> 2];
      $7 = HEAP32[$1 + 680 >> 2];
      $16 = HEAP32[$1 + 684 >> 2];
      __subtf3($1 + 624 | 0, $8, $6, $13, $9, $2, $5, $7, $16);
      __addtf3($1 + 608 | 0, $20, $21, $24, $14, HEAP32[$1 + 624 >> 2], HEAP32[$1 + 628 >> 2], HEAP32[$1 + 632 >> 2], HEAP32[$1 + 636 >> 2]);
      $13 = HEAP32[$1 + 616 >> 2];
      $9 = HEAP32[$1 + 620 >> 2];
      $8 = HEAP32[$1 + 608 >> 2];
      $6 = HEAP32[$1 + 612 >> 2];
     }
     $10 = $3 + 4 & 2047;
     block51 : {
      if (($10 | 0) == ($0 | 0)) {
       break block51
      }
      $10 = HEAP32[($1 + 784 | 0) + ($10 << 2) >> 2];
      block54 : {
       if ($10 >>> 0 <= 499999999) {
        if (!$10 & ($3 + 5 & 2047) == ($0 | 0)) {
         break block54
        }
        __extenddftf2($1 + 496 | 0, +($11 | 0) * .25);
        __addtf3($1 + 480 | 0, $2, $5, $7, $16, HEAP32[$1 + 496 >> 2], HEAP32[$1 + 500 >> 2], HEAP32[$1 + 504 >> 2], HEAP32[$1 + 508 >> 2]);
        $7 = HEAP32[$1 + 488 >> 2];
        $16 = HEAP32[$1 + 492 >> 2];
        $2 = HEAP32[$1 + 480 >> 2];
        $5 = HEAP32[$1 + 484 >> 2];
        break block54;
       }
       if (($10 | 0) != 5e8) {
        __extenddftf2($1 + 592 | 0, +($11 | 0) * .75);
        __addtf3($1 + 576 | 0, $2, $5, $7, $16, HEAP32[$1 + 592 >> 2], HEAP32[$1 + 596 >> 2], HEAP32[$1 + 600 >> 2], HEAP32[$1 + 604 >> 2]);
        $7 = HEAP32[$1 + 584 >> 2];
        $16 = HEAP32[$1 + 588 >> 2];
        $2 = HEAP32[$1 + 576 >> 2];
        $5 = HEAP32[$1 + 580 >> 2];
        break block54;
       }
       $29 = +($11 | 0);
       if (($0 | 0) == ($3 + 5 & 2047)) {
        __extenddftf2($1 + 528 | 0, $29 * .5);
        __addtf3($1 + 512 | 0, $2, $5, $7, $16, HEAP32[$1 + 528 >> 2], HEAP32[$1 + 532 >> 2], HEAP32[$1 + 536 >> 2], HEAP32[$1 + 540 >> 2]);
        $7 = HEAP32[$1 + 520 >> 2];
        $16 = HEAP32[$1 + 524 >> 2];
        $2 = HEAP32[$1 + 512 >> 2];
        $5 = HEAP32[$1 + 516 >> 2];
        break block54;
       }
       __extenddftf2($1 + 560 | 0, $29 * .75);
       __addtf3($1 + 544 | 0, $2, $5, $7, $16, HEAP32[$1 + 560 >> 2], HEAP32[$1 + 564 >> 2], HEAP32[$1 + 568 >> 2], HEAP32[$1 + 572 >> 2]);
       $7 = HEAP32[$1 + 552 >> 2];
       $16 = HEAP32[$1 + 556 >> 2];
       $2 = HEAP32[$1 + 544 >> 2];
       $5 = HEAP32[$1 + 548 >> 2];
      }
      if ($12 >>> 0 > 111) {
       break block51
      }
      fmodl($1 + 464 | 0, $2, $5, $7, $16, 0, 0, 0, 1073676288);
      if (__letf2(HEAP32[$1 + 464 >> 2], HEAP32[$1 + 468 >> 2], HEAP32[$1 + 472 >> 2], HEAP32[$1 + 476 >> 2], 0, 0, 0, 0)) {
       break block51
      }
      __addtf3($1 + 448 | 0, $2, $5, $7, $16, 0, 0, 0, 1073676288);
      $7 = HEAP32[$1 + 456 >> 2];
      $16 = HEAP32[$1 + 460 >> 2];
      $2 = HEAP32[$1 + 448 >> 2];
      $5 = HEAP32[$1 + 452 >> 2];
     }
     __addtf3($1 + 432 | 0, $8, $6, $13, $9, $2, $5, $7, $16);
     __subtf3($1 + 416 | 0, HEAP32[$1 + 432 >> 2], HEAP32[$1 + 436 >> 2], HEAP32[$1 + 440 >> 2], HEAP32[$1 + 444 >> 2], $20, $21, $24, $14);
     $13 = HEAP32[$1 + 424 >> 2];
     $9 = HEAP32[$1 + 428 >> 2];
     $8 = HEAP32[$1 + 416 >> 2];
     $6 = HEAP32[$1 + 420 >> 2];
     block57 : {
      if (($28 - 2 | 0) >= ($18 & 2147483647)) {
       break block57
      }
      $0 = $1 + 400 | 0;
      HEAP32[$0 + 8 >> 2] = $13;
      HEAP32[$0 + 12 >> 2] = $9 & 2147483647;
      HEAP32[$0 >> 2] = $8;
      HEAP32[$0 + 4 >> 2] = $6;
      __multf3($1 + 384 | 0, $8, $6, $13, $9, 0, 0, 0, 1073610752);
      $3 = __getf2(HEAP32[$1 + 400 >> 2], HEAP32[$1 + 404 >> 2], HEAP32[$1 + 408 >> 2], HEAP32[$1 + 412 >> 2], 1081081856);
      $10 = ($3 | 0) >= 0;
      $13 = $10 ? HEAP32[$1 + 392 >> 2] : $13;
      $9 = $10 ? HEAP32[$1 + 396 >> 2] : $9;
      $8 = $10 ? HEAP32[$1 + 384 >> 2] : $8;
      $6 = $10 ? HEAP32[$1 + 388 >> 2] : $6;
      $0 = __letf2($2, $5, $7, $16, 0, 0, 0, 0);
      $15 = $10 + $15 | 0;
      if (($28 | 0) >= ($15 + 110 | 0)) {
       if (!($23 & (($12 | 0) != ($22 | 0) | ($3 | 0) < 0) & ($0 | 0) != 0)) {
        break block57
       }
      }
      HEAP32[4484] = 68;
     }
     scalbnl($1 + 368 | 0, $8, $6, $13, $9, $15);
     $5 = HEAP32[$1 + 380 >> 2];
     $13 = HEAP32[$1 + 368 >> 2];
     $9 = HEAP32[$1 + 372 >> 2];
     $0 = HEAP32[$1 + 376 >> 2];
    }
    HEAP32[$25 + 8 >> 2] = $0;
    HEAP32[$25 + 12 >> 2] = $5;
    HEAP32[$25 >> 2] = $13;
    HEAP32[$25 + 4 >> 2] = $9;
    __stack_pointer = $1 + 8976 | 0;
    $2 = HEAP32[$19 + 40 >> 2];
    $8 = HEAP32[$19 + 44 >> 2];
    $5 = HEAP32[$19 + 32 >> 2];
    $9 = HEAP32[$19 + 36 >> 2];
    break block14;
   }
   $2 = 0;
   $8 = 0;
  }
  HEAP32[$17 >> 2] = $5;
  HEAP32[$17 + 4 >> 2] = $9;
  HEAP32[$17 + 8 >> 2] = $2;
  HEAP32[$17 + 12 >> 2] = $8;
  __stack_pointer = $19 + 48 | 0;
  $6 = HEAP32[$17 + 12 >> 2];
  $2 = HEAP32[$17 >> 2];
  $0 = HEAP32[$17 + 4 >> 2];
  HEAP32[$26 + 8 >> 2] = HEAP32[$17 + 8 >> 2];
  HEAP32[$26 + 12 >> 2] = $6;
  HEAP32[$26 >> 2] = $2;
  HEAP32[$26 + 4 >> 2] = $0;
  __stack_pointer = $17 + 160 | 0;
  $5 = HEAP32[$26 >> 2];
  $23 = HEAP32[$26 + 4 >> 2];
  $17 = HEAP32[$26 + 8 >> 2];
  $12 = __stack_pointer - 32 | 0;
  __stack_pointer = $12;
  $9 = HEAP32[$26 + 12 >> 2];
  $6 = $9 & 65535;
  $0 = $9 >>> 16 & 32767;
  $10 = $0;
  block30 : {
   if ($0 - 15361 >>> 0 <= 2045) {
    $3 = $17 << 4 | $23 >>> 28;
    $0 = $6 << 4 | $17 >>> 28;
    $6 = $10 - 15360 | 0;
    $2 = $23 & 268435455;
    block29 : {
     if (!(!$5 & ($2 | 0) == 134217728 | $2 >>> 0 < 134217728)) {
      $3 = $3 + 1 | 0;
      $0 = $3 ? $0 : $0 + 1 | 0;
      break block29;
     }
     if ($5 | ($2 | 0) != 134217728) {
      break block29
     }
     $2 = $3;
     $3 = $3 + ($3 & 1) | 0;
     $0 = $2 >>> 0 > $3 >>> 0 ? $0 + 1 | 0 : $0;
    }
    $2 = $0 >>> 0 > 1048575;
    $5 = $2 ? 0 : $3;
    $0 = $2 ? 0 : $0;
    $3 = $2 + $6 | 0;
    $2 = $6 >>> 0 > $3 >>> 0;
    break block30;
   }
   if (!(!($5 | $17 | ($6 | $23)) | ($0 | 0) != 32767)) {
    $5 = $17 << 4 | $23 >>> 28;
    $0 = $6 << 4 | $17 >>> 28 | 524288;
    $3 = 2047;
    $2 = 0;
    break block30;
   }
   if ($10 >>> 0 > 17406) {
    $3 = 2047;
    $5 = 0;
    $0 = 0;
    $2 = 0;
    break block30;
   }
   $0 = !$0;
   $3 = $0 ? 15360 : 15361;
   $2 = $3 - $10 | 0;
   if (($2 | 0) > 112) {
    $5 = 0;
    $0 = 0;
    $3 = 0;
    $2 = 0;
    break block30;
   }
   $0 = $0 ? $6 : $6 | 65536;
   __ashlti3($12 + 16 | 0, $5, $23, $17, $0, 128 - $2 | 0);
   __lshrti3($12, $5, $23, $17, $0, $2);
   $2 = HEAP32[$12 + 4 >> 2];
   $6 = $2;
   $0 = HEAP32[$12 + 8 >> 2];
   $5 = $0 << 4 | $2 >>> 28;
   $0 = HEAP32[$12 + 12 >> 2] << 4 | $0 >>> 28;
   $2 = HEAP32[$12 >> 2] | ($3 | 0) != ($10 | 0) & (HEAP32[$12 + 16 >> 2] | HEAP32[$12 + 24 >> 2] | (HEAP32[$12 + 20 >> 2] | HEAP32[$12 + 28 >> 2])) != 0;
   $6 = $6 & 268435455;
   block8 : {
    if (!(!$2 & ($6 | 0) == 134217728 | $6 >>> 0 < 134217728)) {
     $5 = $5 + 1 | 0;
     $0 = $5 ? $0 : $0 + 1 | 0;
     break block8;
    }
    if ($2 | ($6 | 0) != 134217728) {
     break block8
    }
    $2 = $5;
    $5 = $5 + ($5 & 1) | 0;
    $0 = $2 >>> 0 > $5 >>> 0 ? $0 + 1 | 0 : $0;
   }
   $3 = $0 >>> 0 > 1048575;
   $0 = $3 ? $0 ^ 1048576 : $0;
   $2 = 0;
  }
  __stack_pointer = $12 + 32 | 0;
  wasm2js_scratch_store_i32(0, $5 | 0);
  wasm2js_scratch_store_i32(1, $0 | ($9 & -2147483648 | $3 << 20));
  $29 = +wasm2js_scratch_load_f64();
  __stack_pointer = $26 + 16 | 0;
  return $29;
 }
 
 function __cos($0, $1) {
  var $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0;
  $2 = $0 * $0;
  $3 = $2 * .5;
  $4 = 1.0 - $3;
  $5 = 1.0 - $4 - $3;
  $3 = $2 * $2;
  return $4 + ($5 + ($2 * ($2 * ($2 * ($2 * 2.480158728947673e-05 + -.001388888888887411) + .0416666666666666) + $3 * $3 * ($2 * ($2 * -1.1359647557788195e-11 + 2.087572321298175e-09) + -2.7557314351390663e-07)) - $0 * $1));
 }
 
 function __sin($0, $1) {
  var $2 = 0.0, $3 = 0.0;
  $2 = $0 * $0;
  $3 = $0;
  $0 = $0 * $2;
  return $3 - ($2 * ($1 * .5 - $0 * ($2 * ($2 * $2) * ($2 * 1.58969099521155e-10 + -2.5050760253406863e-08) + ($2 * ($2 * 2.7557313707070068e-06 + -1.984126982985795e-04) + .00833333333332249))) - $1 + $0 * .16666666666666632);
 }
 
 function cos($0) {
  var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0.0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0.0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
  $5 = __stack_pointer - 16 | 0;
  __stack_pointer = $5;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $2 = $2 & 2147483647;
  block1 : {
   if ($2 >>> 0 <= 1072243195) {
    $7 = 1.0;
    if ($2 >>> 0 < 1044816030) {
     break block1
    }
    $7 = __cos($0, 0.0);
    break block1;
   }
   $7 = $0 - $0;
   if ($2 >>> 0 >= 2146435072) {
    break block1
   }
   $14 = __stack_pointer - 48 | 0;
   __stack_pointer = $14;
   wasm2js_scratch_store_f64(+$0);
   $16 = wasm2js_scratch_load_i32(1) | 0;
   $1 = wasm2js_scratch_load_i32(0) | 0;
   block4 : {
    block10 : {
     $8 = $16 & 2147483647;
     block11 : {
      if ($8 >>> 0 <= 1074752122) {
       if (($16 & 1048575) == 598523) {
        break block11
       }
       if ($8 >>> 0 <= 1073928572) {
        if (($16 | 0) >= 0) {
         $0 = $0 + -1.5707963267341256;
         $3 = $0 + -6.077100506506192e-11;
         HEAPF64[$5 >> 3] = $3;
         HEAPF64[$5 + 8 >> 3] = $0 - $3 + -6.077100506506192e-11;
         $2 = 1;
         break block4;
        }
        $0 = $0 + 1.5707963267341256;
        $3 = $0 + 6.077100506506192e-11;
        HEAPF64[$5 >> 3] = $3;
        HEAPF64[$5 + 8 >> 3] = $0 - $3 + 6.077100506506192e-11;
        $2 = -1;
        break block4;
       }
       if (($16 | 0) >= 0) {
        $0 = $0 + -3.1415926534682512;
        $3 = $0 + -1.2154201013012384e-10;
        HEAPF64[$5 >> 3] = $3;
        HEAPF64[$5 + 8 >> 3] = $0 - $3 + -1.2154201013012384e-10;
        $2 = 2;
        break block4;
       }
       $0 = $0 + 3.1415926534682512;
       $3 = $0 + 1.2154201013012384e-10;
       HEAPF64[$5 >> 3] = $3;
       HEAPF64[$5 + 8 >> 3] = $0 - $3 + 1.2154201013012384e-10;
       $2 = -2;
       break block4;
      }
      if ($8 >>> 0 <= 1075594811) {
       if ($8 >>> 0 <= 1075183036) {
        if (($8 | 0) == 1074977148) {
         break block11
        }
        if (($16 | 0) >= 0) {
         $0 = $0 + -4.712388980202377;
         $3 = $0 + -1.8231301519518578e-10;
         HEAPF64[$5 >> 3] = $3;
         HEAPF64[$5 + 8 >> 3] = $0 - $3 + -1.8231301519518578e-10;
         $2 = 3;
         break block4;
        }
        $0 = $0 + 4.712388980202377;
        $3 = $0 + 1.8231301519518578e-10;
        HEAPF64[$5 >> 3] = $3;
        HEAPF64[$5 + 8 >> 3] = $0 - $3 + 1.8231301519518578e-10;
        $2 = -3;
        break block4;
       }
       if (($8 | 0) == 1075388923) {
        break block11
       }
       if (($16 | 0) >= 0) {
        $0 = $0 + -6.2831853069365025;
        $3 = $0 + -2.430840202602477e-10;
        HEAPF64[$5 >> 3] = $3;
        HEAPF64[$5 + 8 >> 3] = $0 - $3 + -2.430840202602477e-10;
        $2 = 4;
        break block4;
       }
       $0 = $0 + 6.2831853069365025;
       $3 = $0 + 2.430840202602477e-10;
       HEAPF64[$5 >> 3] = $3;
       HEAPF64[$5 + 8 >> 3] = $0 - $3 + 2.430840202602477e-10;
       $2 = -4;
       break block4;
      }
      if ($8 >>> 0 > 1094263290) {
       break block10
      }
     }
     $3 = $0 * .6366197723675814 + 6755399441055744.0 + -6755399441055744.0;
     if (Math_abs($3) < 2147483647.0) {
      $2 = ~~$3
     } else {
      $2 = -2147483648
     }
     $7 = $0 + $3 * -1.5707963267341256;
     $12 = $3 * 6.077100506506192e-11;
     $21 = $7 - $12;
     block12 : {
      if ($21 < -.7853981633974483) {
       $2 = $2 - 1 | 0;
       $3 = $3 + -1.0;
       $12 = $3 * 6.077100506506192e-11;
       $7 = $0 + $3 * -1.5707963267341256;
       break block12;
      }
      if (!($21 > .7853981633974483)) {
       break block12
      }
      $2 = $2 + 1 | 0;
      $3 = $3 + 1.0;
      $12 = $3 * 6.077100506506192e-11;
      $7 = $0 + $3 * -1.5707963267341256;
     }
     $0 = $7 - $12;
     HEAPF64[$5 >> 3] = $0;
     wasm2js_scratch_store_f64(+$0);
     $1 = wasm2js_scratch_load_i32(1) | 0;
     wasm2js_scratch_load_i32(0) | 0;
     $4 = $8 >>> 20 | 0;
     block13 : {
      if (($4 - ($1 >>> 20 & 2047) | 0) < 17) {
       break block13
      }
      $12 = $7;
      $0 = $3 * 6.077100506303966e-11;
      $7 = $7 - $0;
      $12 = $3 * 2.0222662487959506e-21 - ($12 - $7 - $0);
      $0 = $7 - $12;
      HEAPF64[$5 >> 3] = $0;
      wasm2js_scratch_store_f64(+$0);
      $1 = wasm2js_scratch_load_i32(1) | 0;
      wasm2js_scratch_load_i32(0) | 0;
      if (($4 - ($1 >>> 20 & 2047) | 0) < 50) {
       break block13
      }
      $12 = $7;
      $0 = $3 * 2.0222662487111665e-21;
      $7 = $7 - $0;
      $12 = $3 * 8.4784276603689e-32 - ($12 - $7 - $0);
      $0 = $7 - $12;
      HEAPF64[$5 >> 3] = $0;
     }
     HEAPF64[$5 + 8 >> 3] = $7 - $0 - $12;
     break block4;
    }
    if ($8 >>> 0 >= 2146435072) {
     $0 = $0 - $0;
     HEAPF64[$5 >> 3] = $0;
     HEAPF64[$5 + 8 >> 3] = $0;
     $2 = 0;
     break block4;
    }
    $2 = $14 + 16 | 0;
    $4 = $2 | 8;
    wasm2js_scratch_store_i32(0, $1 | 0);
    wasm2js_scratch_store_i32(1, $16 & 1048575 | 1096810496);
    $0 = +wasm2js_scratch_load_f64();
    $1 = 1;
    while (1) {
     $3 = +((Math_abs($0) < 2147483647.0 ? ~~$0 : -2147483648) | 0);
     HEAPF64[$2 >> 3] = $3;
     $0 = ($0 - $3) * 16777216.0;
     $10 = $1;
     $1 = 0;
     $2 = $4;
     if ($10) {
      continue
     }
     break;
    };
    HEAPF64[$14 + 32 >> 3] = $0;
    $2 = 2;
    while (1) {
     $1 = $2;
     $2 = $2 - 1 | 0;
     $18 = $14 + 16 | 0;
     if (HEAPF64[$18 + ($1 << 3) >> 3] == 0.0) {
      continue
     }
     break;
    };
    $4 = 0;
    $6 = __stack_pointer - 560 | 0;
    __stack_pointer = $6;
    $2 = ($8 >>> 20 | 0) - 1046 | 0;
    $10 = ($2 - 3 | 0) / 24 | 0;
    $20 = ($10 | 0) > 0 ? $10 : 0;
    $15 = Math_imul($20, -24) + $2 | 0;
    $10 = HEAP32[3053];
    $17 = $1 + 1 | 0;
    $9 = $17 - 1 | 0;
    if (($10 + $9 | 0) >= 0) {
     $2 = $10 + $17 | 0;
     $1 = $20 - $9 | 0;
     while (1) {
      HEAPF64[($6 + 320 | 0) + ($4 << 3) >> 3] = ($1 | 0) < 0 ? 0.0 : +HEAP32[($1 << 2) + 12224 >> 2];
      $1 = $1 + 1 | 0;
      $4 = $4 + 1 | 0;
      if (($2 | 0) != ($4 | 0)) {
       continue
      }
      break;
     };
    }
    $8 = $15 - 24 | 0;
    $2 = 0;
    $4 = ($10 | 0) > 0 ? $10 : 0;
    $11 = ($17 | 0) <= 0;
    while (1) {
     block41 : {
      if ($11) {
       $0 = 0.0;
       break block41;
      }
      $13 = $2 + $9 | 0;
      $1 = 0;
      $0 = 0.0;
      while (1) {
       $0 = HEAPF64[($1 << 3) + $18 >> 3] * HEAPF64[($6 + 320 | 0) + ($13 - $1 << 3) >> 3] + $0;
       $1 = $1 + 1 | 0;
       if (($17 | 0) != ($1 | 0)) {
        continue
       }
       break;
      };
     }
     HEAPF64[($2 << 3) + $6 >> 3] = $0;
     $1 = ($2 | 0) == ($4 | 0);
     $2 = $2 + 1 | 0;
     if (!$1) {
      continue
     }
     break;
    };
    $24 = 47 - $15 | 0;
    $22 = 48 - $15 | 0;
    $25 = $15 - 25 | 0;
    $2 = $10;
    block21 : {
     while (1) {
      $0 = HEAPF64[($2 << 3) + $6 >> 3];
      $1 = 0;
      $4 = $2;
      if (($2 | 0) > 0) {
       while (1) {
        $11 = ($6 + 480 | 0) + ($1 << 2) | 0;
        $3 = $0 * 5.9604644775390625e-08;
        if (Math_abs($3) < 2147483647.0) {
         $9 = ~~$3
        } else {
         $9 = -2147483648
        }
        $3 = +($9 | 0);
        $0 = $3 * -16777216.0 + $0;
        if (Math_abs($0) < 2147483647.0) {
         $9 = ~~$0
        } else {
         $9 = -2147483648
        }
        HEAP32[$11 >> 2] = $9;
        $4 = $4 - 1 | 0;
        $0 = HEAPF64[($4 << 3) + $6 >> 3] + $3;
        $1 = $1 + 1 | 0;
        if (($2 | 0) != ($1 | 0)) {
         continue
        }
        break;
       }
      }
      $0 = scalbn($0, $8);
      $0 = $0 + Math_floor($0 * .125) * -8.0;
      if (Math_abs($0) < 2147483647.0) {
       $9 = ~~$0
      } else {
       $9 = -2147483648
      }
      $0 = $0 - +($9 | 0);
      block9 : {
       block103 : {
        block8 : {
         $23 = ($8 | 0) <= 0;
         block7 : {
          if (!$23) {
           $4 = ($6 + ($2 << 2) | 0) + 476 | 0;
           $11 = HEAP32[$4 >> 2];
           $1 = $11 >> $22;
           $19 = $4;
           $4 = $11 - ($1 << $22) | 0;
           HEAP32[$19 >> 2] = $4;
           $9 = $1 + $9 | 0;
           $11 = $4 >> $24;
           break block7;
          }
          if ($8) {
           break block8
          }
          $11 = HEAP32[($6 + ($2 << 2) | 0) + 476 >> 2] >> 23;
         }
         if (($11 | 0) <= 0) {
          break block9
         }
         break block103;
        }
        $11 = 2;
        if ($0 >= .5) {
         break block103
        }
        $11 = 0;
        break block9;
       }
       $1 = 0;
       $13 = 0;
       $4 = 1;
       if (($2 | 0) > 0) {
        while (1) {
         $19 = ($6 + 480 | 0) + ($1 << 2) | 0;
         $4 = HEAP32[$19 >> 2];
         block15 : {
          block14 : {
           if ($13) {
            $13 = 16777215
           } else {
            if (!$4) {
             break block14
            }
            $13 = 16777216;
           }
           HEAP32[$19 >> 2] = $13 - $4;
           $13 = 1;
           $4 = 0;
           break block15;
          }
          $13 = 0;
          $4 = 1;
         }
         $1 = $1 + 1 | 0;
         if (($2 | 0) != ($1 | 0)) {
          continue
         }
         break;
        }
       }
       block16 : {
        if ($23) {
         break block16
        }
        $1 = 8388607;
        block17 : {
         switch ($25 | 0) {
         case 1:
          $1 = 4194303;
          break;
         case 0:
          break block17;
         default:
          break block16;
         };
        }
        $13 = ($6 + ($2 << 2) | 0) + 476 | 0;
        HEAP32[$13 >> 2] = HEAP32[$13 >> 2] & $1;
       }
       $9 = $9 + 1 | 0;
       if (($11 | 0) != 2) {
        break block9
       }
       $0 = 1.0 - $0;
       $11 = 2;
       if ($4) {
        break block9
       }
       $0 = $0 - scalbn(1.0, $8);
      }
      if ($0 == 0.0) {
       $4 = 0;
       block20 : {
        $1 = $2;
        if (($10 | 0) >= ($2 | 0)) {
         break block20
        }
        while (1) {
         $1 = $1 - 1 | 0;
         $4 = HEAP32[($6 + 480 | 0) + ($1 << 2) >> 2] | $4;
         if (($1 | 0) > ($10 | 0)) {
          continue
         }
         break;
        };
        if (!$4) {
         break block20
        }
        while (1) {
         $8 = $8 - 24 | 0;
         $2 = $2 - 1 | 0;
         if (!HEAP32[($6 + 480 | 0) + ($2 << 2) >> 2]) {
          continue
         }
         break;
        };
        break block21;
       }
       $1 = 1;
       while (1) {
        $4 = $1;
        $1 = $1 + 1 | 0;
        if (!HEAP32[($6 + 480 | 0) + ($10 - $4 << 2) >> 2]) {
         continue
        }
        break;
       };
       $4 = $2 + $4 | 0;
       while (1) {
        $9 = $2 + $17 | 0;
        $2 = $2 + 1 | 0;
        HEAPF64[($6 + 320 | 0) + ($9 << 3) >> 3] = HEAP32[($2 + $20 << 2) + 12224 >> 2];
        $1 = 0;
        $0 = 0.0;
        if (($17 | 0) > 0) {
         while (1) {
          $0 = HEAPF64[($1 << 3) + $18 >> 3] * HEAPF64[($6 + 320 | 0) + ($9 - $1 << 3) >> 3] + $0;
          $1 = $1 + 1 | 0;
          if (($17 | 0) != ($1 | 0)) {
           continue
          }
          break;
         }
        }
        HEAPF64[($2 << 3) + $6 >> 3] = $0;
        if (($2 | 0) < ($4 | 0)) {
         continue
        }
        break;
       };
       $2 = $4;
       continue;
      }
      break;
     };
     $0 = scalbn($0, 24 - $15 | 0);
     block24 : {
      if ($0 >= 16777216.0) {
       $8 = ($6 + 480 | 0) + ($2 << 2) | 0;
       $3 = $0 * 5.9604644775390625e-08;
       if (Math_abs($3) < 2147483647.0) {
        $1 = ~~$3
       } else {
        $1 = -2147483648
       }
       $0 = +($1 | 0) * -16777216.0 + $0;
       if (Math_abs($0) < 2147483647.0) {
        $4 = ~~$0
       } else {
        $4 = -2147483648
       }
       HEAP32[$8 >> 2] = $4;
       $2 = $2 + 1 | 0;
       $8 = $15;
       break block24;
      }
      $1 = Math_abs($0) < 2147483647.0 ? ~~$0 : -2147483648;
     }
     HEAP32[($6 + 480 | 0) + ($2 << 2) >> 2] = $1;
    }
    $0 = scalbn(1.0, $8);
    if (($2 | 0) >= 0) {
     $1 = $2;
     while (1) {
      $4 = $1;
      HEAPF64[($1 << 3) + $6 >> 3] = $0 * +HEAP32[($6 + 480 | 0) + ($1 << 2) >> 2];
      $1 = $1 - 1 | 0;
      $0 = $0 * 5.9604644775390625e-08;
      if ($4) {
       continue
      }
      break;
     };
     $4 = $2;
     while (1) {
      $0 = 0.0;
      $1 = 0;
      $8 = $2 - $4 | 0;
      $15 = ($8 | 0) > ($10 | 0) ? $10 : $8;
      if (($15 | 0) >= 0) {
       while (1) {
        $0 = HEAPF64[($1 << 3) + 14992 >> 3] * HEAPF64[($1 + $4 << 3) + $6 >> 3] + $0;
        $18 = ($1 | 0) != ($15 | 0);
        $1 = $1 + 1 | 0;
        if ($18) {
         continue
        }
        break;
       }
      }
      HEAPF64[($6 + 160 | 0) + ($8 << 3) >> 3] = $0;
      $1 = ($4 | 0) > 0;
      $4 = $4 - 1 | 0;
      if ($1) {
       continue
      }
      break;
     };
    }
    $0 = 0.0;
    if (($2 | 0) >= 0) {
     $1 = $2;
     while (1) {
      $4 = $1;
      $1 = $1 - 1 | 0;
      $0 = $0 + HEAPF64[($6 + 160 | 0) + ($4 << 3) >> 3];
      if ($4) {
       continue
      }
      break;
     };
    }
    HEAPF64[$14 >> 3] = $11 ? -$0 : $0;
    $0 = HEAPF64[$6 + 160 >> 3] - $0;
    $1 = 1;
    if (($2 | 0) > 0) {
     while (1) {
      $0 = $0 + HEAPF64[($6 + 160 | 0) + ($1 << 3) >> 3];
      $4 = ($1 | 0) != ($2 | 0);
      $1 = $1 + 1 | 0;
      if ($4) {
       continue
      }
      break;
     }
    }
    HEAPF64[$14 + 8 >> 3] = $11 ? -$0 : $0;
    __stack_pointer = $6 + 560 | 0;
    $2 = $9 & 7;
    $0 = HEAPF64[$14 >> 3];
    if (($16 | 0) < 0) {
     HEAPF64[$5 >> 3] = -$0;
     HEAPF64[$5 + 8 >> 3] = -HEAPF64[$14 + 8 >> 3];
     $2 = 0 - $2 | 0;
     break block4;
    }
    HEAPF64[$5 >> 3] = $0;
    HEAPF64[$5 + 8 >> 3] = HEAPF64[$14 + 8 >> 3];
   }
   __stack_pointer = $14 + 48 | 0;
   $0 = HEAPF64[$5 + 8 >> 3];
   $3 = HEAPF64[$5 >> 3];
   block6 : {
    switch (($2 & 3) - 1 | 0) {
    default:
     $7 = __cos($3, $0);
     break block1;
    case 0:
     $7 = -__sin($3, $0);
     break block1;
    case 1:
     $7 = -__cos($3, $0);
     break block1;
    case 2:
     break block6;
    };
   }
   $7 = __sin($3, $0);
  }
  $0 = $7;
  __stack_pointer = $5 + 16 | 0;
  return $0;
 }
 
 function __math_xflow($0) {
  return $0 * fp_barrier($0);
 }
 
 function exp($0) {
  var $1 = 0.0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0;
  block3 : {
   block1 : {
    $2 = top12($0) & 2047;
    $5 = top12(5.551115123125783e-17);
    if ($2 - $5 >>> 0 < top12(512.0) - $5 >>> 0) {
     $4 = $2;
     break block1;
    }
    if ($2 >>> 0 < $5 >>> 0) {
     return $0 + 1.0
    }
    if (top12(1024.0) >>> 0 > $2 >>> 0) {
     break block1
    }
    wasm2js_scratch_store_f64(+$0);
    $4 = wasm2js_scratch_load_i32(1) | 0;
    $3 = 0.0;
    if (!(wasm2js_scratch_load_i32(0) | 0) & ($4 | 0) == -1048576) {
     break block3
    }
    if (top12(Infinity) >>> 0 <= $2 >>> 0) {
     return $0 + 1.0
    }
    if (($4 | 0) < 0) {
     return __math_xflow(1.2882297539194267e-231)
    }
    return __math_xflow(3105036184601417870297958.0e207);
   }
   $1 = HEAPF64[1883];
   $6 = $0 * HEAPF64[1882] + $1;
   $1 = $6 - $1;
   $1 = $1 * HEAPF64[1885] + ($1 * HEAPF64[1884] + $0);
   $0 = $1 * $1;
   $3 = $0 * $0 * ($1 * HEAPF64[1889] + HEAPF64[1888]);
   $0 = $0 * ($1 * HEAPF64[1887] + HEAPF64[1886]);
   wasm2js_scratch_store_f64(+$6);
   wasm2js_scratch_load_i32(1) | 0;
   $5 = wasm2js_scratch_load_i32(0) | 0;
   $2 = $5 << 4 & 2032;
   $1 = $3 + ($0 + (HEAPF64[$2 + 15168 >> 3] + $1));
   $2 = $2 + 15176 | 0;
   $7 = HEAP32[$2 >> 2];
   $2 = HEAP32[$2 + 4 >> 2] + ($5 << 13) | 0;
   if (!$4) {
    __inlined_func$specialcase$79 : {
     if (!($5 & -2147483648)) {
      wasm2js_scratch_store_i32(0, $7 | 0);
      wasm2js_scratch_store_i32(1, $2 - 1058013184 | 0);
      $0 = +wasm2js_scratch_load_f64();
      $0 = ($0 * $1 + $0) * 5486124068793688683255936.0e279;
      break __inlined_func$specialcase$79;
     }
     wasm2js_scratch_store_i32(0, $7 | 0);
     wasm2js_scratch_store_i32(1, $2 + 1071644672 | 0);
     $6 = +wasm2js_scratch_load_f64();
     $1 = $6 * $1;
     $3 = $1 + $6;
     if ($3 < 1.0) {
      $4 = __stack_pointer - 16 | 0;
      HEAP32[$4 + 8 >> 2] = 0;
      HEAP32[$4 + 12 >> 2] = 1048576;
      HEAPF64[$4 + 8 >> 3] = HEAPF64[$4 + 8 >> 3] * 2.2250738585072014e-308;
      $0 = $3 + 1.0;
      $0 = $0 + ($1 + ($6 - $3) + ($3 + (1.0 - $0))) + -1.0;
      $3 = $0 == 0.0 ? 0.0 : $0;
     }
     $0 = $3 * 2.2250738585072014e-308;
    }
    return $0;
   }
   wasm2js_scratch_store_i32(0, $7 | 0);
   wasm2js_scratch_store_i32(1, $2 | 0);
   $0 = +wasm2js_scratch_load_f64();
   $3 = $0 * $1 + $0;
  }
  return $3;
 }
 
 function top12($0) {
  var $1 = 0;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  return $1 >>> 20 | 0;
 }
 
 function FLAC__stream_encoder_new() {
  var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0;
  $3 = emscripten_builtin_calloc(1, 8);
  if (!$3) {
   return 0
  }
  $1 = emscripten_builtin_calloc(1, 1032);
  HEAP32[$3 >> 2] = $1;
  block1 : {
   if (!$1) {
    break block1
   }
   $0 = emscripten_builtin_calloc(1, 11856);
   HEAP32[$3 + 4 >> 2] = $0;
   if (!$0) {
    emscripten_builtin_free($1);
    break block1;
   }
   $2 = emscripten_builtin_calloc(1, 20);
   HEAP32[$0 + 6856 >> 2] = $2;
   if (!$2) {
    emscripten_builtin_free($0);
    emscripten_builtin_free($1);
    break block1;
   }
   HEAP32[$0 + 7296 >> 2] = 0;
   HEAP32[$1 + 556 >> 2] = 0;
   HEAP32[$1 + 560 >> 2] = 0;
   HEAP32[$1 + 44 >> 2] = 13;
   HEAP32[$1 + 48 >> 2] = 1056964608;
   HEAP32[$1 + 36 >> 2] = 0;
   HEAP32[$1 + 40 >> 2] = 1;
   HEAP32[$1 + 28 >> 2] = 16;
   HEAP32[$1 + 32 >> 2] = 44100;
   HEAP32[$1 + 20 >> 2] = 0;
   HEAP32[$1 + 24 >> 2] = 2;
   HEAP32[$1 + 12 >> 2] = 1;
   HEAP32[$1 + 16 >> 2] = 0;
   HEAP32[$1 + 4 >> 2] = 0;
   HEAP32[$1 + 8 >> 2] = 1;
   $2 = $1 + 564 | 0;
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 4 >> 2] = 0;
   $2 = $1 + 572 | 0;
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 4 >> 2] = 0;
   $2 = $1 + 580 | 0;
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 4 >> 2] = 0;
   HEAP32[$1 + 592 >> 2] = 0;
   HEAP32[$1 + 596 >> 2] = 0;
   $2 = $1 + 600 | 0;
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 4 >> 2] = 0;
   HEAP32[$0 + 7248 >> 2] = 0;
   HEAP32[$0 + 7252 >> 2] = 0;
   HEAP32[$0 + 7048 >> 2] = 0;
   $2 = $0 + 7256 | 0;
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 4 >> 2] = 0;
   $2 = $0 + 7264 | 0;
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 4 >> 2] = 0;
   $2 = $0 + 7272 | 0;
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 4 >> 2] = 0;
   $2 = $0 + 7280 | 0;
   HEAP32[$2 >> 2] = 0;
   HEAP32[$2 + 4 >> 2] = 0;
   HEAP32[$0 + 7288 >> 2] = 0;
   FLAC__ogg_encoder_aspect_set_defaults($1 + 632 | 0);
   block4 : {
    if (HEAP32[$1 >> 2] != 1) {
     break block4
    }
    HEAP32[$1 + 16 >> 2] = 1;
    HEAP32[$1 + 20 >> 2] = 0;
    FLAC__stream_encoder_set_apodization($3, 6467);
    if (HEAP32[$1 >> 2] != 1) {
     break block4
    }
    HEAP32[$1 + 576 >> 2] = 0;
    HEAP32[$1 + 580 >> 2] = 5;
    HEAP32[$1 + 564 >> 2] = 0;
    HEAP32[$1 + 568 >> 2] = 0;
    HEAP32[$1 + 556 >> 2] = 8;
    HEAP32[$1 + 560 >> 2] = 0;
   }
   HEAP32[$0 + 11848 >> 2] = 0;
   $2 = $0 + 6484 | 0;
   HEAP32[$0 + 6716 >> 2] = $2;
   $4 = $0 + 6472 | 0;
   HEAP32[$0 + 6712 >> 2] = $4;
   $5 = $0 + 6460 | 0;
   HEAP32[$0 + 6708 >> 2] = $5;
   $6 = $0 + 6448 | 0;
   HEAP32[$0 + 6704 >> 2] = $6;
   $7 = $0 + 6436 | 0;
   HEAP32[$0 + 6700 >> 2] = $7;
   $8 = $0 + 6424 | 0;
   HEAP32[$0 + 6696 >> 2] = $8;
   $9 = $0 + 6412 | 0;
   HEAP32[$0 + 6692 >> 2] = $9;
   $10 = $0 + 6400 | 0;
   HEAP32[$0 + 6688 >> 2] = $10;
   $11 = $0 + 6388 | 0;
   HEAP32[$0 + 6684 >> 2] = $11;
   $12 = $0 + 6376 | 0;
   HEAP32[$0 + 6680 >> 2] = $12;
   $13 = $0 + 6364 | 0;
   HEAP32[$0 + 6676 >> 2] = $13;
   $14 = $0 + 6352 | 0;
   HEAP32[$0 + 6672 >> 2] = $14;
   $15 = $0 + 6340 | 0;
   HEAP32[$0 + 6668 >> 2] = $15;
   $16 = $0 + 6328 | 0;
   HEAP32[$0 + 6664 >> 2] = $16;
   $17 = $0 + 6316 | 0;
   HEAP32[$0 + 6660 >> 2] = $17;
   $18 = $0 + 6304 | 0;
   HEAP32[$0 + 6656 >> 2] = $18;
   $19 = $0 + 6292 | 0;
   HEAP32[$0 + 6652 >> 2] = $19;
   $20 = $0 + 6280 | 0;
   HEAP32[$0 + 6648 >> 2] = $20;
   $21 = $0 + 6268 | 0;
   HEAP32[$0 + 6644 >> 2] = $21;
   $22 = $0 + 6256 | 0;
   HEAP32[$0 + 6640 >> 2] = $22;
   HEAP32[$0 + 6252 >> 2] = $0 + 5884;
   HEAP32[$0 + 6248 >> 2] = $0 + 5592;
   HEAP32[$0 + 6244 >> 2] = $0 + 5300;
   HEAP32[$0 + 6240 >> 2] = $0 + 5008;
   HEAP32[$0 + 6236 >> 2] = $0 + 4716;
   HEAP32[$0 + 6232 >> 2] = $0 + 4424;
   HEAP32[$0 + 6228 >> 2] = $0 + 4132;
   HEAP32[$0 + 6224 >> 2] = $0 + 3840;
   HEAP32[$0 + 6220 >> 2] = $0 + 3548;
   HEAP32[$0 + 6216 >> 2] = $0 + 3256;
   HEAP32[$0 + 6212 >> 2] = $0 + 2964;
   HEAP32[$0 + 6208 >> 2] = $0 + 2672;
   HEAP32[$0 + 6204 >> 2] = $0 + 2380;
   HEAP32[$0 + 6200 >> 2] = $0 + 2088;
   HEAP32[$0 + 6196 >> 2] = $0 + 1796;
   HEAP32[$0 + 6192 >> 2] = $0 + 1504;
   HEAP32[$0 + 6188 >> 2] = $0 + 1212;
   HEAP32[$0 + 6184 >> 2] = $0 + 920;
   HEAP32[$0 + 6180 >> 2] = $0 + 628;
   HEAP32[$0 + 6176 >> 2] = $0 + 336;
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($22);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($21);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($20);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($19);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($18);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($17);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($16);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($15);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($14);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($13);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($12);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($11);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($10);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($9);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($8);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($7);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($6);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($5);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($4);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($2);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($0 + 11724 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_init($0 + 11736 | 0);
   HEAP32[$1 >> 2] = 1;
   return $3 | 0;
  }
  emscripten_builtin_free($3);
  return 0;
 }
 
 function FLAC__stream_encoder_set_apodization($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = Math_fround(0), $6 = 0, $7 = 0.0, $8 = Math_fround(0), $9 = Math_fround(0), $10 = 0, $11 = 0;
  $2 = HEAP32[$0 >> 2];
  block : {
   if (HEAP32[$2 >> 2] != 1) {
    break block
   }
   HEAP32[$2 + 40 >> 2] = 0;
   while (1) {
    block5 : {
     block19 : {
      block20 : {
       block17 : {
        block16 : {
         block15 : {
          block14 : {
           block12 : {
            block13 : {
             block8 : {
              block7 : {
               block6 : {
                block10 : {
                 block4 : {
                  $10 = strchr($1, 59);
                  block2 : {
                   if ($10) {
                    $4 = $10 - $1 | 0;
                    break block2;
                   }
                   $4 = strlen($1);
                  }
                  $11 = ($4 | 0) != 8;
                  if (!$11) {
                   if (strncmp(5385, $1, 8)) {
                    break block4
                   }
                   HEAP32[$2 + 40 >> 2] = $3 + 1;
                   HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 0;
                   break block5;
                  }
                  block9 : {
                   switch ($4 - 6 | 0) {
                   case 20:
                    break block10;
                   case 0:
                    break block6;
                   case 1:
                    break block7;
                   case 7:
                    break block9;
                   default:
                    break block8;
                   };
                  }
                  $6 = 1;
                  if (strncmp(5812, $1, 13)) {
                   break block12
                  }
                  HEAP32[$2 + 40 >> 2] = $3 + 1;
                  HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 1;
                  break block5;
                 }
                 if (strncmp(5830, $1, 8)) {
                  break block13
                 }
                 HEAP32[$2 + 40 >> 2] = $3 + 1;
                 HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 2;
                 break block5;
                }
                if (strncmp(5904, $1, 26)) {
                 break block13
                }
                HEAP32[$2 + 40 >> 2] = $3 + 1;
                HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 3;
                break block5;
               }
               if (strncmp(5445, $1, 6)) {
                break block5
               }
               HEAP32[$2 + 40 >> 2] = $3 + 1;
               HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 4;
               break block5;
              }
              if (strncmp(5804, $1, 7)) {
               break block14
              }
              HEAP32[$2 + 40 >> 2] = $3 + 1;
              HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 5;
              break block5;
             }
             if ($4 >>> 0 < 8) {
              break block15
             }
            }
            $6 = 0;
           }
           if (strncmp(6510, $1, 6)) {
            break block16
           }
           $7 = strtod($1 + 6 | 0);
           $2 = HEAP32[$0 >> 2];
           $5 = Math_fround($7);
           if (!($5 > Math_fround(0.0)) | !($5 <= Math_fround(.5))) {
            break block5
           }
           HEAPF32[((HEAP32[$2 + 40 >> 2] << 4) + $2 | 0) + 48 >> 2] = $5;
           $2 = HEAP32[$0 >> 2];
           $1 = HEAP32[$2 + 40 >> 2];
           HEAP32[$2 + 40 >> 2] = $1 + 1;
           HEAP32[(($1 << 4) + $2 | 0) + 44 >> 2] = 6;
           break block5;
          }
          if (strncmp(5877, $1, 7)) {
           break block17
          }
          HEAP32[$2 + 40 >> 2] = $3 + 1;
          HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 7;
          break block5;
         }
         block18 : {
          switch ($4 - 4 | 0) {
          case 0:
           break block18;
          case 1:
           break block19;
          default:
           break block5;
          };
         }
         if (strncmp(5821, $1, 4)) {
          break block5
         }
         HEAP32[$2 + 40 >> 2] = $3 + 1;
         HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 8;
         break block5;
        }
        if (!$6) {
         break block20
        }
        if (strncmp(5847, $1, 13)) {
         break block20
        }
        HEAP32[$2 + 40 >> 2] = $3 + 1;
        HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 9;
        break block5;
       }
       if (strncmp(5839, $1, 7)) {
        break block5
       }
       HEAP32[$2 + 40 >> 2] = $3 + 1;
       HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 10;
       break block5;
      }
      block22 : {
       if (($4 | 0) == 9) {
        if (strncmp(5885, $1, 9)) {
         break block22
        }
        HEAP32[$2 + 40 >> 2] = $3 + 1;
        HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 11;
        break block5;
       }
       if ($11) {
        break block22
       }
       if (strncmp(5895, $1, 8)) {
        break block22
       }
       HEAP32[$2 + 40 >> 2] = $3 + 1;
       HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 12;
       break block5;
      }
      if (!strncmp(6503, $1, 6)) {
       $7 = strtod($1 + 6 | 0);
       $2 = HEAP32[$0 >> 2];
       $5 = Math_fround($7);
       if (!($5 >= Math_fround(0.0)) | !($5 <= Math_fround(1.0))) {
        break block5
       }
       HEAPF32[((HEAP32[$2 + 40 >> 2] << 4) + $2 | 0) + 48 >> 2] = $5;
       $2 = HEAP32[$0 >> 2];
       $1 = HEAP32[$2 + 40 >> 2];
       HEAP32[$2 + 40 >> 2] = $1 + 1;
       HEAP32[(($1 << 4) + $2 | 0) + 44 >> 2] = 13;
       break block5;
      }
      if ($4 >>> 0 < 16) {
       break block5
      }
      if (!strncmp(6495, $1, 14)) {
       $7 = strtod($1 + 14 | 0);
       $2 = strchr($1, 47);
       $5 = Math_fround(.10000000149011612);
       block26 : {
        if (!$2) {
         break block26
        }
        $4 = $2 + 1 | 0;
        $5 = Math_fround(.9900000095367432);
        if (!(Math_fround(strtod($4)) < Math_fround(.9900000095367432))) {
         break block26
        }
        $5 = Math_fround(strtod($4));
       }
       $4 = Math_abs($7) < 2147483647.0 ? ~~$7 : -2147483648;
       $1 = strchr($2 ? $2 + 1 | 0 : $1, 47);
       if ($1) {
        $8 = Math_fround(strtod($1 + 1 | 0))
       } else {
        $8 = Math_fround(.20000000298023224)
       }
       $2 = HEAP32[$0 >> 2];
       $3 = HEAP32[$2 + 40 >> 2];
       if (($4 | 0) <= 1) {
        HEAPF32[(($3 << 4) + $2 | 0) + 48 >> 2] = $8;
        $2 = HEAP32[$0 >> 2];
        $1 = HEAP32[$2 + 40 >> 2];
        HEAP32[$2 + 40 >> 2] = $1 + 1;
        HEAP32[(($1 << 4) + $2 | 0) + 44 >> 2] = 13;
        break block5;
       }
       if ($3 + $4 >>> 0 > 31) {
        break block5
       }
       $9 = Math_fround(Math_fround(Math_fround(1.0) / Math_fround(Math_fround(1.0) - $5)) + Math_fround(-1.0));
       $5 = Math_fround($9 + Math_fround($4 >>> 0));
       $1 = 0;
       while (1) {
        HEAPF32[(($3 << 4) + $2 | 0) + 48 >> 2] = $8;
        $2 = HEAP32[$0 >> 2];
        HEAPF32[((HEAP32[$2 + 40 >> 2] << 4) + $2 | 0) + 52 >> 2] = Math_fround($1 >>> 0) / $5;
        $2 = HEAP32[$0 >> 2];
        $1 = $1 + 1 | 0;
        HEAPF32[((HEAP32[$2 + 40 >> 2] << 4) + $2 | 0) + 56 >> 2] = Math_fround($9 + Math_fround($1 >>> 0)) / $5;
        $2 = HEAP32[$0 >> 2];
        $6 = HEAP32[$2 + 40 >> 2];
        $3 = $6 + 1 | 0;
        HEAP32[$2 + 40 >> 2] = $3;
        HEAP32[(($6 << 4) + $2 | 0) + 44 >> 2] = 14;
        if (($1 | 0) != ($4 | 0)) {
         continue
        }
        break;
       };
       break block5;
      }
      if (($4 | 0) == 16) {
       break block5
      }
      if (strncmp(6479, $1, 15)) {
       break block5
      }
      $7 = strtod($1 + 15 | 0);
      $8 = Math_fround(.20000000298023224);
      $2 = strchr($1, 47);
      $5 = Math_fround(.20000000298023224);
      block30 : {
       if (!$2) {
        break block30
       }
       $4 = $2 + 1 | 0;
       $5 = Math_fround(.9900000095367432);
       if (!(Math_fround(strtod($4)) < Math_fround(.9900000095367432))) {
        break block30
       }
       $5 = Math_fround(strtod($4));
      }
      $4 = Math_abs($7) < 2147483647.0 ? ~~$7 : -2147483648;
      $1 = strchr($2 ? $2 + 1 | 0 : $1, 47);
      if ($1) {
       $8 = Math_fround(strtod($1 + 1 | 0))
      }
      $2 = HEAP32[$0 >> 2];
      $3 = HEAP32[$2 + 40 >> 2];
      if (($4 | 0) <= 1) {
       HEAPF32[(($3 << 4) + $2 | 0) + 48 >> 2] = $8;
       $2 = HEAP32[$0 >> 2];
       $1 = HEAP32[$2 + 40 >> 2];
       HEAP32[$2 + 40 >> 2] = $1 + 1;
       HEAP32[(($1 << 4) + $2 | 0) + 44 >> 2] = 13;
       break block5;
      }
      if ($3 + $4 >>> 0 > 31) {
       break block5
      }
      $9 = Math_fround(Math_fround(Math_fround(1.0) / Math_fround(Math_fround(1.0) - $5)) + Math_fround(-1.0));
      $5 = Math_fround($9 + Math_fround($4 >>> 0));
      $1 = 0;
      while (1) {
       HEAPF32[(($3 << 4) + $2 | 0) + 48 >> 2] = $8;
       $2 = HEAP32[$0 >> 2];
       HEAPF32[((HEAP32[$2 + 40 >> 2] << 4) + $2 | 0) + 52 >> 2] = Math_fround($1 >>> 0) / $5;
       $2 = HEAP32[$0 >> 2];
       $1 = $1 + 1 | 0;
       HEAPF32[((HEAP32[$2 + 40 >> 2] << 4) + $2 | 0) + 56 >> 2] = Math_fround($9 + Math_fround($1 >>> 0)) / $5;
       $2 = HEAP32[$0 >> 2];
       $6 = HEAP32[$2 + 40 >> 2];
       $3 = $6 + 1 | 0;
       HEAP32[$2 + 40 >> 2] = $3;
       HEAP32[(($6 << 4) + $2 | 0) + 44 >> 2] = 15;
       if (($1 | 0) != ($4 | 0)) {
        continue
       }
       break;
      };
      break block5;
     }
     if (strncmp(5861, $1, 5)) {
      break block5
     }
     HEAP32[$2 + 40 >> 2] = $3 + 1;
     HEAP32[(($3 << 4) + $2 | 0) + 44 >> 2] = 16;
    }
    $3 = HEAP32[$2 + 40 >> 2];
    if ($10) {
     $1 = $10 + 1 | 0;
     if (($3 | 0) != 32) {
      continue
     }
    }
    break;
   };
   $4 = 1;
   if ($3) {
    break block
   }
   HEAP32[$2 + 48 >> 2] = 1056964608;
   HEAP32[$2 + 40 >> 2] = 1;
   HEAP32[$2 + 44 >> 2] = 13;
  }
  return $4;
 }
 
 function FLAC__stream_encoder_delete($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  if ($0) {
   HEAP32[HEAP32[$0 + 4 >> 2] + 11848 >> 2] = 1;
   FLAC__stream_encoder_finish($0);
   $1 = HEAP32[$0 + 4 >> 2];
   $2 = HEAP32[$1 + 11752 >> 2];
   if ($2) {
    FLAC__stream_decoder_delete($2);
    $1 = HEAP32[$0 + 4 >> 2];
   }
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear($1 + 6256 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6268 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6280 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6292 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6304 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6316 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6328 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6340 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6352 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6364 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6376 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6388 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6400 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6412 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6424 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6436 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6448 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6460 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6472 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 6484 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 11724 | 0);
   FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(HEAP32[$0 + 4 >> 2] + 11736 | 0);
   FLAC__bitreader_delete(HEAP32[HEAP32[$0 + 4 >> 2] + 6856 >> 2]);
   emscripten_builtin_free(HEAP32[$0 + 4 >> 2]);
   emscripten_builtin_free(HEAP32[$0 >> 2]);
   emscripten_builtin_free($0);
  }
 }
 
 function FLAC__stream_encoder_finish($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
  $9 = __stack_pointer - 16 | 0;
  __stack_pointer = $9;
  block1 : {
   if (!$0) {
    break block1
   }
   block3 : {
    block2 : {
     $4 = HEAP32[$0 >> 2];
     $1 = HEAP32[$4 >> 2];
     switch ($1 | 0) {
     case 1:
      break block1;
     case 0:
      break block2;
     default:
      break block3;
     };
    }
    $2 = HEAP32[$0 + 4 >> 2];
    if (HEAP32[$2 + 11848 >> 2]) {
     break block3
    }
    $2 = HEAP32[$2 + 7052 >> 2];
    if (!$2) {
     break block3
    }
    $3 = HEAP32[$4 + 36 >> 2];
    HEAP32[$4 + 36 >> 2] = $2;
    $3 = process_frame_($0, ($2 | 0) != ($3 | 0), 1) ^ 1;
    $4 = HEAP32[$0 >> 2];
   }
   if (HEAP32[$4 + 12 >> 2]) {
    $2 = HEAP32[$0 + 4 >> 2];
    FLAC__MD5Final($2 + 6928 | 0, $2 + 7060 | 0);
   }
   $1 = HEAP32[$0 + 4 >> 2];
   block6 : {
    if (HEAP32[$1 + 11848 >> 2]) {
     $2 = $3;
     break block6;
    }
    $4 = HEAP32[$0 >> 2];
    block7 : {
     if (HEAP32[$4 >> 2]) {
      break block7
     }
     $2 = HEAP32[$1 + 7268 >> 2];
     if ($2) {
      block10 : {
       if (HEAP32[$1 + 7260 >> 2]) {
        $7 = HEAP32[$1 + 6900 >> 2];
        $11 = HEAP32[$1 + 6896 >> 2];
        $4 = HEAP32[$1 + 6920 >> 2];
        $5 = HEAP32[$1 + 6924 >> 2];
        if ((FUNCTION_TABLE[$2 | 0]($0, 0, 0, HEAP32[$1 + 7288 >> 2]) | 0) == 2) {
         break block10
        }
        simple_ogg_page__init($9);
        $2 = HEAP32[$0 >> 2];
        $8 = HEAP32[$2 + 608 >> 2];
        $10 = HEAP32[$2 + 612 >> 2];
        $2 = HEAP32[$0 + 4 >> 2];
        block11 : {
         if (!simple_ogg_page__get_at($0, $8, $10, $9, HEAP32[$2 + 7268 >> 2], HEAP32[$2 + 7264 >> 2], HEAP32[$2 + 7288 >> 2])) {
          break block11
         }
         $12 = HEAP32[1634] + HEAP32[1633] | 0;
         $14 = HEAP32[1639] + (HEAP32[1638] + (HEAP32[1637] + (HEAP32[1636] + ($12 + HEAP32[1635] | 0) | 0) | 0) | 0) | 0;
         $2 = $14 + HEAP32[1640] >>> 3 | 0;
         if (HEAPU32[$9 + 12 >> 2] < $2 + 33 >>> 0) {
          HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
          simple_ogg_page__clear($9);
          break block10;
         }
         $6 = HEAPU8[$1 + 6932 | 0] | HEAPU8[$1 + 6933 | 0] << 8 | (HEAPU8[$1 + 6934 | 0] << 16 | HEAPU8[$1 + 6935 | 0] << 24);
         $2 = $2 + HEAP32[$9 + 8 >> 2] | 0;
         $8 = HEAPU8[$1 + 6928 | 0] | HEAPU8[$1 + 6929 | 0] << 8 | (HEAPU8[$1 + 6930 | 0] << 16 | HEAPU8[$1 + 6931 | 0] << 24);
         HEAP8[$2 + 17 | 0] = $8;
         HEAP8[$2 + 18 | 0] = $8 >>> 8;
         HEAP8[$2 + 19 | 0] = $8 >>> 16;
         HEAP8[$2 + 20 | 0] = $8 >>> 24;
         HEAP8[$2 + 21 | 0] = $6;
         HEAP8[$2 + 22 | 0] = $6 >>> 8;
         HEAP8[$2 + 23 | 0] = $6 >>> 16;
         HEAP8[$2 + 24 | 0] = $6 >>> 24;
         $1 = $1 + 6936 | 0;
         $6 = HEAPU8[$1 + 4 | 0] | HEAPU8[$1 + 5 | 0] << 8 | (HEAPU8[$1 + 6 | 0] << 16 | HEAPU8[$1 + 7 | 0] << 24);
         $2 = $2 + 25 | 0;
         $1 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
         HEAP8[$2 | 0] = $1;
         HEAP8[$2 + 1 | 0] = $1 >>> 8;
         HEAP8[$2 + 2 | 0] = $1 >>> 16;
         HEAP8[$2 + 3 | 0] = $1 >>> 24;
         HEAP8[$2 + 4 | 0] = $6;
         HEAP8[$2 + 5 | 0] = $6 >>> 8;
         HEAP8[$2 + 6 | 0] = $6 >>> 16;
         HEAP8[$2 + 7 | 0] = $6 >>> 24;
         $2 = $14 - 4 >>> 3 | 0;
         if (HEAPU32[$9 + 12 >> 2] < $2 + 22 >>> 0) {
          HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
          simple_ogg_page__clear($9);
          break block10;
         }
         $2 = $2 + HEAP32[$9 + 8 >> 2] | 0;
         HEAP8[$2 + 21 | 0] = $4;
         HEAP8[$2 + 20 | 0] = ($5 & 255) << 24 | $4 >>> 8;
         HEAP8[$2 + 19 | 0] = ($5 & 65535) << 16 | $4 >>> 16;
         HEAP8[$2 + 18 | 0] = ($5 & 16777215) << 8 | $4 >>> 24;
         HEAP8[$2 + 17 | 0] = HEAPU8[$2 + 17 | 0] & 240 | $5 & 15;
         $2 = $12 >>> 3 | 0;
         if (HEAPU32[$9 + 12 >> 2] < $2 + 23 >>> 0) {
          HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
          simple_ogg_page__clear($9);
          break block10;
         }
         $2 = $2 + HEAP32[$9 + 8 >> 2] | 0;
         HEAP8[$2 + 22 | 0] = $7;
         HEAP8[$2 + 21 | 0] = $7 >>> 8;
         HEAP8[$2 + 20 | 0] = $7 >>> 16;
         HEAP8[$2 + 19 | 0] = $11;
         HEAP8[$2 + 18 | 0] = $11 >>> 8;
         HEAP8[$2 + 17 | 0] = $11 >>> 16;
         $2 = HEAP32[$0 >> 2];
         $1 = HEAP32[$2 + 608 >> 2];
         $4 = HEAP32[$2 + 612 >> 2];
         $2 = HEAP32[$0 + 4 >> 2];
         $2 = simple_ogg_page__set_at($0, $1, $4, $9, HEAP32[$2 + 7268 >> 2], HEAP32[$2 + 7276 >> 2], HEAP32[$2 + 7288 >> 2]);
         simple_ogg_page__clear($9);
         if (!$2) {
          break block10
         }
         $2 = HEAP32[HEAP32[$0 + 4 >> 2] + 7048 >> 2];
         if (!$2 | !HEAP32[$2 >> 2]) {
          break block10
         }
         $1 = HEAP32[$0 >> 2];
         if (!(HEAP32[$1 + 616 >> 2] | HEAP32[$1 + 620 >> 2])) {
          break block10
         }
         FLAC__format_seektable_sort($2);
         simple_ogg_page__init($9);
         $2 = HEAP32[$0 >> 2];
         $1 = HEAP32[$2 + 616 >> 2];
         $4 = HEAP32[$2 + 620 >> 2];
         $2 = HEAP32[$0 + 4 >> 2];
         if (!simple_ogg_page__get_at($0, $1, $4, $9, HEAP32[$2 + 7268 >> 2], HEAP32[$2 + 7264 >> 2], HEAP32[$2 + 7288 >> 2])) {
          break block11
         }
         $2 = HEAP32[$0 + 4 >> 2];
         $5 = HEAP32[$2 + 7048 >> 2];
         $1 = HEAP32[$5 >> 2];
         if (HEAP32[$9 + 12 >> 2] != (Math_imul($1, 18) + 4 | 0)) {
          HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
          simple_ogg_page__clear($9);
          break block10;
         }
         if ($1) {
          $1 = HEAP32[$9 + 8 >> 2] + 4 | 0;
          $4 = 0;
          while (1) {
           $6 = HEAP32[$5 + 4 >> 2] + Math_imul($4, 24) | 0;
           $7 = HEAP32[$6 >> 2];
           $2 = HEAP32[$6 + 4 >> 2];
           $11 = HEAP32[$6 + 8 >> 2];
           $5 = HEAP32[$6 + 12 >> 2];
           $6 = HEAP32[$6 + 16 >> 2];
           HEAP8[$1 + 17 | 0] = $6;
           HEAP8[$1 + 15 | 0] = $11;
           HEAP8[$1 + 7 | 0] = $7;
           HEAP8[$1 + 16 | 0] = $6 >>> 8;
           HEAP8[$1 + 14 | 0] = ($5 & 255) << 24 | $11 >>> 8;
           HEAP8[$1 + 13 | 0] = ($5 & 65535) << 16 | $11 >>> 16;
           HEAP8[$1 + 12 | 0] = ($5 & 16777215) << 8 | $11 >>> 24;
           HEAP8[$1 + 11 | 0] = $5;
           HEAP8[$1 + 10 | 0] = $5 >>> 8;
           HEAP8[$1 + 9 | 0] = $5 >>> 16;
           HEAP8[$1 + 8 | 0] = $5 >>> 24;
           HEAP8[$1 + 6 | 0] = ($2 & 255) << 24 | $7 >>> 8;
           HEAP8[$1 + 5 | 0] = ($2 & 65535) << 16 | $7 >>> 16;
           HEAP8[$1 + 4 | 0] = ($2 & 16777215) << 8 | $7 >>> 24;
           HEAP8[$1 + 3 | 0] = $2;
           HEAP8[$1 + 2 | 0] = $2 >>> 8;
           HEAP8[$1 + 1 | 0] = $2 >>> 16;
           HEAP8[$1 | 0] = $2 >>> 24;
           $1 = $1 + 18 | 0;
           $4 = $4 + 1 | 0;
           $2 = HEAP32[$0 + 4 >> 2];
           $5 = HEAP32[$2 + 7048 >> 2];
           if ($4 >>> 0 < HEAPU32[$5 >> 2]) {
            continue
           }
           break;
          };
         }
         $1 = HEAP32[$0 >> 2];
         simple_ogg_page__set_at($0, HEAP32[$1 + 616 >> 2], HEAP32[$1 + 620 >> 2], $9, HEAP32[$2 + 7268 >> 2], HEAP32[$2 + 7276 >> 2], HEAP32[$2 + 7288 >> 2]);
        }
        simple_ogg_page__clear($9);
        break block10;
       }
       $2 = __stack_pointer - 32 | 0;
       __stack_pointer = $2;
       $1 = HEAP32[$0 + 4 >> 2];
       $11 = HEAP32[$1 + 6912 >> 2];
       $6 = HEAP32[$1 + 6900 >> 2];
       $7 = HEAP32[$1 + 6896 >> 2];
       $4 = HEAP32[$1 + 6920 >> 2];
       $5 = HEAP32[$1 + 6924 >> 2];
       $8 = HEAP32[$0 >> 2];
       $12 = HEAP32[$8 + 608 >> 2];
       $8 = HEAP32[$8 + 612 >> 2];
       $15 = $8 + 1 | 0;
       $10 = $8;
       $8 = HEAP32[1634] + HEAP32[1633] | 0;
       $14 = HEAP32[1639] + (HEAP32[1638] + (HEAP32[1637] + (HEAP32[1636] + ($8 + HEAP32[1635] | 0) | 0) | 0) | 0) | 0;
       $13 = ($14 + HEAP32[1640] >>> 3 | 0) + 4 | 0;
       $12 = $12 + $13 | 0;
       $13 = $13 >>> 0 > $12 >>> 0 ? $15 : $10;
       block20 : {
        block12 : {
         block : {
          switch (FUNCTION_TABLE[HEAP32[$1 + 7268 >> 2]]($0, $12, $13, HEAP32[$1 + 7288 >> 2]) | 0) {
          case 0:
           break block;
          case 1:
           break block12;
          default:
           break block20;
          };
         }
         $10 = $1 + 6928 | 0;
         $1 = HEAP32[$0 + 4 >> 2];
         if (FUNCTION_TABLE[HEAP32[$1 + 7276 >> 2]]($0, $10, 16, 0, 0, HEAP32[$1 + 7288 >> 2]) | 0) {
          break block12
         }
         HEAP8[$2 + 4 | 0] = $4;
         HEAP8[$2 + 3 | 0] = ($5 & 255) << 24 | $4 >>> 8;
         HEAP8[$2 + 2 | 0] = ($5 & 65535) << 16 | $4 >>> 16;
         HEAP8[$2 + 1 | 0] = ($5 & 16777215) << 8 | $4 >>> 24;
         HEAP8[$2 | 0] = ($5 & 15 | $11 << 4) + 240;
         $1 = HEAP32[$0 >> 2];
         $4 = HEAP32[$1 + 608 >> 2];
         $1 = HEAP32[$1 + 612 >> 2];
         $11 = $1 + 1 | 0;
         $10 = $1;
         $1 = ($14 - 4 >>> 3 | 0) + 4 | 0;
         $5 = $1;
         $1 = $1 + $4 | 0;
         $4 = $5 >>> 0 > $1 >>> 0 ? $11 : $10;
         block33 : {
          $10 = $1;
          $1 = HEAP32[$0 + 4 >> 2];
          switch (FUNCTION_TABLE[HEAP32[$1 + 7268 >> 2]]($0, $10, $4, HEAP32[$1 + 7288 >> 2]) | 0) {
          case 1:
           break block12;
          case 0:
           break block33;
          default:
           break block20;
          };
         }
         $1 = HEAP32[$0 + 4 >> 2];
         if (FUNCTION_TABLE[HEAP32[$1 + 7276 >> 2]]($0, $2, 5, 0, 0, HEAP32[$1 + 7288 >> 2]) | 0) {
          break block12
         }
         HEAP8[$2 + 5 | 0] = $6;
         HEAP8[$2 + 4 | 0] = $6 >>> 8;
         HEAP8[$2 + 3 | 0] = $6 >>> 16;
         HEAP8[$2 + 2 | 0] = $7;
         HEAP8[$2 + 1 | 0] = $7 >>> 8;
         HEAP8[$2 | 0] = $7 >>> 16;
         $1 = HEAP32[$0 >> 2];
         $4 = HEAP32[$1 + 608 >> 2];
         $1 = HEAP32[$1 + 612 >> 2];
         $5 = $1 + 1 | 0;
         $10 = $1;
         $1 = ($8 >>> 3 | 0) + 4 | 0;
         $8 = $1;
         $1 = $1 + $4 | 0;
         $4 = $8 >>> 0 > $1 >>> 0 ? $5 : $10;
         block4 : {
          $8 = $1;
          $1 = HEAP32[$0 + 4 >> 2];
          switch (FUNCTION_TABLE[HEAP32[$1 + 7268 >> 2]]($0, $8, $4, HEAP32[$1 + 7288 >> 2]) | 0) {
          case 1:
           break block12;
          case 0:
           break block4;
          default:
           break block20;
          };
         }
         $1 = HEAP32[$0 + 4 >> 2];
         if (FUNCTION_TABLE[HEAP32[$1 + 7276 >> 2]]($0, $2, 6, 0, 0, HEAP32[$1 + 7288 >> 2]) | 0) {
          break block12
         }
         $1 = HEAP32[HEAP32[$0 + 4 >> 2] + 7048 >> 2];
         if (!$1 | !HEAP32[$1 >> 2]) {
          break block20
         }
         $4 = HEAP32[$0 >> 2];
         if (!(HEAP32[$4 + 616 >> 2] | HEAP32[$4 + 620 >> 2])) {
          break block20
         }
         FLAC__format_seektable_sort($1);
         $1 = HEAP32[$0 >> 2];
         $4 = HEAP32[$1 + 616 >> 2];
         $1 = HEAP32[$1 + 620 >> 2];
         $10 = $1 + 1 | 0;
         $8 = $1;
         $1 = $4 + 4 | 0;
         $4 = $1 >>> 0 < 4 ? $10 : $8;
         block5 : {
          $8 = $1;
          $1 = HEAP32[$0 + 4 >> 2];
          switch (FUNCTION_TABLE[HEAP32[$1 + 7268 >> 2]]($0, $8, $4, HEAP32[$1 + 7288 >> 2]) | 0) {
          case 1:
           break block12;
          case 0:
           break block5;
          default:
           break block20;
          };
         }
         $5 = HEAP32[$0 + 4 >> 2];
         $4 = HEAP32[$5 + 7048 >> 2];
         if (!HEAP32[$4 >> 2]) {
          break block20
         }
         $6 = 0;
         while (1) {
          $11 = Math_imul($6, 24);
          $7 = $11 + HEAP32[$4 + 4 >> 2] | 0;
          $1 = HEAP32[$7 >> 2];
          $8 = $1 << 24 | ($1 & 65280) << 8;
          $12 = $1 & 16711680;
          $14 = $12 >>> 8 | 0;
          $13 = $1 & -16777216;
          $10 = $13 >>> 24 | 0;
          $7 = HEAP32[$7 + 4 >> 2];
          HEAP32[$2 >> 2] = $13 << 8 | $12 << 24 | ((($7 & 255) << 24 | $1 >>> 8) & -16777216 | (($7 & 16777215) << 8 | $1 >>> 24) & 16711680 | ($7 >>> 8 & 65280 | $7 >>> 24));
          HEAP32[$2 + 4 >> 2] = $8 | ($14 | $10);
          $7 = $11 + HEAP32[$4 + 4 >> 2] | 0;
          $1 = HEAP32[$7 + 8 >> 2];
          $8 = $1 << 24 | ($1 & 65280) << 8;
          $12 = $1 & 16711680;
          $14 = $12 >>> 8 | 0;
          $13 = $1 & -16777216;
          $10 = $13 >>> 24 | 0;
          $7 = HEAP32[$7 + 12 >> 2];
          HEAP32[$2 + 8 >> 2] = $13 << 8 | $12 << 24 | ((($7 & 255) << 24 | $1 >>> 8) & -16777216 | (($7 & 16777215) << 8 | $1 >>> 24) & 16711680 | ($7 >>> 8 & 65280 | $7 >>> 24));
          HEAP32[$2 + 12 >> 2] = $8 | ($14 | $10);
          $1 = HEAPU16[($11 + HEAP32[$4 + 4 >> 2] | 0) + 16 >> 1];
          HEAP16[$2 + 16 >> 1] = $1 << 8 | $1 >>> 8;
          if (FUNCTION_TABLE[HEAP32[$5 + 7276 >> 2]]($0, $2, 18, 0, 0, HEAP32[$5 + 7288 >> 2]) | 0) {
           break block12
          }
          $6 = $6 + 1 | 0;
          $5 = HEAP32[$0 + 4 >> 2];
          $4 = HEAP32[$5 + 7048 >> 2];
          if ($6 >>> 0 < HEAPU32[$4 >> 2]) {
           continue
          }
          break;
         };
         break block20;
        }
        HEAP32[HEAP32[$0 >> 2] >> 2] = 5;
       }
       __stack_pointer = $2 + 32 | 0;
      }
      $1 = HEAP32[$0 + 4 >> 2];
      $4 = HEAP32[$0 >> 2];
      $3 = HEAP32[$4 >> 2] ? 1 : $3;
     }
     $2 = HEAP32[$1 + 7280 >> 2];
     if (!$2) {
      break block7
     }
     FUNCTION_TABLE[$2 | 0]($0, $1 + 6872 | 0, HEAP32[$1 + 7288 >> 2]);
     $4 = HEAP32[$0 >> 2];
    }
    if (!HEAP32[$4 + 4 >> 2]) {
     $2 = $3;
     break block6;
    }
    $2 = HEAP32[HEAP32[$0 + 4 >> 2] + 11752 >> 2];
    if (!$2) {
     $2 = $3;
     break block6;
    }
    if (FLAC__stream_decoder_finish($2)) {
     $2 = $3;
     break block6;
    }
    $2 = 1;
    if ($3) {
     break block6
    }
    HEAP32[HEAP32[$0 >> 2] >> 2] = 4;
   }
   $1 = HEAP32[$0 + 4 >> 2];
   $3 = HEAP32[$1 + 7296 >> 2];
   if ($3) {
    if (HEAP32[3025] != ($3 | 0)) {
     fclose($3);
     $1 = HEAP32[$0 + 4 >> 2];
    }
    HEAP32[$1 + 7296 >> 2] = 0;
   }
   $4 = HEAP32[$0 >> 2];
   if (HEAP32[$1 + 7260 >> 2]) {
    ogg_stream_clear($4 + 640 | 0);
    $4 = HEAP32[$0 >> 2];
   }
   $3 = HEAP32[$4 + 600 >> 2];
   if ($3) {
    emscripten_builtin_free($3);
    $4 = HEAP32[$0 >> 2];
    $3 = $4;
    HEAP32[$3 + 600 >> 2] = 0;
    HEAP32[$3 + 604 >> 2] = 0;
   }
   $1 = HEAP32[$0 + 4 >> 2];
   if (HEAP32[$4 + 24 >> 2]) {
    $3 = 0;
    while (1) {
     $4 = $3 << 2;
     $5 = HEAP32[($4 + $1 | 0) + 7328 >> 2];
     if ($5) {
      emscripten_builtin_free($5);
      $1 = HEAP32[$0 + 4 >> 2];
      HEAP32[($4 + $1 | 0) + 7328 >> 2] = 0;
     }
     $5 = HEAP32[($1 + $4 | 0) + 7368 >> 2];
     if ($5) {
      emscripten_builtin_free($5);
      $1 = HEAP32[$0 + 4 >> 2];
      HEAP32[($4 + $1 | 0) + 7368 >> 2] = 0;
     }
     $3 = $3 + 1 | 0;
     if ($3 >>> 0 < HEAPU32[HEAP32[$0 >> 2] + 24 >> 2]) {
      continue
     }
     break;
    };
   }
   $3 = HEAP32[$1 + 7360 >> 2];
   if ($3) {
    emscripten_builtin_free($3);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 7360 >> 2] = 0;
   }
   $3 = HEAP32[$1 + 7400 >> 2];
   if ($3) {
    emscripten_builtin_free($3);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 7400 >> 2] = 0;
   }
   $3 = HEAP32[$1 + 7364 >> 2];
   if ($3) {
    emscripten_builtin_free($3);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 7364 >> 2] = 0;
   }
   $3 = HEAP32[$1 + 7404 >> 2];
   if ($3) {
    emscripten_builtin_free($3);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 7404 >> 2] = 0;
   }
   $3 = HEAP32[$0 >> 2];
   if (HEAP32[$3 + 40 >> 2]) {
    $4 = 0;
    while (1) {
     $5 = $4 << 2;
     $6 = HEAP32[($5 + $1 | 0) + 7408 >> 2];
     if ($6) {
      emscripten_builtin_free($6);
      $1 = HEAP32[$0 + 4 >> 2];
      HEAP32[($5 + $1 | 0) + 7408 >> 2] = 0;
      $3 = HEAP32[$0 >> 2];
     }
     $4 = $4 + 1 | 0;
     if ($4 >>> 0 < HEAPU32[$3 + 40 >> 2]) {
      continue
     }
     break;
    };
   }
   $4 = HEAP32[$1 + 7536 >> 2];
   if ($4) {
    emscripten_builtin_free($4);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 7536 >> 2] = 0;
    $3 = HEAP32[$0 >> 2];
   }
   if (HEAP32[$3 + 24 >> 2]) {
    $3 = 0;
    while (1) {
     $4 = $3 << 3;
     $5 = HEAP32[($4 + $1 | 0) + 7540 >> 2];
     if ($5) {
      emscripten_builtin_free($5);
      $1 = HEAP32[$0 + 4 >> 2];
      HEAP32[($4 + $1 | 0) + 7540 >> 2] = 0;
     }
     $5 = HEAP32[($1 + $4 | 0) + 7544 >> 2];
     if ($5) {
      emscripten_builtin_free($5);
      $1 = HEAP32[$0 + 4 >> 2];
      HEAP32[($4 + $1 | 0) + 7544 >> 2] = 0;
     }
     $3 = $3 + 1 | 0;
     if ($3 >>> 0 < HEAPU32[HEAP32[$0 >> 2] + 24 >> 2]) {
      continue
     }
     break;
    };
   }
   $3 = HEAP32[$1 + 7604 >> 2];
   if ($3) {
    emscripten_builtin_free($3);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 7604 >> 2] = 0;
   }
   $3 = HEAP32[$1 + 7608 >> 2];
   if ($3) {
    emscripten_builtin_free($3);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 7608 >> 2] = 0;
   }
   $3 = HEAP32[$1 + 7612 >> 2];
   if ($3) {
    emscripten_builtin_free($3);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 7612 >> 2] = 0;
   }
   $3 = HEAP32[$1 + 7616 >> 2];
   if ($3) {
    emscripten_builtin_free($3);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 7616 >> 2] = 0;
   }
   $3 = HEAP32[$1 + 7620 >> 2];
   if ($3) {
    emscripten_builtin_free($3);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 7620 >> 2] = 0;
   }
   $3 = HEAP32[$1 + 7624 >> 2];
   if ($3) {
    emscripten_builtin_free($3);
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 7624 >> 2] = 0;
   }
   $3 = HEAP32[$0 >> 2];
   if (!(!HEAP32[$3 + 4 >> 2] | !HEAP32[$3 + 24 >> 2])) {
    $4 = 0;
    while (1) {
     $5 = $4 << 2;
     $6 = HEAP32[($5 + $1 | 0) + 11764 >> 2];
     if ($6) {
      emscripten_builtin_free($6);
      $1 = HEAP32[$0 + 4 >> 2];
      HEAP32[($5 + $1 | 0) + 11764 >> 2] = 0;
      $3 = HEAP32[$0 >> 2];
     }
     $4 = $4 + 1 | 0;
     if ($4 >>> 0 < HEAPU32[$3 + 24 >> 2]) {
      continue
     }
     break;
    };
   }
   $3 = HEAP32[$1 + 6856 >> 2];
   $1 = HEAP32[$3 >> 2];
   if ($1) {
    emscripten_builtin_free($1)
   }
   HEAP32[$3 + 16 >> 2] = 0;
   HEAP32[$3 >> 2] = 0;
   HEAP32[$3 + 8 >> 2] = 0;
   HEAP32[$3 + 12 >> 2] = 0;
   $3 = HEAP32[$0 >> 2];
   HEAP32[$3 + 44 >> 2] = 13;
   HEAP32[$3 + 48 >> 2] = 1056964608;
   HEAP32[$3 + 36 >> 2] = 0;
   HEAP32[$3 + 40 >> 2] = 1;
   HEAP32[$3 + 28 >> 2] = 16;
   HEAP32[$3 + 32 >> 2] = 44100;
   HEAP32[$3 + 20 >> 2] = 0;
   HEAP32[$3 + 24 >> 2] = 2;
   HEAP32[$3 + 12 >> 2] = 1;
   HEAP32[$3 + 16 >> 2] = 0;
   HEAP32[$3 + 4 >> 2] = 0;
   HEAP32[$3 + 8 >> 2] = 1;
   $3 = HEAP32[$0 >> 2];
   HEAP32[$3 + 556 >> 2] = 0;
   HEAP32[$3 + 560 >> 2] = 0;
   HEAP32[$3 + 592 >> 2] = 0;
   HEAP32[$3 + 596 >> 2] = 0;
   $1 = $3 + 580 | 0;
   HEAP32[$1 >> 2] = 0;
   HEAP32[$1 + 4 >> 2] = 0;
   $1 = $3 + 572 | 0;
   HEAP32[$1 >> 2] = 0;
   HEAP32[$1 + 4 >> 2] = 0;
   $1 = $3 + 564 | 0;
   HEAP32[$1 >> 2] = 0;
   HEAP32[$1 + 4 >> 2] = 0;
   $1 = $3 + 600 | 0;
   HEAP32[$1 >> 2] = 0;
   HEAP32[$1 + 4 >> 2] = 0;
   $1 = HEAP32[$0 + 4 >> 2];
   HEAP32[$1 + 7248 >> 2] = 0;
   HEAP32[$1 + 7252 >> 2] = 0;
   HEAP32[$1 + 7048 >> 2] = 0;
   $4 = $1 + 7256 | 0;
   HEAP32[$4 >> 2] = 0;
   HEAP32[$4 + 4 >> 2] = 0;
   $4 = $1 + 7264 | 0;
   HEAP32[$4 >> 2] = 0;
   HEAP32[$4 + 4 >> 2] = 0;
   $4 = $1 + 7272 | 0;
   HEAP32[$4 >> 2] = 0;
   HEAP32[$4 + 4 >> 2] = 0;
   $4 = $1 + 7280 | 0;
   HEAP32[$4 >> 2] = 0;
   HEAP32[$4 + 4 >> 2] = 0;
   HEAP32[$1 + 7288 >> 2] = 0;
   FLAC__ogg_encoder_aspect_set_defaults($3 + 632 | 0);
   $1 = HEAP32[$0 >> 2];
   block45 : {
    if (HEAP32[$1 >> 2] != 1) {
     break block45
    }
    HEAP32[$1 + 16 >> 2] = 1;
    HEAP32[$1 + 20 >> 2] = 0;
    FLAC__stream_encoder_set_apodization($0, 6467);
    $1 = HEAP32[$0 >> 2];
    if (HEAP32[$1 >> 2] != 1) {
     break block45
    }
    HEAP32[$1 + 576 >> 2] = 0;
    HEAP32[$1 + 580 >> 2] = 5;
    HEAP32[$1 + 564 >> 2] = 0;
    HEAP32[$1 + 568 >> 2] = 0;
    HEAP32[$1 + 556 >> 2] = 8;
    HEAP32[$1 + 560 >> 2] = 0;
   }
   if (!$2) {
    HEAP32[$1 >> 2] = 1
   }
   $1 = !$2;
  }
  __stack_pointer = $9 + 16 | 0;
  return $1 | 0;
 }
 
 function process_frame_($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0;
  $10 = __stack_pointer - 48 | 0;
  __stack_pointer = $10;
  block1 : {
   block : {
    $9 = HEAP32[$0 >> 2];
    if (!HEAP32[$9 + 12 >> 2]) {
     break block
    }
    $3 = HEAP32[$0 + 4 >> 2];
    $3 = FLAC__MD5Accumulate($3 + 7060 | 0, $3 + 4 | 0, HEAP32[$9 + 24 >> 2], HEAP32[$9 + 36 >> 2], HEAP32[$9 + 28 >> 2] + 7 >>> 3 | 0);
    $9 = HEAP32[$0 >> 2];
    if ($3) {
     break block
    }
    HEAP32[$9 >> 2] = 8;
    break block1;
   }
   $6 = HEAP32[$9 + 576 >> 2];
   if ($1) {
    $14 = 0
   } else {
    $1 = 0;
    $3 = HEAP32[$9 + 36 >> 2];
    if (!($3 & 1)) {
     while (1) {
      $1 = $1 + 1 | 0;
      $4 = $3 & 2;
      $3 = $3 >>> 1 | 0;
      if (!$4) {
       continue
      }
      break;
     }
    }
    $1 = $1 >>> 0 >= 15 ? 15 : $1;
    $9 = HEAP32[$0 >> 2];
    $3 = HEAP32[$9 + 580 >> 2];
    $14 = $1 >>> 0 < $3 >>> 0 ? $1 : $3;
   }
   $4 = HEAP32[$9 + 36 >> 2];
   HEAP32[$10 + 8 >> 2] = $4;
   HEAP32[$10 + 12 >> 2] = HEAP32[$9 + 32 >> 2];
   $1 = HEAP32[$9 + 24 >> 2];
   HEAP32[$10 + 20 >> 2] = 0;
   HEAP32[$10 + 16 >> 2] = $1;
   $3 = HEAP32[$9 + 28 >> 2];
   HEAP32[$10 + 28 >> 2] = 0;
   HEAP32[$10 + 24 >> 2] = $3;
   $8 = HEAP32[$0 + 4 >> 2];
   HEAP32[$10 + 32 >> 2] = HEAP32[$8 + 7056 >> 2];
   $18 = $6 >>> 0 < $14 >>> 0 ? $6 : $14;
   block29 : {
    block40 : {
     block38 : {
      block37 : {
       block36 : {
        block34 : {
         block25 : {
          block23 : {
           block13 : {
            block6 : {
             block5 : {
              if (!HEAP32[$9 + 16 >> 2]) {
               $7 = 1;
               break block5;
              }
              if (!HEAP32[$9 + 20 >> 2] | !HEAP32[$8 + 6864 >> 2]) {
               break block5
              }
              $7 = 1;
              $3 = $7;
              if (HEAP32[$8 + 6868 >> 2]) {
               break block6
              }
             }
             if ($1) {
              $13 = $8 + 216 | 0;
              $19 = $8 + 624 | 0;
              $20 = $8 + 916 | 0;
              $21 = $8 + 4 | 0;
              $3 = 0;
              while (1) {
               $15 = $3 << 2;
               $4 = 0;
               $6 = HEAP32[$9 + 36 >> 2];
               block8 : {
                if (!$6) {
                 break block8
                }
                $16 = HEAP32[$15 + $21 >> 2];
                $5 = 0;
                $1 = 0;
                while (1) {
                 block9 : {
                  $5 = HEAP32[$16 + ($1 << 2) >> 2] | $5;
                  $11 = $5 & 1;
                  $1 = $1 + 1 | 0;
                  if ($6 >>> 0 <= $1 >>> 0) {
                   break block9
                  }
                  if (!$11) {
                   continue
                  }
                 }
                 break;
                };
                if (!$5) {
                 break block8
                }
                $1 = 0;
                if ($11) {
                 break block8
                }
                while (1) {
                 $1 = $1 + 1 | 0;
                 $11 = $5 & 2;
                 $5 = $5 >> 1;
                 if (!$11) {
                  continue
                 }
                 break;
                };
                if (!$1) {
                 break block8
                }
                $5 = 0;
                if ($6 >>> 0 >= 4) {
                 $22 = $6 & -4;
                 $11 = 0;
                 while (1) {
                  $12 = $16 + ($5 << 2) | 0;
                  HEAP32[$12 >> 2] = HEAP32[$12 >> 2] >> $1;
                  $17 = $12 + 4 | 0;
                  HEAP32[$17 >> 2] = HEAP32[$17 >> 2] >> $1;
                  $17 = $12 + 8 | 0;
                  HEAP32[$17 >> 2] = HEAP32[$17 >> 2] >> $1;
                  $12 = $12 + 12 | 0;
                  HEAP32[$12 >> 2] = HEAP32[$12 >> 2] >> $1;
                  $5 = $5 + 4 | 0;
                  $11 = $11 + 4 | 0;
                  if (($22 | 0) != ($11 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                $6 = $6 & 3;
                if ($6) {
                 while (1) {
                  $11 = $16 + ($5 << 2) | 0;
                  HEAP32[$11 >> 2] = HEAP32[$11 >> 2] >> $1;
                  $5 = $5 + 1 | 0;
                  $4 = $4 + 1 | 0;
                  if (($6 | 0) != ($4 | 0)) {
                   continue
                  }
                  break;
                 }
                }
                $4 = $1;
               }
               $6 = Math_imul($3, 584);
               $1 = HEAP32[$9 + 28 >> 2];
               $4 = $1 >>> 0 > $4 >>> 0 ? $4 : $1;
               HEAP32[$6 + $20 >> 2] = $4;
               HEAP32[$6 + $19 >> 2] = $4;
               HEAP32[$13 + $15 >> 2] = $1 - $4;
               $3 = $3 + 1 | 0;
               if ($3 >>> 0 < HEAPU32[$9 + 24 >> 2]) {
                continue
               }
               break;
              };
             }
             $4 = 1;
             if ($7) {
              break block13
             }
             $4 = HEAP32[$9 + 36 >> 2];
             $3 = 0;
            }
            $16 = $3;
            $11 = HEAP32[$8 + 36 >> 2];
            $5 = 0;
            $3 = 0;
            block14 : {
             if (!$4) {
              break block14
             }
             $1 = 0;
             $6 = 0;
             while (1) {
              block15 : {
               $1 = HEAP32[($6 << 2) + $11 >> 2] | $1;
               $7 = $1 & 1;
               $6 = $6 + 1 | 0;
               if ($4 >>> 0 <= $6 >>> 0) {
                break block15
               }
               if (!$7) {
                continue
               }
              }
              break;
             };
             if ($7 | !$1) {
              break block14
             }
             $6 = 0;
             while (1) {
              $6 = $6 + 1 | 0;
              $7 = $1 & 2;
              $1 = $1 >> 1;
              if (!$7) {
               continue
              }
              break;
             };
             if (!$6) {
              break block14
             }
             $12 = $4 & 3;
             $1 = 0;
             if ($4 >>> 0 >= 4) {
              $15 = $4 & -4;
              $4 = 0;
              while (1) {
               $7 = ($1 << 2) + $11 | 0;
               HEAP32[$7 >> 2] = HEAP32[$7 >> 2] >> $6;
               $13 = $7 + 4 | 0;
               HEAP32[$13 >> 2] = HEAP32[$13 >> 2] >> $6;
               $13 = $7 + 8 | 0;
               HEAP32[$13 >> 2] = HEAP32[$13 >> 2] >> $6;
               $7 = $7 + 12 | 0;
               HEAP32[$7 >> 2] = HEAP32[$7 >> 2] >> $6;
               $1 = $1 + 4 | 0;
               $4 = $4 + 4 | 0;
               if (($15 | 0) != ($4 | 0)) {
                continue
               }
               break;
              };
             }
             if ($12) {
              while (1) {
               $4 = ($1 << 2) + $11 | 0;
               HEAP32[$4 >> 2] = HEAP32[$4 >> 2] >> $6;
               $1 = $1 + 1 | 0;
               $3 = $3 + 1 | 0;
               if (($12 | 0) != ($3 | 0)) {
                continue
               }
               break;
              }
             }
             $3 = $6;
            }
            $1 = HEAP32[$9 + 28 >> 2];
            $3 = $1 >>> 0 > $3 >>> 0 ? $3 : $1;
            HEAP32[$8 + 5296 >> 2] = $3;
            HEAP32[$8 + 5588 >> 2] = $3;
            HEAP32[$8 + 248 >> 2] = $1 - $3;
            $6 = HEAP32[$9 + 36 >> 2];
            block19 : {
             if (!$6) {
              $3 = 0;
              break block19;
             }
             $12 = HEAP32[$8 + 40 >> 2];
             $1 = 0;
             while (1) {
              block20 : {
               $5 = HEAP32[$12 + ($1 << 2) >> 2] | $5;
               $4 = $5 & 1;
               $1 = $1 + 1 | 0;
               if ($6 >>> 0 <= $1 >>> 0) {
                break block20
               }
               if (!$4) {
                continue
               }
              }
              break;
             };
             $3 = 0;
             if ($4 | !$5) {
              break block19
             }
             $1 = 0;
             while (1) {
              $1 = $1 + 1 | 0;
              $4 = $5 & 2;
              $5 = $5 >> 1;
              if (!$4) {
               continue
              }
              break;
             };
             if (!$1) {
              break block19
             }
             $5 = 0;
             if ($6 >>> 0 >= 4) {
              $15 = $6 & -4;
              $4 = 0;
              while (1) {
               $7 = $12 + ($5 << 2) | 0;
               HEAP32[$7 >> 2] = HEAP32[$7 >> 2] >> $1;
               $13 = $7 + 4 | 0;
               HEAP32[$13 >> 2] = HEAP32[$13 >> 2] >> $1;
               $13 = $7 + 8 | 0;
               HEAP32[$13 >> 2] = HEAP32[$13 >> 2] >> $1;
               $7 = $7 + 12 | 0;
               HEAP32[$7 >> 2] = HEAP32[$7 >> 2] >> $1;
               $5 = $5 + 4 | 0;
               $4 = $4 + 4 | 0;
               if (($15 | 0) != ($4 | 0)) {
                continue
               }
               break;
              };
             }
             $4 = $6 & 3;
             if ($4) {
              while (1) {
               $6 = $12 + ($5 << 2) | 0;
               HEAP32[$6 >> 2] = HEAP32[$6 >> 2] >> $1;
               $5 = $5 + 1 | 0;
               $3 = $3 + 1 | 0;
               if (($4 | 0) != ($3 | 0)) {
                continue
               }
               break;
              }
             }
             $3 = $1;
            }
            $1 = HEAP32[$9 + 28 >> 2];
            $3 = $1 >>> 0 > $3 >>> 0 ? $3 : $1;
            HEAP32[$8 + 5880 >> 2] = $3;
            HEAP32[$8 + 6172 >> 2] = $3;
            HEAP32[$8 + 252 >> 2] = ($1 - $3 | 0) + 1;
            if ($16) {
             break block23
            }
            $4 = 0;
           }
           if (HEAP32[$9 + 24 >> 2]) {
            $5 = 0;
            while (1) {
             $3 = HEAP32[$0 + 4 >> 2];
             $1 = $3 + ($5 << 2) | 0;
             $3 = $3 + ($5 << 3) | 0;
             process_subframe_($0, $18, $14, $10 + 8 | 0, HEAP32[$1 + 216 >> 2], HEAP32[$1 + 4 >> 2], $3 + 6176 | 0, $3 + 6640 | 0, $3 + 256 | 0, $1 + 6768 | 0, $1 + 6808 | 0);
             $5 = $5 + 1 | 0;
             if ($5 >>> 0 < HEAPU32[HEAP32[$0 >> 2] + 24 >> 2]) {
              continue
             }
             break;
            };
            $8 = HEAP32[$0 + 4 >> 2];
           }
           if ($4) {
            break block25
           }
           $11 = HEAP32[$8 + 36 >> 2];
          }
          $1 = $10 + 8 | 0;
          process_subframe_($0, $18, $14, $1, HEAP32[$8 + 248 >> 2], $11, $8 + 6240 | 0, $8 + 6704 | 0, $8 + 320 | 0, $8 + 6800 | 0, $8 + 6840 | 0);
          $4 = $1;
          $1 = HEAP32[$0 + 4 >> 2];
          process_subframe_($0, $18, $14, $4, HEAP32[$1 + 252 >> 2], HEAP32[$1 + 40 >> 2], $1 + 6248 | 0, $1 + 6712 | 0, $1 + 328 | 0, $1 + 6804 | 0, $1 + 6844 | 0);
          $1 = HEAP32[$0 + 4 >> 2];
          block27 : {
           if (!(!HEAP32[HEAP32[$0 >> 2] + 20 >> 2] | !HEAP32[$1 + 6864 >> 2])) {
            $4 = HEAP32[$1 + 6868 >> 2] ? 3 : 0;
            break block27;
           }
           $3 = HEAP32[$1 + 6844 >> 2];
           $4 = HEAP32[$1 + 6808 >> 2];
           $6 = $3 + $4 | 0;
           $5 = HEAP32[$1 + 6812 >> 2];
           $4 = $4 + $5 | 0;
           $8 = $6 >>> 0 < $4 >>> 0;
           $5 = $3 + $5 | 0;
           $4 = $8 ? $6 : $4;
           $6 = $5 >>> 0 < $4 >>> 0;
           $4 = $3 + HEAP32[$1 + 6840 >> 2] >>> 0 < ($6 ? $5 : $4) >>> 0 ? 3 : $6 ? 2 : $8;
          }
          HEAP32[$10 + 20 >> 2] = $4;
          if (!FLAC__frame_add_header($10 + 8 | 0, HEAP32[$1 + 6856 >> 2])) {
           $1 = HEAP32[$0 >> 2];
           break block29;
          }
          $3 = HEAP32[$0 + 4 >> 2];
          block35 : {
           block33 : {
            switch ($4 - 1 | 0) {
            default:
             $1 = ($3 + Math_imul(HEAP32[$3 + 6768 >> 2], 292) | 0) + 336 | 0;
             $6 = 220;
             $7 = 216;
             break block34;
            case 0:
             $6 = 252;
             $7 = 216;
             $1 = ($3 + Math_imul(HEAP32[$3 + 6768 >> 2], 292) | 0) + 336 | 0;
             break block35;
            case 1:
             $1 = ($3 + Math_imul(HEAP32[$3 + 6804 >> 2], 292) | 0) + 5592 | 0;
             $6 = 220;
             $7 = 252;
             break block34;
            case 2:
             break block33;
            };
           }
           $6 = 252;
           $7 = 248;
           $1 = ($3 + Math_imul(HEAP32[$3 + 6800 >> 2], 292) | 0) + 5008 | 0;
          }
          $11 = 6804;
          $4 = 5592;
          break block36;
         }
         $3 = FLAC__frame_add_header($10 + 8 | 0, HEAP32[$8 + 6856 >> 2]);
         $1 = HEAP32[$0 >> 2];
         if (!$3) {
          break block29
         }
         if (!HEAP32[$1 + 24 >> 2]) {
          break block37
         }
         $5 = 0;
         while (1) {
          $1 = HEAP32[$0 + 4 >> 2];
          $3 = $1 + ($5 << 2) | 0;
          if (!add_subframe_($0, HEAP32[$10 + 8 >> 2], HEAP32[$3 + 216 >> 2], (($1 + Math_imul($5, 584) | 0) + Math_imul(HEAP32[$3 + 6768 >> 2], 292) | 0) + 336 | 0, HEAP32[$1 + 6856 >> 2])) {
           break block38
          }
          $5 = $5 + 1 | 0;
          $1 = HEAP32[$0 >> 2];
          if ($5 >>> 0 < HEAPU32[$1 + 24 >> 2]) {
           continue
          }
          break;
         };
         break block37;
        }
        $11 = 6772;
        $4 = 920;
       }
       $6 = HEAP32[$3 + $6 >> 2];
       $5 = HEAP32[$3 + $11 >> 2];
       if (!add_subframe_($0, HEAP32[$10 + 8 >> 2], HEAP32[$3 + $7 >> 2], $1, HEAP32[$3 + 6856 >> 2])) {
        break block38
       }
       if (!add_subframe_($0, HEAP32[$10 + 8 >> 2], $6, ($3 + $4 | 0) + Math_imul($5, 292) | 0, HEAP32[HEAP32[$0 + 4 >> 2] + 6856 >> 2])) {
        break block38
       }
       $1 = HEAP32[$0 >> 2];
      }
      if (HEAP32[$1 + 20 >> 2]) {
       $1 = HEAP32[$0 + 4 >> 2];
       $3 = HEAP32[$1 + 6864 >> 2] + 1 | 0;
       HEAP32[$1 + 6864 >> 2] = $3 >>> 0 < HEAPU32[$1 + 6860 >> 2] ? $3 : 0;
      }
      $1 = HEAP32[$0 + 4 >> 2];
      HEAP32[$1 + 6868 >> 2] = HEAP32[$10 + 20 >> 2];
      $1 = HEAP32[$1 + 6856 >> 2];
      $3 = HEAP32[$1 + 16 >> 2] & 7;
      if ($3) {
       $1 = FLAC__bitwriter_write_zeroes($1, 8 - $3 | 0)
      } else {
       $1 = 1
      }
      if ($1) {
       break block40
      }
      HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
      $5 = 0;
      break block1;
     }
     $5 = 0;
     break block1;
    }
    $1 = $10 + 8 | 0;
    $6 = 0;
    $5 = __stack_pointer - 16 | 0;
    __stack_pointer = $5;
    if (FLAC__bitwriter_get_buffer(HEAP32[HEAP32[$0 + 4 >> 2] + 6856 >> 2], $5 + 12 | 0, $5 + 8 | 0)) {
     $7 = $1;
     $4 = HEAP32[$5 + 12 >> 2];
     $1 = HEAP32[$5 + 8 >> 2];
     if ($1 >>> 0 > 7) {
      while (1) {
       $3 = HEAPU8[$4 | 0] | HEAPU8[$4 + 1 | 0] << 8;
       $3 = ($3 << 8 | $3 >>> 8) ^ $6;
       $6 = HEAPU16[(HEAPU8[$4 + 7 | 0] << 1) + 1280 >> 1] ^ (HEAPU16[((HEAPU8[$4 + 6 | 0] << 1) + 1280 | 0) + 512 >> 1] ^ (HEAPU16[((HEAPU8[$4 + 5 | 0] << 1) + 1280 | 0) + 1024 >> 1] ^ (HEAPU16[((HEAPU8[$4 + 4 | 0] << 1) + 1280 | 0) + 1536 >> 1] ^ (HEAPU16[((HEAPU8[$4 + 3 | 0] << 1) + 1280 | 0) + 2048 >> 1] ^ (HEAPU16[((HEAPU8[$4 + 2 | 0] << 1) + 1280 | 0) + 2560 >> 1] ^ (HEAPU16[(($3 & 255) << 1) + 4352 >> 1] ^ HEAPU16[(($3 >>> 7 & 510) + 1280 | 0) + 3584 >> 1]))))));
       $4 = $4 + 8 | 0;
       $1 = $1 - 8 | 0;
       if ($1 >>> 0 > 7) {
        continue
       }
       break;
      }
     }
     block116 : {
      if (!$1) {
       break block116
      }
      if ($1 & 1) {
       $6 = HEAPU16[((HEAPU8[$4 | 0] ^ ($6 & 65280) >>> 8) << 1) + 1280 >> 1] ^ $6 << 8;
       $4 = $4 + 1 | 0;
       $3 = $1 - 1 | 0;
      } else {
       $3 = $1
      }
      if (($1 | 0) == 1) {
       break block116
      }
      while (1) {
       $1 = HEAPU16[((HEAPU8[$4 | 0] ^ ($6 & 65280) >>> 8) << 1) + 1280 >> 1];
       $6 = HEAPU16[((HEAPU8[$4 + 1 | 0] ^ (($1 ^ $6 << 8) & 65280) >>> 8) << 1) + 1280 >> 1] ^ $1 << 8;
       $4 = $4 + 2 | 0;
       $3 = $3 - 2 | 0;
       if ($3) {
        continue
       }
       break;
      };
     }
     HEAP16[$7 >> 1] = $6;
     $1 = 1;
    } else {
     $1 = 0
    }
    __stack_pointer = $5 + 16 | 0;
    block42 : {
     if ($1) {
      if (FLAC__bitwriter_write_raw_uint32(HEAP32[HEAP32[$0 + 4 >> 2] + 6856 >> 2], HEAPU16[$10 + 8 >> 1], HEAP32[1681])) {
       break block42
      }
     }
     HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
     $5 = 0;
     break block1;
    }
    if (!write_bitbuffer_($0, HEAP32[HEAP32[$0 >> 2] + 36 >> 2], $2)) {
     $5 = 0;
     break block1;
    }
    $1 = HEAP32[$0 + 4 >> 2];
    HEAP32[$1 + 7052 >> 2] = 0;
    $5 = 1;
    HEAP32[$1 + 7056 >> 2] = HEAP32[$1 + 7056 >> 2] + 1;
    $2 = HEAP32[$1 + 6924 >> 2];
    $0 = HEAP32[HEAP32[$0 >> 2] + 36 >> 2];
    $3 = $0 + HEAP32[$1 + 6920 >> 2] | 0;
    HEAP32[$1 + 6920 >> 2] = $3;
    HEAP32[$1 + 6924 >> 2] = $0 >>> 0 > $3 >>> 0 ? $2 + 1 | 0 : $2;
    break block1;
   }
   HEAP32[$1 >> 2] = 7;
   $5 = 0;
  }
  __stack_pointer = $10 + 48 | 0;
  return $5;
 }
 
 function FLAC__stream_encoder_init_stream($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  return init_stream_internal__299($0, 0, $1, $2, $3, $4, $5, 0) | 0;
 }
 
 function init_stream_internal__299($0, $1, $2, $3, $4, $5, $6, $7) {
  var $8 = 0, $9 = 0, $10 = 0, $11 = 0.0, $12 = 0, $13 = 0, $14 = Math_fround(0), $15 = Math_fround(0), $16 = 0, $17 = 0.0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0.0, $24 = 0, $25 = 0, $26 = 0, $27 = 0.0, $28 = Math_fround(0), $29 = 0, $30 = Math_fround(0), $31 = 0, $32 = 0, $33 = 0, $34 = 0.0, wasm2js_i32$0 = 0, wasm2js_f32$0 = Math_fround(0);
  $25 = __stack_pointer - 176 | 0;
  __stack_pointer = $25;
  $8 = HEAP32[$0 >> 2];
  block1 : {
   if (HEAP32[$8 >> 2] != 1) {
    $16 = 13;
    break block1;
   }
   $16 = 3;
   if (!$2 | !(!$3 | $4)) {
    break block1
   }
   $9 = HEAP32[$8 + 24 >> 2];
   if ($9 - 9 >>> 0 < 4294967288) {
    $16 = 4;
    break block1;
   }
   block6 : {
    block5 : {
     if (($9 | 0) != 2) {
      HEAP32[$8 + 16 >> 2] = 0;
      break block5;
     }
     if (HEAP32[$8 + 16 >> 2]) {
      break block6
     }
    }
    HEAP32[$8 + 20 >> 2] = 0;
   }
   $9 = HEAP32[$8 + 28 >> 2];
   if ($9 >>> 0 >= 32) {
    HEAP32[$8 + 16 >> 2] = 0;
    $16 = 5;
    break block1;
   }
   if ($9 - 25 >>> 0 < 4294967275) {
    $16 = 5;
    break block1;
   }
   if (HEAP32[$8 + 32 >> 2] - 1 >>> 0 >= 655350) {
    $16 = 6;
    break block1;
   }
   block11 : {
    $8 = HEAP32[$0 >> 2];
    $12 = HEAP32[$8 + 36 >> 2];
    if (!$12) {
     $12 = HEAP32[$8 + 556 >> 2] ? 4096 : 1152;
     HEAP32[$8 + 36 >> 2] = $12;
     break block11;
    }
    if ($12 - 65536 >>> 0 >= 4294901776) {
     break block11
    }
    $16 = 7;
    break block1;
   }
   $9 = HEAP32[$8 + 556 >> 2];
   if ($9 >>> 0 > 32) {
    $16 = 8;
    break block1;
   }
   if ($9 >>> 0 > $12 >>> 0) {
    $16 = 10;
    break block1;
   }
   block24 : {
    block16 : {
     block22 : {
      $9 = HEAP32[$8 + 560 >> 2];
      if (!$9) {
       $9 = HEAP32[$8 + 28 >> 2];
       if ($9 >>> 0 <= 15) {
        $9 = $9 >>> 0 <= 5 ? 5 : ($9 >>> 1 | 0) + 2 | 0;
        break block16;
       }
       if (($9 | 0) == 16) {
        $9 = 7;
        if ($12 >>> 0 < 193) {
         break block16
        }
        $9 = 8;
        if ($12 >>> 0 < 385) {
         break block16
        }
        $9 = 9;
        if ($12 >>> 0 < 577) {
         break block16
        }
        $9 = 10;
        if ($12 >>> 0 < 1153) {
         break block16
        }
        if ($12 >>> 0 >= 2305) {
         break block22
        }
        $9 = 11;
        break block16;
       }
       $9 = 13;
       if ($12 >>> 0 < 385) {
        break block16
       }
       $9 = $12 >>> 0 < 1153 ? 14 : 15;
       break block16;
      }
      if ($9 - 16 >>> 0 >= 4294967285) {
       break block24
      }
      $16 = 9;
      break block1;
     }
     $9 = $12 >>> 0 < 4609 ? 12 : 13;
    }
    HEAP32[$8 + 560 >> 2] = $9;
   }
   block26 : {
    if (!HEAP32[$8 + 8 >> 2]) {
     $12 = HEAP32[$8 + 580 >> 2];
     break block26;
    }
    $16 = 11;
    if (!(($12 >>> 0 < 4609 | HEAPU32[$8 + 32 >> 2] > 48e3) & $12 >>> 0 < 16385)) {
     break block1
    }
    $8 = HEAP32[HEAP32[$0 >> 2] + 32 >> 2];
    if ($8 - 655351 >>> 0 >= 4294311946) {
     $9 = !(($8 >>> 0) % 1e3 | 0) | !(($8 >>> 0) % 10 | 0) | $8 >>> 0 < 65536
    } else {
     $9 = 0
    }
    if (!$9) {
     break block1
    }
    $8 = HEAP32[$0 >> 2];
    if (__wasm_rotl_i32(HEAP32[$8 + 28 >> 2] - 8 | 0, 30) >>> 0 > 4) {
     break block1
    }
    $12 = HEAP32[$8 + 580 >> 2];
    if ($12 >>> 0 > 8) {
     break block1
    }
    if (HEAPU32[$8 + 32 >> 2] > 48e3) {
     break block26
    }
    if (HEAPU32[$8 + 36 >> 2] > 4608 | HEAPU32[$8 + 556 >> 2] > 12) {
     break block1
    }
   }
   $9 = 1 << HEAP32[1683];
   if ($12 >>> 0 >= $9 >>> 0) {
    $12 = $9 - 1 | 0;
    HEAP32[$8 + 580 >> 2] = $12;
   }
   if ($12 >>> 0 <= HEAPU32[$8 + 576 >> 2]) {
    HEAP32[$8 + 576 >> 2] = $12
   }
   block29 : {
    if (!$7) {
     break block29
    }
    $10 = HEAP32[$8 + 600 >> 2];
    if (!$10) {
     break block29
    }
    $13 = HEAP32[$8 + 604 >> 2];
    if ($13 >>> 0 < 2) {
     break block29
    }
    $16 = 1;
    $12 = 0;
    while (1) {
     $9 = HEAP32[$10 + ($16 << 2) >> 2];
     if (!(!$9 | HEAP32[$9 >> 2] != 4)) {
      $10 = $16 & 3;
      if ($10) {
       $8 = 0;
       while (1) {
        $13 = HEAP32[HEAP32[$0 >> 2] + 600 >> 2] + ($16 << 2) | 0;
        HEAP32[$13 >> 2] = HEAP32[$13 - 4 >> 2];
        $16 = $16 - 1 | 0;
        $8 = $8 + 1 | 0;
        if (($10 | 0) != ($8 | 0)) {
         continue
        }
        break;
       };
      }
      if ($12 >>> 0 >= 3) {
       while (1) {
        $8 = $16 << 2;
        $10 = $8 + HEAP32[HEAP32[$0 >> 2] + 600 >> 2] | 0;
        HEAP32[$10 >> 2] = HEAP32[$10 - 4 >> 2];
        $10 = $8 + HEAP32[HEAP32[$0 >> 2] + 600 >> 2] | 0;
        HEAP32[$10 - 4 >> 2] = HEAP32[$10 - 8 >> 2];
        $10 = $8 + HEAP32[HEAP32[$0 >> 2] + 600 >> 2] | 0;
        HEAP32[$10 - 8 >> 2] = HEAP32[$10 - 12 >> 2];
        $8 = $8 + HEAP32[HEAP32[$0 >> 2] + 600 >> 2] | 0;
        HEAP32[$8 - 12 >> 2] = HEAP32[$8 - 16 >> 2];
        $16 = $16 - 4 | 0;
        if ($16) {
         continue
        }
        break;
       }
      }
      HEAP32[HEAP32[HEAP32[$0 >> 2] + 600 >> 2] >> 2] = $9;
      $8 = HEAP32[$0 >> 2];
      break block29;
     }
     $12 = $12 + 1 | 0;
     $16 = $16 + 1 | 0;
     if (($13 | 0) != ($16 | 0)) {
      continue
     }
     break;
    };
   }
   $9 = HEAP32[$8 + 604 >> 2];
   block35 : {
    block37 : {
     $13 = HEAP32[$8 + 600 >> 2];
     if ($13) {
      $10 = 1;
      if (!$9) {
       break block35
      }
      $16 = 0;
      while (1) {
       $10 = HEAP32[$13 + ($16 << 2) >> 2];
       if (!(!$10 | HEAP32[$10 >> 2] != 3)) {
        HEAP32[HEAP32[$0 + 4 >> 2] + 7048 >> 2] = $10 + 16;
        break block37;
       }
       $16 = $16 + 1 | 0;
       if (($9 | 0) != ($16 | 0)) {
        continue
       }
       break;
      };
      break block37;
     }
     if ($9) {
      $16 = 12;
      break block1;
     }
     $10 = 1;
     break block35;
    }
    $12 = 0;
    while (1) {
     $16 = 12;
     block39 : {
      block43 : {
       block42 : {
        block41 : {
         block40 : {
          $10 = HEAP32[HEAP32[$8 + 600 >> 2] + ($12 << 2) >> 2];
          switch (HEAP32[$10 >> 2]) {
          case 0:
           break block1;
          case 3:
           break block40;
          case 4:
           break block41;
          case 5:
           break block42;
          case 6:
           break block43;
          default:
           break block39;
          };
         }
         if ($24) {
          break block1
         }
         $8 = $10 + 16 | 0;
         $20 = HEAP32[$8 >> 2];
         $21 = 1;
         __inlined_func$FLAC__format_seektable_is_legal$89 : {
          if (!$20) {
           break __inlined_func$FLAC__format_seektable_is_legal$89
          }
          if (($20 | 0) != 1) {
           $24 = HEAP32[$8 + 4 >> 2];
           $8 = $24;
           $9 = HEAP32[$8 >> 2];
           $8 = HEAP32[$8 + 4 >> 2];
           $18 = 1;
           while (1) {
            $10 = Math_imul($18, 24) + $24 | 0;
            $13 = HEAP32[$10 >> 2];
            $10 = HEAP32[$10 + 4 >> 2];
            $21 = 0;
            if (!(($13 & $10) == -1 | (($8 | 0) == ($10 | 0) & $9 >>> 0 < $13 >>> 0 | $8 >>> 0 < $10 >>> 0))) {
             break __inlined_func$FLAC__format_seektable_is_legal$89
            }
            $9 = $13;
            $8 = $10;
            $18 = $18 + 1 | 0;
            if (($20 | 0) != ($18 | 0)) {
             continue
            }
            break;
           };
          }
          $21 = 1;
         }
         if (!$21) {
          break block1
         }
         $24 = 1;
         break block39;
        }
        if ($29) {
         break block1
        }
        $29 = 1;
        break block39;
       }
       $8 = $10 + 16 | 0;
       __inlined_func$FLAC__format_cuesheet_is_legal$90 : {
        block2 : {
         block14 : {
          block61 : {
           if (HEAP32[$10 + 160 >> 2]) {
            $9 = HEAP32[$8 + 140 >> 2];
            $10 = HEAP32[$8 + 136 >> 2];
            if (!(!$9 & $10 >>> 0 > 88199 | ($9 | 0) != 0)) {
             break block2
            }
            if (__wasm_i64_urem($10, $9) | i64toi32_i32$HIGH_BITS) {
             break block2
            }
            $18 = HEAP32[$8 + 148 >> 2];
            if (!$18) {
             break block2
            }
            $20 = HEAP32[$8 + 152 >> 2];
            if (HEAPU8[($20 + ($18 << 5) | 0) - 24 | 0] == 170) {
             break block61
            }
            break block2;
           }
           $13 = HEAP32[$8 + 148 >> 2];
           if (!$13) {
            break block2
           }
           $18 = $13 - 1 | 0;
           $20 = HEAP32[$8 + 152 >> 2];
           $21 = $20 + 23 | 0;
           $8 = 0;
           while (1) {
            $9 = $8 << 5;
            $10 = $9 + $20 | 0;
            if (!HEAPU8[$10 + 8 | 0]) {
             break block2
            }
            block12 : {
             block113 : {
              if ($8 >>> 0 < $18 >>> 0) {
               $9 = HEAPU8[$10 + 23 | 0];
               if (!$9 | HEAPU8[HEAP32[$10 + 24 >> 2] + 8 | 0] > 1) {
                break block2
               }
               break block113;
              }
              $9 = HEAPU8[$9 + $21 | 0];
              if (!$9) {
               break block12
              }
             }
             if (($9 | 0) == 1) {
              break block12
             }
             $26 = HEAP32[$10 + 24 >> 2];
             $32 = $26 - 8 | 0;
             $10 = 1;
             while (1) {
              $31 = $10 << 4;
              if ((HEAPU8[$31 + $32 | 0] + 1 | 0) != HEAPU8[($26 + $31 | 0) + 8 | 0]) {
               break block2
              }
              $10 = $10 + 1 | 0;
              if (($9 | 0) != ($10 | 0)) {
               continue
              }
              break;
             };
            }
            $8 = $8 + 1 | 0;
            if (($13 | 0) != ($8 | 0)) {
             continue
            }
            break;
           };
           break block14;
          }
          $21 = $18 - 1 | 0;
          $8 = 0;
          while (1) {
           $9 = $20 + ($8 << 5) | 0;
           $10 = HEAPU8[$9 + 8 | 0];
           if (!$10 | !(($10 | 0) == 170 | $10 >>> 0 < 100)) {
            break block2
           }
           if (__wasm_i64_urem(HEAP32[$9 >> 2], HEAP32[$9 + 4 >> 2]) | i64toi32_i32$HIGH_BITS) {
            break block2
           }
           $13 = HEAPU8[$9 + 23 | 0];
           block19 : {
            block18 : {
             if ($8 >>> 0 < $21 >>> 0) {
              if (!$13) {
               break block2
              }
              if (HEAPU8[HEAP32[$9 + 24 >> 2] + 8 | 0] < 2) {
               break block18
              }
              break block2;
             }
             if (!$13) {
              break block19
             }
            }
            $26 = HEAP32[$9 + 24 >> 2];
            $9 = $26;
            if (__wasm_i64_urem(HEAP32[$9 >> 2], HEAP32[$9 + 4 >> 2]) | i64toi32_i32$HIGH_BITS) {
             break block2
            }
            $10 = 1;
            if (($13 | 0) == 1) {
             break block19
            }
            while (1) {
             $9 = $26 + ($10 << 4) | 0;
             if (__wasm_i64_urem(HEAP32[$9 >> 2], HEAP32[$9 + 4 >> 2]) | i64toi32_i32$HIGH_BITS | HEAPU8[$9 + 8 | 0] != (HEAPU8[$9 - 8 | 0] + 1 | 0)) {
              break block2
             }
             $10 = $10 + 1 | 0;
             if (($13 | 0) != ($10 | 0)) {
              continue
             }
             break;
            };
           }
           $8 = $8 + 1 | 0;
           if (($18 | 0) != ($8 | 0)) {
            continue
           }
           break;
          };
         }
         $9 = 1;
         break __inlined_func$FLAC__format_cuesheet_is_legal$90;
        }
        $9 = 0;
       }
       if ($9) {
        break block39
       }
       break block1;
      }
      __inlined_func$FLAC__format_picture_is_legal$137 : {
       block20 : {
        block : {
         $21 = $10 + 16 | 0;
         $13 = $21;
         $9 = HEAP32[$13 + 4 >> 2];
         $8 = HEAPU8[$9 | 0];
         if (!$8) {
          break block
         }
         while (1) {
          if (($8 - 127 & 255) >>> 0 > 160) {
           $8 = HEAPU8[$9 + 1 | 0];
           $9 = $9 + 1 | 0;
           if ($8) {
            continue
           }
           break block;
          }
          break;
         };
         break block20;
        }
        $8 = HEAP32[$13 + 8 >> 2];
        if (HEAPU8[$8 | 0]) {
         while (1) {
          $13 = 1;
          $18 = HEAPU8[$8 | 0];
          $9 = $18 << 24 >> 24;
          __inlined_func$utf8len_$13 : {
           block0 : {
            if (($9 | 0) >= 0) {
             break block0
            }
            $13 = (($18 & 222) != 192) << 1;
            if (!(($18 & 224) != 192 | HEAP8[$8 + 1 | 0] > -65)) {
             break __inlined_func$utf8len_$13
            }
            block21 : {
             if (($9 & -16) != -32) {
              break block21
             }
             $20 = HEAPU8[$8 + 1 | 0];
             if (($20 & 192) != 128) {
              break block21
             }
             $26 = HEAP8[$8 + 2 | 0];
             if (($26 | 0) > -65) {
              break block21
             }
             $13 = 0;
             if (($9 | 0) == -32 & ($20 & 160) == 128) {
              break block0
             }
             block58 : {
              block69 : {
               switch ($18 - 237 | 0) {
               case 0:
                if (($20 & 224) != 160) {
                 break block58
                }
                break block0;
               case 2:
                break block69;
               default:
                break block58;
               };
              }
              if (($20 | 0) != 191) {
               break block58
              }
              if (($26 & 190) == 190) {
               break block0
              }
             }
             $13 = 3;
             break __inlined_func$utf8len_$13;
            }
            block7 : {
             if (($9 & -8) != -16) {
              break block7
             }
             $13 = HEAPU8[$8 + 1 | 0];
             if (($13 & 192) != 128 | HEAP8[$8 + 2 | 0] > -65 | HEAP8[$8 + 3 | 0] > -65) {
              break block7
             }
             $13 = ($9 | 0) != -16 ? 4 : (($13 & 176) != 128) << 2;
             break __inlined_func$utf8len_$13;
            }
            block8 : {
             if (($9 & -4) != -8) {
              break block8
             }
             $13 = HEAPU8[$8 + 1 | 0];
             if (($13 & 192) != 128 | HEAP8[$8 + 2 | 0] > -65 | (HEAP8[$8 + 3 | 0] > -65 | HEAP8[$8 + 4 | 0] > -65)) {
              break block8
             }
             $13 = ($9 | 0) != -8 ? 5 : ($13 & 184) != 128 ? 5 : 0;
             break __inlined_func$utf8len_$13;
            }
            $13 = 0;
            if (($9 & -2) != -4) {
             break block0
            }
            $18 = HEAPU8[$8 + 1 | 0];
            if (($18 & 192) != 128 | HEAP8[$8 + 2 | 0] > -65 | (HEAP8[$8 + 3 | 0] > -65 | HEAP8[$8 + 4 | 0] > -65) | HEAP8[$8 + 5 | 0] > -65) {
             break block0
            }
            $13 = ($9 | 0) != -4 ? 6 : ($18 & 188) != 128 ? 6 : 0;
           }
          }
          $9 = $13;
          if (!$9) {
           break block20
          }
          $8 = $8 + $9 | 0;
          if (HEAPU8[$8 | 0]) {
           continue
          }
          break;
         }
        }
        $9 = 1;
        break __inlined_func$FLAC__format_picture_is_legal$137;
       }
       $9 = 0;
      }
      if (!$9) {
       break block1
      }
      block45 : {
       switch (HEAP32[$21 >> 2] - 1 | 0) {
       case 0:
        if ($19) {
         break block1
        }
        $8 = HEAP32[$10 + 20 >> 2];
        if (strcmp($8, 5867)) {
         if (strcmp($8, 5936)) {
          break block1
         }
        }
        if (HEAP32[$10 + 28 >> 2] != 32 | HEAP32[$10 + 32 >> 2] != 32) {
         break block1
        }
        $19 = 1;
        break block39;
       case 1:
        break block45;
       default:
        break block39;
       };
      }
      if ($33) {
       break block1
      }
      $33 = 1;
     }
     $12 = $12 + 1 | 0;
     $8 = HEAP32[$0 >> 2];
     if ($12 >>> 0 < HEAPU32[$8 + 604 >> 2]) {
      continue
     }
     break;
    };
    $10 = !$29;
   }
   $29 = $10;
   $12 = 0;
   $9 = HEAP32[$0 + 4 >> 2];
   HEAP32[$9 >> 2] = 0;
   $18 = HEAP32[$8 + 24 >> 2];
   block47 : {
    if (!$18) {
     break block47
    }
    $13 = $9 + 7368 | 0;
    $16 = $9 + 44 | 0;
    $19 = $9 + 7328 | 0;
    $20 = $9 + 4 | 0;
    if (($18 | 0) != 1) {
     $24 = $18 & -2;
     while (1) {
      $10 = $12 << 2;
      HEAP32[$10 + $20 >> 2] = 0;
      HEAP32[$10 + $19 >> 2] = 0;
      HEAP32[$10 + $16 >> 2] = 0;
      HEAP32[$10 + $13 >> 2] = 0;
      $10 = $10 | 4;
      HEAP32[$10 + $20 >> 2] = 0;
      HEAP32[$10 + $19 >> 2] = 0;
      HEAP32[$10 + $16 >> 2] = 0;
      HEAP32[$10 + $13 >> 2] = 0;
      $12 = $12 + 2 | 0;
      $22 = $22 + 2 | 0;
      if (($24 | 0) != ($22 | 0)) {
       continue
      }
      break;
     };
    }
    if (!($18 & 1)) {
     break block47
    }
    $10 = $12 << 2;
    HEAP32[$10 + $20 >> 2] = 0;
    HEAP32[$10 + $19 >> 2] = 0;
    HEAP32[$10 + $16 >> 2] = 0;
    HEAP32[$10 + $13 >> 2] = 0;
   }
   HEAP32[$9 + 76 >> 2] = 0;
   HEAP32[$9 + 80 >> 2] = 0;
   HEAP32[$9 + 36 >> 2] = 0;
   HEAP32[$9 + 40 >> 2] = 0;
   HEAP32[$9 + 7400 >> 2] = 0;
   HEAP32[$9 + 7404 >> 2] = 0;
   HEAP32[$9 + 7360 >> 2] = 0;
   HEAP32[$9 + 7364 >> 2] = 0;
   $20 = HEAP32[$8 + 40 >> 2];
   block49 : {
    if (!$20) {
     break block49
    }
    $10 = $9 + 7408 | 0;
    $13 = $9 + 84 | 0;
    $22 = 0;
    $16 = 0;
    if ($20 >>> 0 >= 4) {
     $24 = $20 & -4;
     $19 = 0;
     while (1) {
      $12 = $16 << 2;
      HEAP32[$12 + $13 >> 2] = 0;
      HEAP32[$10 + $12 >> 2] = 0;
      $21 = $12 | 4;
      HEAP32[$21 + $13 >> 2] = 0;
      HEAP32[$10 + $21 >> 2] = 0;
      $21 = $12 | 8;
      HEAP32[$21 + $13 >> 2] = 0;
      HEAP32[$10 + $21 >> 2] = 0;
      $12 = $12 | 12;
      HEAP32[$12 + $13 >> 2] = 0;
      HEAP32[$10 + $12 >> 2] = 0;
      $16 = $16 + 4 | 0;
      $19 = $19 + 4 | 0;
      if (($24 | 0) != ($19 | 0)) {
       continue
      }
      break;
     };
    }
    $12 = $20 & 3;
    if (!$12) {
     break block49
    }
    while (1) {
     $19 = $16 << 2;
     HEAP32[$19 + $13 >> 2] = 0;
     HEAP32[$10 + $19 >> 2] = 0;
     $16 = $16 + 1 | 0;
     $22 = $22 + 1 | 0;
     if (($12 | 0) != ($22 | 0)) {
      continue
     }
     break;
    };
   }
   HEAP32[$9 + 7536 >> 2] = 0;
   HEAP32[$9 + 212 >> 2] = 0;
   if ($18) {
    $13 = $9 + 6768 | 0;
    $12 = $9 + 7544 | 0;
    $19 = $9 + 260 | 0;
    $18 = $9 + 7540 | 0;
    $22 = $9 + 256 | 0;
    $16 = 0;
    while (1) {
     $10 = $16 << 3;
     HEAP32[$10 + $22 >> 2] = 0;
     HEAP32[$10 + $18 >> 2] = 0;
     HEAP32[$10 + $19 >> 2] = 0;
     HEAP32[$10 + $12 >> 2] = 0;
     HEAP32[$13 + ($16 << 2) >> 2] = 0;
     $16 = $16 + 1 | 0;
     if ($16 >>> 0 < HEAPU32[$8 + 24 >> 2]) {
      continue
     }
     break;
    };
   }
   HEAP32[$9 + 320 >> 2] = 0;
   HEAP32[$9 + 324 >> 2] = 0;
   HEAP32[$9 + 7604 >> 2] = 0;
   HEAP32[$9 + 7608 >> 2] = 0;
   HEAP32[$9 + 6848 >> 2] = 0;
   HEAP32[$9 + 6852 >> 2] = 0;
   HEAP32[$9 + 6800 >> 2] = 0;
   HEAP32[$9 + 6804 >> 2] = 0;
   $10 = $9 + 328 | 0;
   HEAP32[$10 >> 2] = 0;
   HEAP32[$10 + 4 >> 2] = 0;
   $10 = $9 + 7612 | 0;
   HEAP32[$10 >> 2] = 0;
   HEAP32[$10 + 4 >> 2] = 0;
   $10 = $9 + 7620 | 0;
   HEAP32[$10 >> 2] = 0;
   HEAP32[$10 + 4 >> 2] = 0;
   $10 = HEAP32[$8 + 36 >> 2];
   $8 = HEAP32[$8 + 32 >> 2];
   HEAP32[$9 + 7052 >> 2] = 0;
   HEAP32[$9 + 7056 >> 2] = 0;
   HEAP32[$9 + 6864 >> 2] = 0;
   $16 = 1;
   $11 = +($8 >>> 0) * .4 / +($10 >>> 0) + .5;
   if ($11 < 4294967295.0 & $11 >= 0.0) {
    $8 = ~~$11 >>> 0
   } else {
    $8 = 0
   }
   HEAP32[$9 + 6860 >> 2] = $8 >>> 0 <= 1 ? 1 : $8;
   FLAC__cpu_info($9 + 7156 | 0);
   $8 = HEAP32[$0 + 4 >> 2];
   HEAP32[$8 + 7244 >> 2] = 13;
   HEAP32[$8 + 7240 >> 2] = 14;
   HEAP32[$8 + 7236 >> 2] = 13;
   HEAP32[$8 + 7228 >> 2] = 15;
   HEAP32[$8 + 7224 >> 2] = 16;
   HEAP32[$8 + 7220 >> 2] = 17;
   HEAP32[$8 + 7232 >> 2] = 18;
   $12 = HEAP32[$0 >> 2];
   HEAP32[$12 >> 2] = 0;
   HEAP32[$8 + 7260 >> 2] = $7;
   block60 : {
    block53 : {
     if ($7) {
      $7 = $12 + 632 | 0;
      if (ogg_stream_init($7 + 8 | 0, HEAP32[$7 >> 2])) {
       $7 = 0
      } else {
       HEAP32[$7 + 392 >> 2] = 0;
       HEAP32[$7 + 396 >> 2] = 0;
       HEAP32[$7 + 384 >> 2] = 0;
       HEAP32[$7 + 388 >> 2] = 1;
       $7 = 1;
      }
      if (!$7) {
       break block53
      }
      $12 = HEAP32[$0 >> 2];
      $8 = HEAP32[$0 + 4 >> 2];
     }
     HEAP32[$8 + 7276 >> 2] = $2;
     HEAP32[$8 + 7264 >> 2] = $1;
     HEAP32[$8 + 7288 >> 2] = $6;
     HEAP32[$8 + 7280 >> 2] = $5;
     HEAP32[$8 + 7272 >> 2] = $4;
     HEAP32[$8 + 7268 >> 2] = $3;
     $1 = HEAP32[$12 + 36 >> 2];
     $3 = HEAP32[$0 + 4 >> 2];
     if ($1 >>> 0 > HEAPU32[$3 >> 2]) {
      $4 = $1 + 5 | 0;
      $2 = 0;
      __inlined_func$resize_buffers_$92 : {
       while (1) {
        block210 : {
         if ($2 >>> 0 >= HEAPU32[HEAP32[$0 >> 2] + 24 >> 2]) {
          $3 = FLAC__memory_alloc_aligned_int32_array($4, $3 + 7360 | 0, $3 + 36 | 0);
          $2 = HEAP32[HEAP32[$0 + 4 >> 2] + 36 >> 2];
          HEAP32[$2 >> 2] = 0;
          HEAP32[$2 + 4 >> 2] = 0;
          $2 = $2 + 8 | 0;
          HEAP32[$2 >> 2] = 0;
          HEAP32[$2 + 4 >> 2] = 0;
          $2 = HEAP32[$0 + 4 >> 2];
          HEAP32[$2 + 36 >> 2] = HEAP32[$2 + 36 >> 2] + 16;
          if (!$3) {
           break block210
          }
          $3 = FLAC__memory_alloc_aligned_int32_array($4, $2 + 7364 | 0, $2 + 40 | 0);
          $2 = HEAP32[HEAP32[$0 + 4 >> 2] + 40 >> 2];
          HEAP32[$2 >> 2] = 0;
          HEAP32[$2 + 4 >> 2] = 0;
          $2 = $2 + 8 | 0;
          HEAP32[$2 >> 2] = 0;
          HEAP32[$2 + 4 >> 2] = 0;
          $2 = HEAP32[$0 + 4 >> 2];
          HEAP32[$2 + 40 >> 2] = HEAP32[$2 + 40 >> 2] + 16;
          if (!$3) {
           break block210
          }
          if (HEAP32[HEAP32[$0 >> 2] + 556 >> 2]) {
           $2 = 0;
           while (1) {
            block411 : {
             $3 = HEAP32[$0 + 4 >> 2];
             if (HEAPU32[HEAP32[$0 >> 2] + 40 >> 2] <= $2 >>> 0) {
              break block411
             }
             $4 = $2 << 2;
             $2 = $2 + 1 | 0;
             $3 = $3 + $4 | 0;
             if (FLAC__memory_alloc_aligned_int32_array($1, $3 + 7408 | 0, $3 + 84 | 0)) {
              continue
             }
             break block210;
            }
            break;
           };
           if (!FLAC__memory_alloc_aligned_int32_array($1, $3 + 7536 | 0, $3 + 212 | 0)) {
            break block210
           }
          }
          $4 = 0;
          $3 = 1;
          $2 = 0;
          block812 : {
           while (1) {
            block713 : {
             if ($2 >>> 0 >= HEAPU32[HEAP32[$0 >> 2] + 24 >> 2]) {
              while (1) {
               $2 = 0;
               $4 = $4 << 3;
               $5 = $4 + HEAP32[$0 + 4 >> 2] | 0;
               if (FLAC__memory_alloc_aligned_int32_array($1, $5 + 7604 | 0, $5 + 320 | 0)) {
                $2 = $4 + HEAP32[$0 + 4 >> 2] | 0;
                $2 = (FLAC__memory_alloc_aligned_int32_array($1, $2 + 7608 | 0, $2 + 324 | 0) | 0) != 0;
               }
               $5 = $2 & $3;
               $4 = 1;
               $3 = 0;
               if ($5) {
                continue
               }
               break;
              };
              if (!$2) {
               break block210
              }
              $3 = HEAP32[$0 + 4 >> 2];
              $2 = $3 + 7620 | 0;
              $5 = $3 + 6848 | 0;
              $3 = 0;
              $6 = $1 << 1;
              $4 = $6;
              block15 : {
               if ($4 >>> 0 > 536870911) {
                break block15
               }
               $4 = $4 << 3;
               $4 = emscripten_builtin_malloc($4 >>> 0 <= 1 ? 1 : $4);
               if (!$4) {
                break block15
               }
               $3 = HEAP32[$2 >> 2];
               if ($3) {
                emscripten_builtin_free($3)
               }
               HEAP32[$2 >> 2] = $4;
               HEAP32[$5 >> 2] = $4;
               $3 = 1;
              }
              $2 = $3;
              $3 = HEAP32[HEAP32[$0 >> 2] + 572 >> 2];
              if (!$3 | !$2) {
               break block713
              }
              $2 = HEAP32[$0 + 4 >> 2];
              if (FLAC__memory_alloc_aligned_int32_array($6, $2 + 7624 | 0, $2 + 6852 | 0)) {
               break block812
              }
              break block210;
             }
             $5 = $2 << 3;
             $6 = $5 + HEAP32[$0 + 4 >> 2] | 0;
             if (FLAC__memory_alloc_aligned_int32_array($1, $6 + 7540 | 0, $6 + 256 | 0)) {
              $5 = $5 + HEAP32[$0 + 4 >> 2] | 0;
              $5 = (FLAC__memory_alloc_aligned_int32_array($1, $5 + 7544 | 0, $5 + 260 | 0) | 0) != 0;
             } else {
              $5 = 0
             }
             $2 = $2 + 1 | 0;
             if ($5) {
              continue
             }
             break block210;
            }
            break;
           };
           if (!$2 | $3) {
            break block210
           }
          }
          $2 = HEAP32[$0 + 4 >> 2];
          block1114 : {
           if (HEAP32[$2 >> 2] == ($1 | 0)) {
            break block1114
           }
           $4 = HEAP32[$0 >> 2];
           if (!HEAP32[$4 + 556 >> 2] | !HEAP32[$4 + 40 >> 2]) {
            break block1114
           }
           $2 = 0;
           while (1) {
            $4 = ($2 << 4) + $4 | 0;
            $7 = $4 + 44 | 0;
            $3 = HEAP32[(HEAP32[$0 + 4 >> 2] + ($2 << 2) | 0) + 84 >> 2];
            block2916 : {
             block2016 : {
              switch (HEAP32[$4 + 44 >> 2]) {
              case 0:
               $4 = $3;
               $3 = 0;
               $5 = 0;
               $7 = 0;
               $6 = $1 - 1 | 0;
               block719 : {
                block120 : {
                 block3 : {
                  block221 : {
                   if ($1 & 1) {
                    $7 = $6 >> 1;
                    if (($7 | 0) < 0) {
                     break block120
                    }
                    $14 = Math_fround($6 >>> 0);
                    if ($6) {
                     break block221
                    }
                    break block3;
                   }
                   $3 = $1 >> 1;
                   block522 : {
                    if (($3 | 0) <= 0) {
                     $3 = 0;
                     break block522;
                    }
                    $14 = Math_fround($6 | 0);
                    if (($1 | 0) != 2) {
                     $8 = $3 & 2147483646;
                     while (1) {
                      $15 = Math_fround($5 >>> 0);
                      HEAPF32[($5 << 2) + $4 >> 2] = Math_fround($15 + $15) / $14;
                      $9 = $5 | 1;
                      $15 = Math_fround($9 >>> 0);
                      HEAPF32[($9 << 2) + $4 >> 2] = Math_fround($15 + $15) / $14;
                      $5 = $5 + 2 | 0;
                      $7 = $7 + 2 | 0;
                      if (($8 | 0) != ($7 | 0)) {
                       continue
                      }
                      break;
                     };
                    }
                    if (!($1 & 2)) {
                     break block522
                    }
                    $15 = Math_fround($5 >>> 0);
                    HEAPF32[($5 << 2) + $4 >> 2] = Math_fround($15 + $15) / $14;
                   }
                   if (($1 | 0) <= ($3 | 0)) {
                    break block719
                   }
                   $5 = $3 + 1 | 0;
                   $14 = Math_fround($6 | 0);
                   if ($3 & 1) {
                    $15 = Math_fround($3 >>> 0);
                    HEAPF32[($3 << 2) + $4 >> 2] = Math_fround(2.0) - Math_fround(Math_fround($15 + $15) / $14);
                    $3 = $5;
                   }
                   if (($1 | 0) == ($5 | 0)) {
                    break block719
                   }
                   while (1) {
                    $15 = Math_fround($3 >>> 0);
                    HEAPF32[($3 << 2) + $4 >> 2] = Math_fround(2.0) - Math_fround(Math_fround($15 + $15) / $14);
                    $5 = $3 + 1 | 0;
                    $15 = Math_fround($5 >>> 0);
                    HEAPF32[($5 << 2) + $4 >> 2] = Math_fround(2.0) - Math_fround(Math_fround($15 + $15) / $14);
                    $3 = $3 + 2 | 0;
                    if (($3 | 0) != ($1 | 0)) {
                     continue
                    }
                    break;
                   };
                   break block719;
                  }
                  $8 = $7 + 1 & 2147483646;
                  while (1) {
                   $15 = Math_fround($5 >>> 0);
                   HEAPF32[($5 << 2) + $4 >> 2] = Math_fround($15 + $15) / $14;
                   $9 = $5 | 1;
                   $15 = Math_fround($9 >>> 0);
                   HEAPF32[($9 << 2) + $4 >> 2] = Math_fround($15 + $15) / $14;
                   $5 = $5 + 2 | 0;
                   $3 = $3 + 2 | 0;
                   if (($8 | 0) != ($3 | 0)) {
                    continue
                   }
                   break;
                  };
                 }
                 $3 = $7 + 1 | 0;
                 if ($6 & 2) {
                  break block120
                 }
                 $15 = Math_fround($5 >>> 0);
                 HEAPF32[($5 << 2) + $4 >> 2] = Math_fround($15 + $15) / $14;
                }
                if (($1 | 0) <= ($3 | 0)) {
                 break block719
                }
                $5 = $3 + 1 | 0;
                $14 = Math_fround($6 | 0);
                if ($1 - $3 & 1) {
                 $15 = Math_fround($3 >>> 0);
                 HEAPF32[($3 << 2) + $4 >> 2] = Math_fround(2.0) - Math_fround(Math_fround($15 + $15) / $14);
                 $3 = $5;
                }
                if (($1 | 0) == ($5 | 0)) {
                 break block719
                }
                while (1) {
                 $15 = Math_fround($3 >>> 0);
                 HEAPF32[($3 << 2) + $4 >> 2] = Math_fround(2.0) - Math_fround(Math_fround($15 + $15) / $14);
                 $5 = $3 + 1 | 0;
                 $15 = Math_fround($5 >>> 0);
                 HEAPF32[($5 << 2) + $4 >> 2] = Math_fround(2.0) - Math_fround(Math_fround($15 + $15) / $14);
                 $3 = $3 + 2 | 0;
                 if (($3 | 0) != ($1 | 0)) {
                  continue
                 }
                 break;
                };
               }
               break block2916;
              case 1:
               $4 = 0;
               if (($1 | 0) > 0) {
                $14 = Math_fround($1 - 1 >>> 0);
                while (1) {
                 $15 = Math_fround(Math_fround($4 >>> 0) / $14);
                 (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos(+$15 * 6.283185307179586) * -.3799999952316284 + (+Math_fround(Math_abs(Math_fround($15 + Math_fround(-.5)))) * -.47999998927116394 + .6200000047683716))), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 $4 = $4 + 1 | 0;
                 if (($4 | 0) != ($1 | 0)) {
                  continue
                 }
                 break;
                };
               }
               break block2916;
              case 2:
               $4 = 0;
               if (($1 | 0) > 0) {
                $11 = +($1 - 1 >>> 0);
                while (1) {
                 $17 = +($4 >>> 0);
                 (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos($17 * 12.566370614359172 / $11) * .07999999821186066 + (cos($17 * 6.283185307179586 / $11) * -.5 + .41999998688697815))), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 $4 = $4 + 1 | 0;
                 if (($4 | 0) != ($1 | 0)) {
                  continue
                 }
                 break;
                };
               }
               break block2916;
              case 3:
               $4 = 0;
               if (($1 | 0) > 0) {
                $11 = +($1 - 1 >>> 0);
                while (1) {
                 $17 = +($4 >>> 0);
                 $23 = cos($17 * 12.566370614359172 / $11);
                 $27 = cos($17 * 6.283185307179586 / $11);
                 (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos($17 * 18.84955592153876 / $11) * -.011680000461637974 + ($23 * .14127999544143677 + ($27 * -.488290011882782 + .35874998569488525)))), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 $4 = $4 + 1 | 0;
                 if (($4 | 0) != ($1 | 0)) {
                  continue
                 }
                 break;
                };
               }
               break block2916;
              case 4:
               $4 = 0;
               block31 : {
                if (($1 | 0) <= 0) {
                 break block31
                }
                $11 = +($1 - 1 | 0) * .5;
                if (($1 | 0) != 1) {
                 $6 = $1 & 2147483646;
                 $5 = 0;
                 while (1) {
                  $17 = (+($4 >>> 0) - $11) / $11;
                  $17 = 1.0 - $17 * $17;
                  HEAPF32[($4 << 2) + $3 >> 2] = $17 * $17;
                  $7 = $4 | 1;
                  $17 = (+($7 >>> 0) - $11) / $11;
                  $17 = 1.0 - $17 * $17;
                  HEAPF32[($7 << 2) + $3 >> 2] = $17 * $17;
                  $4 = $4 + 2 | 0;
                  $5 = $5 + 2 | 0;
                  if (($6 | 0) != ($5 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                if (!($1 & 1)) {
                 break block31
                }
                $11 = (+($4 >>> 0) - $11) / $11;
                $11 = 1.0 - $11 * $11;
                HEAPF32[($4 << 2) + $3 >> 2] = $11 * $11;
               }
               break block2916;
              case 5:
               $4 = 0;
               if (($1 | 0) > 0) {
                $11 = +($1 - 1 >>> 0);
                while (1) {
                 $17 = +($4 >>> 0);
                 $23 = cos($17 * 12.566370614359172 / $11);
                 $27 = cos($17 * 6.283185307179586 / $11);
                 $34 = cos($17 * 18.84955592153876 / $11);
                 (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos($17 * 25.132741228718345 / $11) * 6.9473679177463055e-03 + ($34 * -.08357894420623779 + ($23 * .27726316452026367 + ($27 * -.4166315793991089 + .21557894349098206))))), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 $4 = $4 + 1 | 0;
                 if (($4 | 0) != ($1 | 0)) {
                  continue
                 }
                 break;
                };
               }
               break block2916;
              case 6:
               $14 = HEAPF32[$7 + 4 >> 2];
               $4 = 0;
               block34 : {
                if (($1 | 0) <= 0) {
                 break block34
                }
                $11 = +($1 - 1 | 0) * .5;
                $17 = $11 * +$14;
                if (($1 | 0) != 1) {
                 $6 = $1 & 2147483646;
                 $5 = 0;
                 while (1) {
                  $23 = (+($4 >>> 0) - $11) / $17;
                  (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(exp($23 * ($23 * -.5)))), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                  $7 = $4 | 1;
                  $23 = (+($7 >>> 0) - $11) / $17;
                  (wasm2js_i32$0 = ($7 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(exp($23 * ($23 * -.5)))), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                  $4 = $4 + 2 | 0;
                  $5 = $5 + 2 | 0;
                  if (($6 | 0) != ($5 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                if (!($1 & 1)) {
                 break block34
                }
                $11 = (+($4 >>> 0) - $11) / $17;
                (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(exp($11 * ($11 * -.5)))), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
               }
               break block2916;
              case 7:
               $4 = 0;
               block36 : {
                if (($1 | 0) <= 0) {
                 break block36
                }
                $11 = +($1 - 1 >>> 0);
                if (($1 | 0) != 1) {
                 $6 = $1 & 2147483646;
                 $5 = 0;
                 while (1) {
                  (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 >>> 0) * 6.283185307179586 / $11) * -.46000000834465027 + .5400000214576721)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                  $7 = $4 | 1;
                  (wasm2js_i32$0 = ($7 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos(+($7 >>> 0) * 6.283185307179586 / $11) * -.46000000834465027 + .5400000214576721)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                  $4 = $4 + 2 | 0;
                  $5 = $5 + 2 | 0;
                  if (($6 | 0) != ($5 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                if (!($1 & 1)) {
                 break block36
                }
                (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 >>> 0) * 6.283185307179586 / $11) * -.46000000834465027 + .5400000214576721)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
               }
               break block2916;
              case 9:
               $4 = 0;
               if (($1 | 0) > 0) {
                $11 = +($1 - 1 >>> 0);
                while (1) {
                 $17 = +($4 >>> 0);
                 $23 = cos($17 * 12.566370614359172 / $11);
                 $27 = cos($17 * 6.283185307179586 / $11);
                 (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos($17 * 18.84955592153876 / $11) * -1.0000000474974513e-03 + ($23 * .09799999743700027 + ($27 * -.49799999594688416 + .4020000100135803)))), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 $4 = $4 + 1 | 0;
                 if (($4 | 0) != ($1 | 0)) {
                  continue
                 }
                 break;
                };
               }
               break block2916;
              case 10:
               $4 = 0;
               if (($1 | 0) > 0) {
                $11 = +($1 - 1 >>> 0);
                while (1) {
                 $17 = +($4 >>> 0);
                 $23 = cos($17 * 12.566370614359172 / $11);
                 $27 = cos($17 * 6.283185307179586 / $11);
                 (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos($17 * 18.84955592153876 / $11) * -.010641099885106087 + ($23 * .13659949600696564 + ($27 * -.48917749524116516 + .36358189582824707)))), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 $4 = $4 + 1 | 0;
                 if (($4 | 0) != ($1 | 0)) {
                  continue
                 }
                 break;
                };
               }
               break block2916;
              case 11:
               $4 = 0;
               $6 = 0;
               $7 = 0;
               block46 : {
                if (($1 | 0) <= 0) {
                 break block46
                }
                if ($1 >>> 0 >= 8) {
                 $8 = $1 & 2147483640;
                 while (1) {
                  $5 = ($4 << 2) + $3 | 0;
                  HEAP32[$5 >> 2] = 1065353216;
                  HEAP32[$5 + 4 >> 2] = 1065353216;
                  $9 = $5 + 8 | 0;
                  HEAP32[$9 >> 2] = 1065353216;
                  HEAP32[$9 + 4 >> 2] = 1065353216;
                  $9 = $5 + 16 | 0;
                  HEAP32[$9 >> 2] = 1065353216;
                  HEAP32[$9 + 4 >> 2] = 1065353216;
                  $5 = $5 + 24 | 0;
                  HEAP32[$5 >> 2] = 1065353216;
                  HEAP32[$5 + 4 >> 2] = 1065353216;
                  $4 = $4 + 8 | 0;
                  $7 = $7 + 8 | 0;
                  if (($7 | 0) != ($8 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                $5 = $1 & 7;
                if (!$5) {
                 break block46
                }
                while (1) {
                 HEAP32[($4 << 2) + $3 >> 2] = 1065353216;
                 $4 = $4 + 1 | 0;
                 $6 = $6 + 1 | 0;
                 if (($6 | 0) != ($5 | 0)) {
                  continue
                 }
                 break;
                };
               }
               break block2916;
              case 12:
               $5 = $3;
               $4 = 1;
               block349 : {
                if ($1 & 1) {
                 $6 = $3 - 4 | 0;
                 $7 = $1 + 1 | 0;
                 $8 = $7 >> 1;
                 block150 : {
                  if (($8 | 0) <= 0) {
                   break block150
                  }
                  $14 = Math_fround(Math_fround($1 | 0) + Math_fround(1.0));
                  $3 = 1;
                  if (($7 | 0) != 2) {
                   $9 = $8 & 2147483646;
                   $4 = 0;
                   while (1) {
                    $10 = $3 << 2;
                    $15 = Math_fround($3 >>> 0);
                    HEAPF32[$10 + $6 >> 2] = Math_fround($15 + $15) / $14;
                    $15 = Math_fround($3 + 1 >>> 0);
                    HEAPF32[$5 + $10 >> 2] = Math_fround($15 + $15) / $14;
                    $3 = $3 + 2 | 0;
                    $4 = $4 + 2 | 0;
                    if (($9 | 0) != ($4 | 0)) {
                     continue
                    }
                    break;
                   };
                  }
                  $4 = $8 + 1 | 0;
                  if (!($7 & 2)) {
                   break block150
                  }
                  $15 = Math_fround($3 >>> 0);
                  HEAPF32[$6 + ($3 << 2) >> 2] = Math_fround($15 + $15) / $14;
                 }
                 if (($1 | 0) < ($4 | 0)) {
                  break block349
                 }
                 $14 = Math_fround(Math_fround($1 | 0) + Math_fround(1.0));
                 $3 = $4;
                 if ($3 & 1) {
                  HEAPF32[$6 + ($3 << 2) >> 2] = Math_fround($1 - $3 << 1 | 2) / $14;
                  $3 = $3 + 1 | 0;
                 }
                 if (($1 | 0) == ($4 | 0)) {
                  break block349
                 }
                 while (1) {
                  $4 = $3 << 2;
                  HEAPF32[$4 + $6 >> 2] = Math_fround(($1 - $3 << 1) + 2 | 0) / $14;
                  $7 = $4 + $5 | 0;
                  $4 = $3 + 1 | 0;
                  HEAPF32[$7 >> 2] = Math_fround(($1 - $4 << 1) + 2 | 0) / $14;
                  $3 = $3 + 2 | 0;
                  if (($1 | 0) != ($4 | 0)) {
                   continue
                  }
                  break;
                 };
                 break block349;
                }
                $6 = $5 - 4 | 0;
                $7 = $1 >> 1;
                block553 : {
                 if (($7 | 0) <= 0) {
                  break block553
                 }
                 $14 = Math_fround(Math_fround($1 >>> 0) + Math_fround(1.0));
                 $3 = 1;
                 if (($1 | 0) != 2) {
                  $8 = $7 & 2147483646;
                  $4 = 0;
                  while (1) {
                   $9 = $3 << 2;
                   $15 = Math_fround($3 >>> 0);
                   HEAPF32[$9 + $6 >> 2] = Math_fround($15 + $15) / $14;
                   $15 = Math_fround($3 + 1 >>> 0);
                   HEAPF32[$5 + $9 >> 2] = Math_fround($15 + $15) / $14;
                   $3 = $3 + 2 | 0;
                   $4 = $4 + 2 | 0;
                   if (($8 | 0) != ($4 | 0)) {
                    continue
                   }
                   break;
                  };
                 }
                 $4 = $7 + 1 | 0;
                 if (!($1 & 2)) {
                  break block553
                 }
                 $15 = Math_fround($3 >>> 0);
                 HEAPF32[$6 + ($3 << 2) >> 2] = Math_fround($15 + $15) / $14;
                }
                if (($1 | 0) < ($4 | 0)) {
                 break block349
                }
                $14 = Math_fround(Math_fround($1 | 0) + Math_fround(1.0));
                $3 = $4;
                if (!($3 & 1)) {
                 HEAPF32[$6 + ($3 << 2) >> 2] = Math_fround($1 - $3 << 1 | 2) / $14;
                 $3 = $3 | 1;
                }
                if (($1 | 0) == ($4 | 0)) {
                 break block349
                }
                while (1) {
                 $4 = $3 << 2;
                 HEAPF32[$4 + $6 >> 2] = Math_fround(($1 - $3 << 1) + 2 | 0) / $14;
                 $7 = $4 + $5 | 0;
                 $4 = $3 + 1 | 0;
                 HEAPF32[$7 >> 2] = Math_fround(($1 - $4 << 1) + 2 | 0) / $14;
                 $3 = $3 + 2 | 0;
                 if (($1 | 0) != ($4 | 0)) {
                  continue
                 }
                 break;
                };
               }
               break block2916;
              case 13:
               $4 = 0;
               $5 = 0;
               $6 = 0;
               $14 = HEAPF32[$7 + 4 >> 2];
               __inlined_func$FLAC__window_tukey$151 : {
                if ($14 <= Math_fround(0.0)) {
                 if (($1 | 0) <= 0) {
                  break __inlined_func$FLAC__window_tukey$151
                 }
                 if ($1 >>> 0 >= 8) {
                  $8 = $1 & 2147483640;
                  while (1) {
                   $7 = ($4 << 2) + $3 | 0;
                   HEAP32[$7 >> 2] = 1065353216;
                   HEAP32[$7 + 4 >> 2] = 1065353216;
                   $9 = $7 + 8 | 0;
                   HEAP32[$9 >> 2] = 1065353216;
                   HEAP32[$9 + 4 >> 2] = 1065353216;
                   $9 = $7 + 16 | 0;
                   HEAP32[$9 >> 2] = 1065353216;
                   HEAP32[$9 + 4 >> 2] = 1065353216;
                   $7 = $7 + 24 | 0;
                   HEAP32[$7 >> 2] = 1065353216;
                   HEAP32[$7 + 4 >> 2] = 1065353216;
                   $4 = $4 + 8 | 0;
                   $6 = $6 + 8 | 0;
                   if (($8 | 0) != ($6 | 0)) {
                    continue
                   }
                   break;
                  };
                 }
                 $6 = $1 & 7;
                 if (!$6) {
                  break __inlined_func$FLAC__window_tukey$151
                 }
                 while (1) {
                  HEAP32[($4 << 2) + $3 >> 2] = 1065353216;
                  $4 = $4 + 1 | 0;
                  $5 = $5 + 1 | 0;
                  if (($6 | 0) != ($5 | 0)) {
                   continue
                  }
                  break;
                 };
                 break __inlined_func$FLAC__window_tukey$151;
                }
                if ($14 >= Math_fround(1.0)) {
                 if (($1 | 0) <= 0) {
                  break __inlined_func$FLAC__window_tukey$151
                 }
                 $11 = +($1 - 1 >>> 0);
                 if (($1 | 0) != 1) {
                  $6 = $1 & 2147483646;
                  while (1) {
                   (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 >>> 0) * 6.283185307179586 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                   $7 = $4 | 1;
                   (wasm2js_i32$0 = ($7 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos(+($7 >>> 0) * 6.283185307179586 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                   $4 = $4 + 2 | 0;
                   $5 = $5 + 2 | 0;
                   if (($6 | 0) != ($5 | 0)) {
                    continue
                   }
                   break;
                  };
                 }
                 if (!($1 & 1)) {
                  break __inlined_func$FLAC__window_tukey$151
                 }
                 (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 >>> 0) * 6.283185307179586 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 break __inlined_func$FLAC__window_tukey$151;
                }
                $14 = Math_fround(Math_fround($14 * Math_fround(.5)) * Math_fround($1 | 0));
                if (Math_fround(Math_abs($14)) < Math_fround(2147483648.0)) {
                 $7 = ~~$14
                } else {
                 $7 = -2147483648
                }
                block560 : {
                 if (($1 | 0) <= 0) {
                  break block560
                 }
                 if ($1 >>> 0 >= 8) {
                  $9 = $1 & 2147483640;
                  while (1) {
                   $8 = ($4 << 2) + $3 | 0;
                   HEAP32[$8 >> 2] = 1065353216;
                   HEAP32[$8 + 4 >> 2] = 1065353216;
                   $10 = $8 + 8 | 0;
                   HEAP32[$10 >> 2] = 1065353216;
                   HEAP32[$10 + 4 >> 2] = 1065353216;
                   $10 = $8 + 16 | 0;
                   HEAP32[$10 >> 2] = 1065353216;
                   HEAP32[$10 + 4 >> 2] = 1065353216;
                   $8 = $8 + 24 | 0;
                   HEAP32[$8 >> 2] = 1065353216;
                   HEAP32[$8 + 4 >> 2] = 1065353216;
                   $4 = $4 + 8 | 0;
                   $6 = $6 + 8 | 0;
                   if (($9 | 0) != ($6 | 0)) {
                    continue
                   }
                   break;
                  };
                 }
                 $6 = $1 & 7;
                 if (!$6) {
                  break block560
                 }
                 while (1) {
                  HEAP32[($4 << 2) + $3 >> 2] = 1065353216;
                  $4 = $4 + 1 | 0;
                  $5 = $5 + 1 | 0;
                  if (($6 | 0) != ($5 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                if (($7 | 0) < 2) {
                 break __inlined_func$FLAC__window_tukey$151
                }
                $5 = ($1 - $7 << 2) + $3 | 0;
                $6 = $7 - 1 | 0;
                $11 = +($6 >>> 0);
                $4 = 0;
                while (1) {
                 $8 = $4 << 2;
                 (wasm2js_i32$0 = $8 + $3 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 >>> 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 (wasm2js_i32$0 = $5 + $8 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 + $6 | 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 $4 = $4 + 1 | 0;
                 if (($7 | 0) != ($4 | 0)) {
                  continue
                 }
                 break;
                };
               }
               break block2916;
              case 14:
               $5 = $3;
               $14 = HEAPF32[$7 + 4 >> 2];
               $15 = HEAPF32[$7 + 8 >> 2];
               $8 = 0;
               $30 = Math_fround($1 | 0);
               $28 = Math_fround(HEAPF32[$7 + 12 >> 2] * $30);
               if (Math_fround(Math_abs($28)) < Math_fround(2147483648.0)) {
                $9 = ~~$28
               } else {
                $9 = -2147483648
               }
               $15 = Math_fround($15 * $30);
               if (Math_fround(Math_abs($15)) < Math_fround(2147483648.0)) {
                $4 = ~~$15
               } else {
                $4 = -2147483648
               }
               $3 = $9 - $4 | 0;
               block2664 : {
                block2565 : {
                 block366 : {
                  block567 : {
                   block668 : {
                    if ($14 <= Math_fround(0.0)) {
                     $14 = Math_fround(Math_fround($3 | 0) * Math_fround(.02500000037252903));
                     if (Math_fround(Math_abs($14)) < Math_fround(2147483648.0)) {
                      $7 = ~~$14
                     } else {
                      $7 = -2147483648
                     }
                     $3 = ($1 | 0) > ($4 | 0) ? $4 : $1;
                     block269 : {
                      if (($3 | 0) <= 0) {
                       $3 = 0;
                       break block269;
                      }
                      $6 = $3 << 2;
                      if (!$6) {
                       break block269
                      }
                      wasm2js_memory_fill($5, 0, $6);
                     }
                     $4 = $4 + $7 | 0;
                     $4 = ($1 | 0) > ($4 | 0) ? $4 : $1;
                     if (($4 | 0) <= ($3 | 0)) {
                      break block366
                     }
                     $6 = $4 - $3 | 0;
                     $10 = $6 & 1;
                     $11 = +($7 | 0);
                     $17 = 3.141592653589793;
                     if (($3 + 1 | 0) == ($4 | 0)) {
                      break block567
                     }
                     $13 = $5 + 4 | 0;
                     $6 = $6 & -2;
                     $4 = 1;
                     while (1) {
                      $12 = $3 << 2;
                      (wasm2js_i32$0 = $12 + $5 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 >>> 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                      (wasm2js_i32$0 = $12 + $13 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 + 1 >>> 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                      $4 = $4 + 2 | 0;
                      $3 = $3 + 2 | 0;
                      $8 = $8 + 2 | 0;
                      if (($6 | 0) != ($8 | 0)) {
                       continue
                      }
                      break;
                     };
                     break block668;
                    }
                    block10 : {
                     block1271 : {
                      block1372 : {
                       if ($14 >= Math_fround(1.0)) {
                        $14 = Math_fround(Math_fround($3 | 0) * Math_fround(.4749999940395355));
                        if (Math_fround(Math_abs($14)) < Math_fround(2147483648.0)) {
                         $7 = ~~$14
                        } else {
                         $7 = -2147483648
                        }
                        $3 = ($1 | 0) > ($4 | 0) ? $4 : $1;
                        block9 : {
                         if (($3 | 0) <= 0) {
                          $3 = 0;
                          break block9;
                         }
                         $6 = $3 << 2;
                         if (!$6) {
                          break block9
                         }
                         wasm2js_memory_fill($5, 0, $6);
                        }
                        $4 = $4 + $7 | 0;
                        $4 = ($1 | 0) > ($4 | 0) ? $4 : $1;
                        if (($4 | 0) <= ($3 | 0)) {
                         break block10
                        }
                        $6 = $4 - $3 | 0;
                        $10 = $6 & 1;
                        $11 = +($7 | 0);
                        $17 = 3.141592653589793;
                        if (($3 + 1 | 0) == ($4 | 0)) {
                         break block1271
                        }
                        $13 = $5 + 4 | 0;
                        $6 = $6 & -2;
                        $4 = 1;
                        while (1) {
                         $12 = $3 << 2;
                         (wasm2js_i32$0 = $12 + $5 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 >>> 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                         (wasm2js_i32$0 = $12 + $13 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 + 1 >>> 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                         $4 = $4 + 2 | 0;
                         $3 = $3 + 2 | 0;
                         $8 = $8 + 2 | 0;
                         if (($6 | 0) != ($8 | 0)) {
                          continue
                         }
                         break;
                        };
                        break block1372;
                       }
                       $14 = Math_fround(Math_fround($14 * Math_fround(.5)) * Math_fround($3 | 0));
                       if (Math_fround(Math_abs($14)) < Math_fround(2147483648.0)) {
                        $7 = ~~$14
                       } else {
                        $7 = -2147483648
                       }
                       $3 = ($1 | 0) > ($4 | 0) ? $4 : $1;
                       block1574 : {
                        if (($3 | 0) <= 0) {
                         $3 = 0;
                         break block1574;
                        }
                        $6 = $3 << 2;
                        if (!$6) {
                         break block1574
                        }
                        wasm2js_memory_fill($5, 0, $6);
                       }
                       $4 = $4 + $7 | 0;
                       $4 = ($1 | 0) > ($4 | 0) ? $4 : $1;
                       block1675 : {
                        if (($4 | 0) <= ($3 | 0)) {
                         break block1675
                        }
                        $6 = $4 - $3 | 0;
                        $10 = $6 & 1;
                        $11 = +($7 | 0);
                        if (($3 + 1 | 0) == ($4 | 0)) {
                         $17 = 3.141592653589793
                        } else {
                         $13 = $5 + 4 | 0;
                         $6 = $6 & -2;
                         $4 = 1;
                         while (1) {
                          $12 = $3 << 2;
                          (wasm2js_i32$0 = $12 + $5 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 >>> 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                          (wasm2js_i32$0 = $12 + $13 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 + 1 >>> 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                          $4 = $4 + 2 | 0;
                          $3 = $3 + 2 | 0;
                          $8 = $8 + 2 | 0;
                          if (($6 | 0) != ($8 | 0)) {
                           continue
                          }
                          break;
                         };
                         $17 = +($4 >>> 0) * 3.141592653589793;
                        }
                        if (!$10) {
                         break block1675
                        }
                        (wasm2js_i32$0 = ($3 << 2) + $5 | 0, wasm2js_f32$0 = Math_fround(cos($17 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                        $3 = $3 + 1 | 0;
                       }
                       $4 = $9 - $7 | 0;
                       $6 = ($1 | 0) > ($4 | 0) ? $4 : $1;
                       if (($3 | 0) < ($6 | 0)) {
                        $4 = $3;
                        $10 = $6 - $3 & 7;
                        if ($10) {
                         $8 = 0;
                         while (1) {
                          HEAP32[($4 << 2) + $5 >> 2] = 1065353216;
                          $4 = $4 + 1 | 0;
                          $8 = $8 + 1 | 0;
                          if (($10 | 0) != ($8 | 0)) {
                           continue
                          }
                          break;
                         };
                        }
                        if ($3 - $6 >>> 0 <= 4294967288) {
                         $8 = $5 + 28 | 0;
                         $10 = $5 + 24 | 0;
                         $13 = $5 + 20 | 0;
                         $12 = $5 + 16 | 0;
                         $19 = $5 + 12 | 0;
                         $18 = $5 + 8 | 0;
                         $22 = $5 + 4 | 0;
                         while (1) {
                          $3 = $4 << 2;
                          HEAP32[$3 + $5 >> 2] = 1065353216;
                          HEAP32[$3 + $22 >> 2] = 1065353216;
                          HEAP32[$3 + $18 >> 2] = 1065353216;
                          HEAP32[$3 + $19 >> 2] = 1065353216;
                          HEAP32[$3 + $12 >> 2] = 1065353216;
                          HEAP32[$3 + $13 >> 2] = 1065353216;
                          HEAP32[$3 + $10 >> 2] = 1065353216;
                          HEAP32[$3 + $8 >> 2] = 1065353216;
                          $4 = $4 + 8 | 0;
                          if (($6 | 0) != ($4 | 0)) {
                           continue
                          }
                          break;
                         };
                        }
                        $3 = $6;
                       }
                       $4 = ($1 | 0) > ($9 | 0) ? $9 : $1;
                       if (($3 | 0) < ($4 | 0)) {
                        $6 = $3 + 1 | 0;
                        $11 = +($7 | 0);
                        if ($4 - $3 & 1) {
                         (wasm2js_i32$0 = ($3 << 2) + $5 | 0, wasm2js_f32$0 = Math_fround(cos($11 * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                         $7 = $7 - 1 | 0;
                         $3 = $6;
                        }
                        if (($4 | 0) != ($6 | 0)) {
                         $6 = $5 + 4 | 0;
                         while (1) {
                          $8 = $3 << 2;
                          (wasm2js_i32$0 = $8 + $5 | 0, wasm2js_f32$0 = Math_fround(cos(+($7 | 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                          (wasm2js_i32$0 = $6 + $8 | 0, wasm2js_f32$0 = Math_fround(cos(+($7 - 1 | 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                          $7 = $7 - 2 | 0;
                          $3 = $3 + 2 | 0;
                          if (($4 | 0) != ($3 | 0)) {
                           continue
                          }
                          break;
                         };
                        }
                        $3 = $4;
                       }
                       if (($1 | 0) > ($3 | 0)) {
                        break block2565
                       }
                       break block2664;
                      }
                      $17 = +($4 >>> 0) * 3.141592653589793;
                     }
                     if (!$10) {
                      break block10
                     }
                     (wasm2js_i32$0 = ($3 << 2) + $5 | 0, wasm2js_f32$0 = Math_fround(cos($17 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                     $3 = $3 + 1 | 0;
                    }
                    $4 = $9 - $7 | 0;
                    $6 = ($1 | 0) > ($4 | 0) ? $4 : $1;
                    if (($3 | 0) < ($6 | 0)) {
                     $4 = $3;
                     $10 = $6 - $3 & 7;
                     if ($10) {
                      $8 = 0;
                      while (1) {
                       HEAP32[($4 << 2) + $5 >> 2] = 1065353216;
                       $4 = $4 + 1 | 0;
                       $8 = $8 + 1 | 0;
                       if (($10 | 0) != ($8 | 0)) {
                        continue
                       }
                       break;
                      };
                     }
                     if ($3 - $6 >>> 0 <= 4294967288) {
                      $8 = $5 + 28 | 0;
                      $10 = $5 + 24 | 0;
                      $13 = $5 + 20 | 0;
                      $12 = $5 + 16 | 0;
                      $19 = $5 + 12 | 0;
                      $18 = $5 + 8 | 0;
                      $22 = $5 + 4 | 0;
                      while (1) {
                       $3 = $4 << 2;
                       HEAP32[$3 + $5 >> 2] = 1065353216;
                       HEAP32[$3 + $22 >> 2] = 1065353216;
                       HEAP32[$3 + $18 >> 2] = 1065353216;
                       HEAP32[$3 + $19 >> 2] = 1065353216;
                       HEAP32[$3 + $12 >> 2] = 1065353216;
                       HEAP32[$3 + $13 >> 2] = 1065353216;
                       HEAP32[$3 + $10 >> 2] = 1065353216;
                       HEAP32[$3 + $8 >> 2] = 1065353216;
                       $4 = $4 + 8 | 0;
                       if (($6 | 0) != ($4 | 0)) {
                        continue
                       }
                       break;
                      };
                     }
                     $3 = $6;
                    }
                    $4 = ($1 | 0) > ($9 | 0) ? $9 : $1;
                    if (($3 | 0) < ($4 | 0)) {
                     $6 = $3 + 1 | 0;
                     $11 = +($7 | 0);
                     if ($4 - $3 & 1) {
                      (wasm2js_i32$0 = ($3 << 2) + $5 | 0, wasm2js_f32$0 = Math_fround(cos($11 * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                      $7 = $7 - 1 | 0;
                      $3 = $6;
                     }
                     if (($4 | 0) != ($6 | 0)) {
                      $6 = $5 + 4 | 0;
                      while (1) {
                       $8 = $3 << 2;
                       (wasm2js_i32$0 = $8 + $5 | 0, wasm2js_f32$0 = Math_fround(cos(+($7 | 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                       (wasm2js_i32$0 = $6 + $8 | 0, wasm2js_f32$0 = Math_fround(cos(+($7 - 1 | 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                       $7 = $7 - 2 | 0;
                       $3 = $3 + 2 | 0;
                       if (($4 | 0) != ($3 | 0)) {
                        continue
                       }
                       break;
                      };
                     }
                     $3 = $4;
                    }
                    if (($1 | 0) > ($3 | 0)) {
                     break block2565
                    }
                    break block2664;
                   }
                   $17 = +($4 >>> 0) * 3.141592653589793;
                  }
                  if (!$10) {
                   break block366
                  }
                  (wasm2js_i32$0 = ($3 << 2) + $5 | 0, wasm2js_f32$0 = Math_fround(cos($17 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                  $3 = $3 + 1 | 0;
                 }
                 $4 = $9 - $7 | 0;
                 $6 = ($1 | 0) > ($4 | 0) ? $4 : $1;
                 if (($3 | 0) < ($6 | 0)) {
                  $4 = $3;
                  $10 = $6 - $3 & 7;
                  if ($10) {
                   $8 = 0;
                   while (1) {
                    HEAP32[($4 << 2) + $5 >> 2] = 1065353216;
                    $4 = $4 + 1 | 0;
                    $8 = $8 + 1 | 0;
                    if (($10 | 0) != ($8 | 0)) {
                     continue
                    }
                    break;
                   };
                  }
                  if ($3 - $6 >>> 0 <= 4294967288) {
                   $8 = $5 + 28 | 0;
                   $10 = $5 + 24 | 0;
                   $13 = $5 + 20 | 0;
                   $12 = $5 + 16 | 0;
                   $19 = $5 + 12 | 0;
                   $18 = $5 + 8 | 0;
                   $22 = $5 + 4 | 0;
                   while (1) {
                    $3 = $4 << 2;
                    HEAP32[$3 + $5 >> 2] = 1065353216;
                    HEAP32[$3 + $22 >> 2] = 1065353216;
                    HEAP32[$3 + $18 >> 2] = 1065353216;
                    HEAP32[$3 + $19 >> 2] = 1065353216;
                    HEAP32[$3 + $12 >> 2] = 1065353216;
                    HEAP32[$3 + $13 >> 2] = 1065353216;
                    HEAP32[$3 + $10 >> 2] = 1065353216;
                    HEAP32[$3 + $8 >> 2] = 1065353216;
                    $4 = $4 + 8 | 0;
                    if (($6 | 0) != ($4 | 0)) {
                     continue
                    }
                    break;
                   };
                  }
                  $3 = $6;
                 }
                 $4 = ($1 | 0) > ($9 | 0) ? $9 : $1;
                 if (($3 | 0) < ($4 | 0)) {
                  $6 = $3 + 1 | 0;
                  $11 = +($7 | 0);
                  if ($4 - $3 & 1) {
                   (wasm2js_i32$0 = ($3 << 2) + $5 | 0, wasm2js_f32$0 = Math_fround(cos($11 * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                   $7 = $7 - 1 | 0;
                   $3 = $6;
                  }
                  if (($4 | 0) != ($6 | 0)) {
                   $6 = $5 + 4 | 0;
                   while (1) {
                    $8 = $3 << 2;
                    (wasm2js_i32$0 = $8 + $5 | 0, wasm2js_f32$0 = Math_fround(cos(+($7 | 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                    (wasm2js_i32$0 = $6 + $8 | 0, wasm2js_f32$0 = Math_fround(cos(+($7 - 1 | 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                    $7 = $7 - 2 | 0;
                    $3 = $3 + 2 | 0;
                    if (($4 | 0) != ($3 | 0)) {
                     continue
                    }
                    break;
                   };
                  }
                  $3 = $4;
                 }
                 if (($1 | 0) <= ($3 | 0)) {
                  break block2664
                 }
                }
                $4 = $1 - $3 << 2;
                if (!$4) {
                 break block2664
                }
                wasm2js_memory_fill(($3 << 2) + $5 | 0, 0, $4);
               }
               break block2916;
              case 15:
               $6 = $3;
               $14 = HEAPF32[$7 + 4 >> 2];
               $30 = HEAPF32[$7 + 8 >> 2];
               $28 = HEAPF32[$7 + 12 >> 2];
               $5 = 0;
               $7 = 0;
               while (1) {
                $15 = $14;
                $14 = Math_fround(.05000000074505806);
                if ($15 <= Math_fround(0.0)) {
                 continue
                }
                $14 = Math_fround(.949999988079071);
                if ($15 >= Math_fround(1.0)) {
                 continue
                }
                break;
               };
               $14 = Math_fround($1 | 0);
               $28 = Math_fround($28 * $14);
               if (Math_fround(Math_abs($28)) < Math_fround(2147483648.0)) {
                $9 = ~~$28
               } else {
                $9 = -2147483648
               }
               $13 = $1 - $9 | 0;
               $15 = Math_fround($15 * Math_fround(.5));
               $14 = Math_fround($30 * $14);
               if (Math_fround(Math_abs($14)) < Math_fround(2147483648.0)) {
                $10 = ~~$14
               } else {
                $10 = -2147483648
               }
               $14 = Math_fround($15 * Math_fround($10 | 0));
               if (Math_fround(Math_abs($14)) < Math_fround(2147483648.0)) {
                $8 = ~~$14
               } else {
                $8 = -2147483648
               }
               $3 = ($1 | 0) > ($8 | 0) ? $8 : $1;
               block185 : {
                if (($3 | 0) <= 0) {
                 $3 = 0;
                 break block185;
                }
                $12 = $3 & 1;
                $11 = +($8 | 0);
                if (($3 | 0) == 1) {
                 $17 = 3.141592653589793
                } else {
                 $19 = $3 & 2147483646;
                 $4 = 1;
                 while (1) {
                  $18 = ($5 << 2) + $6 | 0;
                  (wasm2js_i32$0 = $18, wasm2js_f32$0 = Math_fround(cos(+($4 >>> 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                  (wasm2js_i32$0 = $18 + 4 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 + 1 >>> 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                  $4 = $4 + 2 | 0;
                  $5 = $5 + 2 | 0;
                  $7 = $7 + 2 | 0;
                  if (($19 | 0) != ($7 | 0)) {
                   continue
                  }
                  break;
                 };
                 $17 = +($4 >>> 0) * 3.141592653589793;
                }
                if (!$12) {
                 break block185
                }
                (wasm2js_i32$0 = ($5 << 2) + $6 | 0, wasm2js_f32$0 = Math_fround(cos($17 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
               }
               $4 = $10 - $8 | 0;
               $7 = ($1 | 0) > ($4 | 0) ? $4 : $1;
               if (($3 | 0) < ($7 | 0)) {
                $5 = $3;
                $12 = $7 - $3 & 7;
                if ($12) {
                 $4 = 0;
                 while (1) {
                  HEAP32[($5 << 2) + $6 >> 2] = 1065353216;
                  $5 = $5 + 1 | 0;
                  $4 = $4 + 1 | 0;
                  if (($12 | 0) != ($4 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                if ($3 - $7 >>> 0 <= 4294967288) {
                 $4 = $6 + 28 | 0;
                 $12 = $6 + 24 | 0;
                 $19 = $6 + 20 | 0;
                 $18 = $6 + 16 | 0;
                 $22 = $6 + 12 | 0;
                 $20 = $6 + 8 | 0;
                 $24 = $6 + 4 | 0;
                 while (1) {
                  $3 = $5 << 2;
                  HEAP32[$3 + $6 >> 2] = 1065353216;
                  HEAP32[$3 + $24 >> 2] = 1065353216;
                  HEAP32[$3 + $20 >> 2] = 1065353216;
                  HEAP32[$3 + $22 >> 2] = 1065353216;
                  HEAP32[$3 + $18 >> 2] = 1065353216;
                  HEAP32[$3 + $19 >> 2] = 1065353216;
                  HEAP32[$3 + $12 >> 2] = 1065353216;
                  HEAP32[$3 + $4 >> 2] = 1065353216;
                  $5 = $5 + 8 | 0;
                  if (($7 | 0) != ($5 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                $3 = $7;
               }
               $4 = ($1 | 0) > ($10 | 0) ? $10 : $1;
               if (($3 | 0) < ($4 | 0)) {
                $5 = $3 + 1 | 0;
                $11 = +($8 | 0);
                if ($4 - $3 & 1) {
                 (wasm2js_i32$0 = ($3 << 2) + $6 | 0, wasm2js_f32$0 = Math_fround(cos($11 * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 $8 = $8 - 1 | 0;
                 $3 = $5;
                }
                if (($4 | 0) != ($5 | 0)) {
                 $5 = $6 + 4 | 0;
                 while (1) {
                  $7 = $3 << 2;
                  (wasm2js_i32$0 = $7 + $6 | 0, wasm2js_f32$0 = Math_fround(cos(+($8 | 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                  (wasm2js_i32$0 = $5 + $7 | 0, wasm2js_f32$0 = Math_fround(cos(+($8 - 1 | 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                  $8 = $8 - 2 | 0;
                  $3 = $3 + 2 | 0;
                  if (($4 | 0) != ($3 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                $3 = $4;
               }
               $14 = Math_fround($15 * Math_fround($13 | 0));
               $8 = Math_fround(Math_abs($14)) < Math_fround(2147483648.0) ? ~~$14 : -2147483648;
               $4 = ($1 | 0) > ($9 | 0) ? $9 : $1;
               block1191 : {
                if (($3 | 0) >= ($4 | 0)) {
                 $4 = $3;
                 break block1191;
                }
                $5 = $4 - $3 << 2;
                if (!$5) {
                 break block1191
                }
                wasm2js_memory_fill(($3 << 2) + $6 | 0, 0, $5);
               }
               $3 = $8 + $9 | 0;
               $3 = ($1 | 0) > ($3 | 0) ? $3 : $1;
               block1292 : {
                if (($3 | 0) <= ($4 | 0)) {
                 break block1292
                }
                $5 = $3 - $4 | 0;
                $7 = $5 & 1;
                $11 = +($8 | 0);
                if (($4 + 1 | 0) == ($3 | 0)) {
                 $17 = 3.141592653589793
                } else {
                 $9 = $6 + 4 | 0;
                 $10 = $5 & -2;
                 $3 = 0;
                 $5 = 1;
                 while (1) {
                  $13 = $4 << 2;
                  (wasm2js_i32$0 = $13 + $6 | 0, wasm2js_f32$0 = Math_fround(cos(+($5 >>> 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                  (wasm2js_i32$0 = $9 + $13 | 0, wasm2js_f32$0 = Math_fround(cos(+($5 + 1 >>> 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                  $5 = $5 + 2 | 0;
                  $4 = $4 + 2 | 0;
                  $3 = $3 + 2 | 0;
                  if (($10 | 0) != ($3 | 0)) {
                   continue
                  }
                  break;
                 };
                 $17 = +($5 >>> 0) * 3.141592653589793;
                }
                if (!$7) {
                 break block1292
                }
                (wasm2js_i32$0 = ($4 << 2) + $6 | 0, wasm2js_f32$0 = Math_fround(cos($17 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                $4 = $4 + 1 | 0;
               }
               $3 = $1 - $8 | 0;
               $7 = ($1 | 0) > ($3 | 0) ? $3 : $1;
               if (($4 | 0) < ($7 | 0)) {
                $5 = $4;
                $9 = $7 - $4 & 7;
                if ($9) {
                 $3 = 0;
                 while (1) {
                  HEAP32[($5 << 2) + $6 >> 2] = 1065353216;
                  $5 = $5 + 1 | 0;
                  $3 = $3 + 1 | 0;
                  if (($9 | 0) != ($3 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                if ($4 - $7 >>> 0 <= 4294967288) {
                 $4 = $6 + 28 | 0;
                 $9 = $6 + 24 | 0;
                 $10 = $6 + 20 | 0;
                 $13 = $6 + 16 | 0;
                 $12 = $6 + 12 | 0;
                 $19 = $6 + 8 | 0;
                 $18 = $6 + 4 | 0;
                 while (1) {
                  $3 = $5 << 2;
                  HEAP32[$3 + $6 >> 2] = 1065353216;
                  HEAP32[$3 + $18 >> 2] = 1065353216;
                  HEAP32[$3 + $19 >> 2] = 1065353216;
                  HEAP32[$3 + $12 >> 2] = 1065353216;
                  HEAP32[$3 + $13 >> 2] = 1065353216;
                  HEAP32[$3 + $10 >> 2] = 1065353216;
                  HEAP32[$3 + $9 >> 2] = 1065353216;
                  HEAP32[$3 + $4 >> 2] = 1065353216;
                  $5 = $5 + 8 | 0;
                  if (($7 | 0) != ($5 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                $4 = $7;
               }
               block1896 : {
                if (($1 | 0) <= ($4 | 0)) {
                 break block1896
                }
                $3 = $4 + 1 | 0;
                $11 = +($8 | 0);
                if ($1 - $4 & 1) {
                 (wasm2js_i32$0 = ($4 << 2) + $6 | 0, wasm2js_f32$0 = Math_fround(cos($11 * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 $8 = $8 - 1 | 0;
                 $4 = $3;
                }
                if (($1 | 0) == ($3 | 0)) {
                 break block1896
                }
                $3 = $6 + 4 | 0;
                while (1) {
                 $5 = $4 << 2;
                 (wasm2js_i32$0 = $5 + $6 | 0, wasm2js_f32$0 = Math_fround(cos(+($8 | 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 (wasm2js_i32$0 = $3 + $5 | 0, wasm2js_f32$0 = Math_fround(cos(+($8 - 1 | 0) * 3.141592653589793 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                 $8 = $8 - 2 | 0;
                 $4 = $4 + 2 | 0;
                 if (($4 | 0) != ($1 | 0)) {
                  continue
                 }
                 break;
                };
               }
               break block2916;
              case 16:
               $4 = 0;
               block98 : {
                if (($1 | 0) <= 0) {
                 break block98
                }
                $11 = +($1 - 1 | 0) * .5;
                if (($1 | 0) != 1) {
                 $6 = $1 & 2147483646;
                 $5 = 0;
                 while (1) {
                  $17 = (+($4 >>> 0) - $11) / $11;
                  HEAPF32[($4 << 2) + $3 >> 2] = 1.0 - $17 * $17;
                  $7 = $4 | 1;
                  $17 = (+($7 >>> 0) - $11) / $11;
                  HEAPF32[($7 << 2) + $3 >> 2] = 1.0 - $17 * $17;
                  $4 = $4 + 2 | 0;
                  $5 = $5 + 2 | 0;
                  if (($6 | 0) != ($5 | 0)) {
                   continue
                  }
                  break;
                 };
                }
                if (!($1 & 1)) {
                 break block98
                }
                $11 = (+($4 >>> 0) - $11) / $11;
                HEAPF32[($4 << 2) + $3 >> 2] = 1.0 - $11 * $11;
               }
               break block2916;
              default:
               break block2016;
              };
             }
             $4 = 0;
             block100 : {
              if (($1 | 0) <= 0) {
               break block100
              }
              $11 = +($1 - 1 >>> 0);
              if (($1 | 0) != 1) {
               $6 = $1 & 2147483646;
               $5 = 0;
               while (1) {
                (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 >>> 0) * 6.283185307179586 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                $7 = $4 | 1;
                (wasm2js_i32$0 = ($7 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos(+($7 >>> 0) * 6.283185307179586 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
                $4 = $4 + 2 | 0;
                $5 = $5 + 2 | 0;
                if (($6 | 0) != ($5 | 0)) {
                 continue
                }
                break;
               };
              }
              if (!($1 & 1)) {
               break block100
              }
              (wasm2js_i32$0 = ($4 << 2) + $3 | 0, wasm2js_f32$0 = Math_fround(cos(+($4 >>> 0) * 6.283185307179586 / $11) * -.5 + .5)), HEAPF32[wasm2js_i32$0 >> 2] = wasm2js_f32$0;
             }
            }
            $2 = $2 + 1 | 0;
            $4 = HEAP32[$0 >> 2];
            if ($2 >>> 0 < HEAPU32[$4 + 40 >> 2]) {
             continue
            }
            break;
           };
           $2 = HEAP32[$0 + 4 >> 2];
          }
          HEAP32[$2 >> 2] = $1;
          $1 = 1;
          break __inlined_func$resize_buffers_$92;
         }
         $5 = $2 << 2;
         $3 = $5 + $3 | 0;
         $6 = FLAC__memory_alloc_aligned_int32_array($4, $3 + 7328 | 0, $3 + 4 | 0);
         $3 = HEAP32[($5 + HEAP32[$0 + 4 >> 2] | 0) + 4 >> 2];
         HEAP32[$3 >> 2] = 0;
         HEAP32[$3 + 4 >> 2] = 0;
         $3 = $3 + 8 | 0;
         HEAP32[$3 >> 2] = 0;
         HEAP32[$3 + 4 >> 2] = 0;
         $3 = HEAP32[$0 + 4 >> 2];
         $5 = $5 + $3 | 0;
         HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] + 16;
         $2 = $2 + 1 | 0;
         if ($6) {
          continue
         }
        }
        break;
       };
       HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
       $1 = 0;
      }
     } else {
      $1 = 1
     }
     if (!$1) {
      break block1
     }
     $1 = HEAP32[HEAP32[$0 + 4 >> 2] + 6856 >> 2];
     HEAP32[$1 + 16 >> 2] = 0;
     HEAP32[$1 + 8 >> 2] = 8192;
     HEAP32[$1 + 12 >> 2] = 0;
     $2 = $1;
     $1 = emscripten_builtin_malloc(32768);
     HEAP32[$2 >> 2] = $1;
     $2 = HEAP32[$0 >> 2];
     if (!$1) {
      HEAP32[$2 >> 2] = 8;
      break block1;
     }
     if (HEAP32[$2 + 4 >> 2]) {
      $8 = HEAP32[$0 + 4 >> 2];
      HEAP32[$8 + 11796 >> 2] = HEAP32[$2 + 36 >> 2] + 1;
      block57 : {
       if (!HEAP32[$2 + 24 >> 2]) {
        break block57
       }
       $2 = 0;
       while (1) {
        block58103 : {
         $1 = safe_malloc_mul_2op_p(4, HEAP32[$8 + 11796 >> 2]);
         $8 = HEAP32[$0 + 4 >> 2];
         HEAP32[($8 + ($2 << 2) | 0) + 11764 >> 2] = $1;
         if (!$1) {
          break block58103
         }
         $2 = $2 + 1 | 0;
         if ($2 >>> 0 < HEAPU32[HEAP32[$0 >> 2] + 24 >> 2]) {
          continue
         }
         break block57;
        }
        break;
       };
       HEAP32[HEAP32[$0 >> 2] >> 2] = 8;
       break block1;
      }
      HEAP32[$8 + 11800 >> 2] = 0;
      block59 : {
       $2 = HEAP32[$8 + 11752 >> 2];
       if ($2) {
        break block59
       }
       $2 = FLAC__stream_decoder_new();
       HEAP32[HEAP32[$0 + 4 >> 2] + 11752 >> 2] = $2;
       if ($2) {
        break block59
       }
       HEAP32[HEAP32[$0 >> 2] >> 2] = 3;
       break block1;
      }
      $1 = FLAC__stream_decoder_init_stream($2, 19, 0, 0, 0, 0, 20, 21, 22, $0);
      $2 = HEAP32[$0 >> 2];
      if ($1) {
       break block60
      }
      $3 = !HEAP32[$2 + 4 >> 2];
     } else {
      $3 = 1
     }
     $1 = HEAP32[$0 + 4 >> 2];
     HEAP32[$1 + 11816 >> 2] = 0;
     HEAP32[$1 + 11820 >> 2] = 0;
     HEAP32[$1 + 7312 >> 2] = 0;
     HEAP32[$1 + 7316 >> 2] = 0;
     HEAP32[$1 + 7292 >> 2] = 0;
     $4 = $1 + 11824 | 0;
     HEAP32[$4 >> 2] = 0;
     HEAP32[$4 + 4 >> 2] = 0;
     $4 = $1 + 11832 | 0;
     HEAP32[$4 >> 2] = 0;
     HEAP32[$4 + 4 >> 2] = 0;
     HEAP32[$1 + 11840 >> 2] = 0;
     $4 = $2 + 624 | 0;
     HEAP32[$4 >> 2] = 0;
     HEAP32[$4 + 4 >> 2] = 0;
     $4 = $2 + 616 | 0;
     HEAP32[$4 >> 2] = 0;
     HEAP32[$4 + 4 >> 2] = 0;
     HEAP32[$2 + 608 >> 2] = 0;
     HEAP32[$2 + 612 >> 2] = 0;
     if (!$3) {
      HEAP32[$1 + 11756 >> 2] = 0
     }
     if (!FLAC__bitwriter_write_raw_uint32(HEAP32[$1 + 6856 >> 2], HEAP32[1631], HEAP32[1632])) {
      HEAP32[HEAP32[$0 >> 2] >> 2] = 7;
      break block1;
     }
     if (!write_bitbuffer_($0, 0, 0)) {
      break block1
     }
     $1 = HEAP32[$0 + 4 >> 2];
     $2 = HEAP32[$0 >> 2];
     if (HEAP32[$2 + 4 >> 2]) {
      HEAP32[$1 + 11756 >> 2] = 1
     }
     HEAP32[$1 + 6880 >> 2] = 34;
     HEAP32[$1 + 6872 >> 2] = 0;
     HEAP32[$1 + 6876 >> 2] = 0;
     HEAP32[$1 + 6888 >> 2] = HEAP32[$2 + 36 >> 2];
     HEAP32[HEAP32[$0 + 4 >> 2] + 6892 >> 2] = HEAP32[HEAP32[$0 >> 2] + 36 >> 2];
     HEAP32[HEAP32[$0 + 4 >> 2] + 6896 >> 2] = 0;
     HEAP32[HEAP32[$0 + 4 >> 2] + 6900 >> 2] = 0;
     HEAP32[HEAP32[$0 + 4 >> 2] + 6904 >> 2] = HEAP32[HEAP32[$0 >> 2] + 32 >> 2];
     HEAP32[HEAP32[$0 + 4 >> 2] + 6908 >> 2] = HEAP32[HEAP32[$0 >> 2] + 24 >> 2];
     HEAP32[HEAP32[$0 + 4 >> 2] + 6912 >> 2] = HEAP32[HEAP32[$0 >> 2] + 28 >> 2];
     $1 = HEAP32[$0 >> 2];
     $2 = HEAP32[$1 + 596 >> 2];
     $3 = HEAP32[$0 + 4 >> 2];
     HEAP32[$3 + 6920 >> 2] = HEAP32[$1 + 592 >> 2];
     HEAP32[$3 + 6924 >> 2] = $2;
     $1 = HEAP32[$0 + 4 >> 2];
     HEAP32[$1 + 6928 >> 2] = 0;
     HEAP32[$1 + 6932 >> 2] = 0;
     $1 = $1 + 6936 | 0;
     HEAP32[$1 >> 2] = 0;
     HEAP32[$1 + 4 >> 2] = 0;
     if (HEAP32[HEAP32[$0 >> 2] + 12 >> 2]) {
      FLAC__MD5Init(HEAP32[$0 + 4 >> 2] + 7060 | 0)
     }
     $1 = HEAP32[$0 + 4 >> 2];
     if (!FLAC__add_metadata_block($1 + 6872 | 0, HEAP32[$1 + 6856 >> 2])) {
      HEAP32[HEAP32[$0 >> 2] >> 2] = 7;
      break block1;
     }
     if (!write_bitbuffer_($0, 0, 0)) {
      break block1
     }
     HEAP32[HEAP32[$0 + 4 >> 2] + 6896 >> 2] = -1 << HEAP32[1635] ^ -1;
     $1 = HEAP32[$0 + 4 >> 2];
     HEAP32[$1 + 6920 >> 2] = 0;
     HEAP32[$1 + 6924 >> 2] = 0;
     if ($29) {
      HEAP32[$25 >> 2] = 4;
      $1 = HEAP32[HEAP32[$0 >> 2] + 604 >> 2];
      $2 = $25 + 24 | 0;
      HEAP32[$2 >> 2] = 0;
      HEAP32[$2 + 4 >> 2] = 0;
      HEAP32[$25 + 16 >> 2] = 0;
      HEAP32[$25 + 20 >> 2] = 0;
      HEAP32[$25 + 8 >> 2] = 8;
      HEAP32[$25 + 4 >> 2] = !$1;
      if (!FLAC__add_metadata_block($25, HEAP32[HEAP32[$0 + 4 >> 2] + 6856 >> 2])) {
       HEAP32[HEAP32[$0 >> 2] >> 2] = 7;
       break block1;
      }
      if (!write_bitbuffer_($0, 0, 0)) {
       break block1
      }
     }
     block68 : {
      $2 = HEAP32[$0 >> 2];
      $8 = HEAP32[$2 + 604 >> 2];
      if (!$8) {
       break block68
      }
      $16 = 0;
      while (1) {
       $1 = HEAP32[HEAP32[$2 + 600 >> 2] + ($16 << 2) >> 2];
       HEAP32[$1 + 4 >> 2] = ($8 - 1 | 0) == ($16 | 0);
       if (!FLAC__add_metadata_block($1, HEAP32[HEAP32[$0 + 4 >> 2] + 6856 >> 2])) {
        HEAP32[HEAP32[$0 >> 2] >> 2] = 7;
        $16 = 1;
        break block1;
       }
       if (write_bitbuffer_($0, 0, 0)) {
        $2 = HEAP32[$0 >> 2];
        $8 = HEAP32[$2 + 604 >> 2];
        $16 = $16 + 1 | 0;
        if ($8 >>> 0 <= $16 >>> 0) {
         break block68
        }
        continue;
       }
       break;
      };
      $16 = 1;
      break block1;
     }
     block71 : {
      $1 = HEAP32[$0 + 4 >> 2];
      $3 = HEAP32[$1 + 7272 >> 2];
      if (!$3) {
       break block71
      }
      $16 = 1;
      $1 = FUNCTION_TABLE[$3 | 0]($0, $2 + 624 | 0, HEAP32[$1 + 7288 >> 2]) | 0;
      $2 = HEAP32[$0 >> 2];
      if (($1 | 0) != 1) {
       break block71
      }
      HEAP32[$2 >> 2] = 5;
      break block1;
     }
     $16 = 0;
     if (!HEAP32[$2 + 4 >> 2]) {
      break block1
     }
     HEAP32[HEAP32[$0 + 4 >> 2] + 11756 >> 2] = 2;
     break block1;
    }
    HEAP32[HEAP32[$0 >> 2] >> 2] = 2;
    break block1;
   }
   HEAP32[$2 >> 2] = 3;
  }
  __stack_pointer = $25 + 176 | 0;
  return $16;
 }
 
 function precompute_partition_info_sums_($0, $1, $2, $3, $4, $5, $6) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  $6 = $6 | 0;
  var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
  $15 = 0 - $3 | 0;
  $13 = 1 << $5;
  $10 = $2 + $3 >>> $5 | 0;
  $9 = $10 - $3 | 0;
  block4 : {
   if ($6 + 4 >>> 0 >= 32 - (Math_clz32($10) ^ 31) >>> 0) {
    $11 = $0 + 4 | 0;
    $12 = ($3 ^ -1) + $10 | 0;
    while (1) {
     $7 = 0;
     $3 = 0;
     $15 = $10 + $15 | 0;
     block1 : {
      if ($15 >>> 0 <= $8 >>> 0) {
       break block1
      }
      $2 = $9 - $8 | 0;
      $17 = $2 & 1;
      block3 : {
       if (($8 | 0) == ($12 + Math_imul($10, $14) | 0)) {
        $6 = $8;
        break block3;
       }
       $18 = $2 & -2;
       $2 = 0;
       $6 = $8;
       while (1) {
        $16 = $6 << 2;
        $19 = HEAP32[$16 + $0 >> 2];
        $8 = $19 >> 31;
        $8 = ($8 ^ $19) - $8 | 0;
        $7 = $7 + $8 | 0;
        $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
        $16 = HEAP32[$11 + $16 >> 2];
        $8 = $16 >> 31;
        $8 = ($8 ^ $16) - $8 | 0;
        $7 = $7 + $8 | 0;
        $3 = $8 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
        $6 = $6 + 2 | 0;
        $2 = $2 + 2 | 0;
        if (($18 | 0) != ($2 | 0)) {
         continue
        }
        break;
       };
      }
      $8 = $9;
      if (!$17) {
       break block1
      }
      $6 = HEAP32[($6 << 2) + $0 >> 2];
      $2 = $6 >> 31;
      $2 = ($2 ^ $6) - $2 | 0;
      $7 = $2 + $7 | 0;
      $3 = $2 >>> 0 > $7 >>> 0 ? $3 + 1 | 0 : $3;
     }
     $2 = ($14 << 3) + $1 | 0;
     HEAP32[$2 >> 2] = $7;
     HEAP32[$2 + 4 >> 2] = $3;
     $9 = $9 + $10 | 0;
     $14 = $14 + 1 | 0;
     if (($14 | 0) != ($13 | 0)) {
      continue
     }
     break;
    };
    break block4;
   }
   $19 = $0 + 12 | 0;
   $24 = $0 + 8 | 0;
   $25 = $0 + 4 | 0;
   $6 = 0;
   while (1) {
    $7 = 0;
    $15 = $10 + $15 | 0;
    if ($6 >>> 0 < $15 >>> 0) {
     $2 = $9 - $6 | 0;
     $14 = $2 & 3;
     $11 = 0;
     block7 : {
      if ((Math_imul($8 ^ -1, $10) + $3 | 0) + $6 >>> 0 > 4294967292) {
       $2 = 0;
       break block7;
      }
      $26 = $2 & -4;
      $2 = 0;
      $12 = 0;
      while (1) {
       $7 = $6 << 2;
       $20 = HEAP32[$7 + $19 >> 2];
       $17 = $20 >> 31;
       $21 = HEAP32[$7 + $24 >> 2];
       $18 = $21 >> 31;
       $22 = HEAP32[$7 + $25 >> 2];
       $16 = $22 >> 31;
       $23 = HEAP32[$0 + $7 >> 2];
       $7 = $23 >> 31;
       $2 = (($7 ^ $23) - $7 | 0) + $2 + (($16 ^ $22) - $16) + (($18 ^ $21) - $18) + (($17 ^ $20) - $17) | 0;
       $6 = $6 + 4 | 0;
       $12 = $12 + 4 | 0;
       if (($26 | 0) != ($12 | 0)) {
        continue
       }
       break;
      };
     }
     if ($14) {
      while (1) {
       $12 = HEAP32[($6 << 2) + $0 >> 2];
       $7 = $12 >> 31;
       $2 = (($7 ^ $12) - $7 | 0) + $2 | 0;
       $6 = $6 + 1 | 0;
       $11 = $11 + 1 | 0;
       if (($14 | 0) != ($11 | 0)) {
        continue
       }
       break;
      }
     }
     $7 = $2;
     $6 = $9;
    }
    $2 = ($8 << 3) + $1 | 0;
    HEAP32[$2 >> 2] = $7;
    HEAP32[$2 + 4 >> 2] = 0;
    $9 = $9 + $10 | 0;
    $8 = $8 + 1 | 0;
    if (($8 | 0) != ($13 | 0)) {
     continue
    }
    break;
   };
  }
  if (($4 | 0) < ($5 | 0)) {
   $15 = $1 + 8 | 0;
   $2 = 0;
   $0 = $13;
   while (1) {
    $3 = $0;
    $0 = $3 >>> 1 | 0;
    block10 : {
     if ($3 >>> 0 < 2) {
      break block10
     }
     if (($0 | 0) != 1) {
      $14 = $0 & 2147483646;
      $8 = 0;
      while (1) {
       $6 = ($2 << 3) + $1 | 0;
       $7 = $6 + 8 | 0;
       $12 = HEAP32[$6 >> 2];
       $10 = HEAP32[$7 >> 2] + $12 | 0;
       $7 = HEAP32[$7 + 4 >> 2] + HEAP32[$6 + 4 >> 2] | 0;
       $11 = $13 << 3;
       $9 = $11 + $1 | 0;
       HEAP32[$9 >> 2] = $10;
       HEAP32[$9 + 4 >> 2] = $10 >>> 0 < $12 >>> 0 ? $7 + 1 | 0 : $7;
       $7 = $11 + $15 | 0;
       $10 = $6 + 24 | 0;
       $6 = $6 + 16 | 0;
       $11 = HEAP32[$6 >> 2];
       $9 = HEAP32[$10 >> 2] + $11 | 0;
       $6 = HEAP32[$10 + 4 >> 2] + HEAP32[$6 + 4 >> 2] | 0;
       HEAP32[$7 >> 2] = $9;
       HEAP32[$7 + 4 >> 2] = $9 >>> 0 < $11 >>> 0 ? $6 + 1 | 0 : $6;
       $2 = $2 + 4 | 0;
       $13 = $13 + 2 | 0;
       $8 = $8 + 2 | 0;
       if (($14 | 0) != ($8 | 0)) {
        continue
       }
       break;
      };
     }
     if (!($3 & 2)) {
      break block10
     }
     $3 = ($2 << 3) + $1 | 0;
     $7 = $3 + 8 | 0;
     $9 = HEAP32[$3 >> 2];
     $8 = HEAP32[$7 >> 2] + $9 | 0;
     $3 = HEAP32[$7 + 4 >> 2] + HEAP32[$3 + 4 >> 2] | 0;
     $6 = ($13 << 3) + $1 | 0;
     HEAP32[$6 >> 2] = $8;
     HEAP32[$6 + 4 >> 2] = $8 >>> 0 < $9 >>> 0 ? $3 + 1 | 0 : $3;
     $2 = $2 + 2 | 0;
     $13 = $13 + 1 | 0;
    }
    $5 = $5 - 1 | 0;
    if (($5 | 0) > ($4 | 0)) {
     continue
    }
    break;
   };
  }
 }
 
 function verify_read_callback_($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0;
  $5 = HEAP32[$3 + 4 >> 2];
  if (HEAP32[$5 + 11760 >> 2]) {
   HEAP32[$2 >> 2] = 4;
   $0 = HEAPU8[6517] | HEAPU8[6518] << 8 | (HEAPU8[6519] << 16 | HEAPU8[6520] << 24);
   HEAP8[$1 | 0] = $0;
   HEAP8[$1 + 1 | 0] = $0 >>> 8;
   HEAP8[$1 + 2 | 0] = $0 >>> 16;
   HEAP8[$1 + 3 | 0] = $0 >>> 24;
   HEAP32[HEAP32[$3 + 4 >> 2] + 11760 >> 2] = 0;
   return 0;
  }
  $0 = HEAP32[$5 + 11812 >> 2];
  if (!$0) {
   return 2
  }
  $4 = HEAP32[$2 >> 2];
  if ($0 >>> 0 < $4 >>> 0) {
   HEAP32[$2 >> 2] = $0;
   $4 = $0;
  }
  if ($4) {
   wasm2js_memory_copy($1, HEAP32[$5 + 11804 >> 2], $4)
  }
  $0 = HEAP32[$3 + 4 >> 2];
  $1 = HEAP32[$2 >> 2];
  HEAP32[$0 + 11804 >> 2] = $1 + HEAP32[$0 + 11804 >> 2];
  HEAP32[$0 + 11812 >> 2] = HEAP32[$0 + 11812 >> 2] - $1;
  return 0;
 }
 
 function verify_write_callback_($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0;
  $9 = HEAP32[$1 >> 2];
  $0 = HEAP32[$3 + 4 >> 2];
  $7 = HEAP32[$1 + 8 >> 2];
  if (!$7) {
   HEAP32[$0 + 11800 >> 2] = HEAP32[$0 + 11800 >> 2] - $9;
   return 0;
  }
  $4 = $9 << 2;
  $5 = $0 + 11764 | 0;
  while (1) {
   $6 = $8 << 2;
   $10 = HEAP32[$6 + $2 >> 2];
   $6 = HEAP32[$5 + $6 >> 2];
   if (memcmp($10, $6, $4)) {
    $7 = 0;
    block4 : {
     if ($9) {
      $4 = 0;
      while (1) {
       $2 = $4 << 2;
       $5 = HEAP32[$2 + $10 >> 2];
       $2 = HEAP32[$2 + $6 >> 2];
       if (($2 | 0) != ($5 | 0)) {
        $7 = $4;
        break block4;
       }
       $4 = $4 + 1 | 0;
       if (($4 | 0) != ($9 | 0)) {
        continue
       }
       break;
      };
     }
     $2 = 0;
     $5 = 0;
    }
    $4 = HEAP32[$1 + 28 >> 2];
    $6 = HEAP32[$1 + 24 >> 2] + $7 | 0;
    $4 = $6 >>> 0 < $7 >>> 0 ? $4 + 1 | 0 : $4;
    HEAP32[$0 + 11816 >> 2] = $6;
    HEAP32[$0 + 11820 >> 2] = $4;
    $4 = HEAP32[$1 + 28 >> 2];
    $1 = HEAP32[$1 + 24 >> 2];
    HEAP32[$0 + 11840 >> 2] = $5;
    HEAP32[$0 + 11836 >> 2] = $2;
    HEAP32[$0 + 11832 >> 2] = $7;
    HEAP32[$0 + 11828 >> 2] = $8;
    (wasm2js_i32$0 = $0, wasm2js_i32$1 = __wasm_i64_udiv($1, $4, $9)), HEAP32[wasm2js_i32$0 + 11824 >> 2] = wasm2js_i32$1;
    HEAP32[HEAP32[$3 >> 2] >> 2] = 4;
    return 1;
   }
   $8 = $8 + 1 | 0;
   if (($7 | 0) != ($8 | 0)) {
    continue
   }
   break;
  };
  HEAP32[$0 + 11800 >> 2] = HEAP32[$0 + 11800 >> 2] - $9;
  $4 = $7 & 1;
  $8 = 0;
  if (($7 | 0) != 1) {
   $7 = $7 & -2;
   $0 = 0;
   while (1) {
    $1 = $9 << 2;
    $2 = $8 << 2;
    $5 = HEAP32[$3 + 4 >> 2];
    $6 = HEAP32[$5 + 11800 >> 2] << 2;
    if ($6) {
     $5 = HEAP32[($2 + $5 | 0) + 11764 >> 2];
     wasm2js_memory_copy($5, $1 + $5 | 0, $6);
    }
    $5 = HEAP32[$3 + 4 >> 2];
    $6 = HEAP32[$5 + 11800 >> 2] << 2;
    if ($6) {
     $2 = HEAP32[($2 + $5 | 0) + 11768 >> 2];
     wasm2js_memory_copy($2, $1 + $2 | 0, $6);
    }
    $8 = $8 + 2 | 0;
    $0 = $0 + 2 | 0;
    if (($7 | 0) != ($0 | 0)) {
     continue
    }
    break;
   };
  }
  block8 : {
   if (!$4) {
    break block8
   }
   $0 = HEAP32[$3 + 4 >> 2];
   $1 = HEAP32[$0 + 11800 >> 2] << 2;
   if (!$1) {
    break block8
   }
   $0 = HEAP32[($0 + ($8 << 2) | 0) + 11764 >> 2];
   wasm2js_memory_copy($0, $0 + ($9 << 2) | 0, $1);
  }
  return 0;
 }
 
 function verify_metadata_callback_($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
 }
 
 function verify_error_callback_($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  HEAP32[HEAP32[$2 >> 2] >> 2] = 3;
 }
 
 function write_bitbuffer_($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0;
  $13 = __stack_pointer - 16 | 0;
  __stack_pointer = $13;
  $4 = FLAC__bitwriter_get_buffer(HEAP32[HEAP32[$0 + 4 >> 2] + 6856 >> 2], $13 + 4 | 0, $13);
  $6 = HEAP32[$0 >> 2];
  block1 : {
   if (!$4) {
    HEAP32[$6 >> 2] = 8;
    break block1;
   }
   $7 = HEAP32[$0 + 4 >> 2];
   $16 = HEAP32[$13 >> 2];
   $4 = HEAP32[$13 + 4 >> 2];
   block14 : {
    block6 : {
     block7 : {
      block9 : {
       block8 : {
        block4 : {
         block2 : {
          if (!HEAP32[$6 + 4 >> 2]) {
           break block2
          }
          HEAP32[$7 + 11812 >> 2] = $16;
          HEAP32[$7 + 11804 >> 2] = $4;
          if (!HEAP32[$7 + 11756 >> 2]) {
           HEAP32[$7 + 11760 >> 2] = 1;
           break block2;
          }
          if (!FLAC__stream_decoder_process_single(HEAP32[$7 + 11752 >> 2])) {
           break block4
          }
          $7 = HEAP32[$0 + 4 >> 2];
          $16 = HEAP32[$13 >> 2];
          $4 = HEAP32[$13 + 4 >> 2];
         }
         HEAP32[$13 + 8 >> 2] = 0;
         HEAP32[$13 + 12 >> 2] = 0;
         $6 = HEAP32[$7 + 7272 >> 2];
         if ($6) {
          if ((FUNCTION_TABLE[$6 | 0]($0, $13 + 8 | 0, HEAP32[$7 + 7288 >> 2]) | 0) == 1) {
           break block6
          }
         }
         if ($1) {
          break block7
         }
         switch (HEAPU8[$4 | 0] & 127) {
         case 0:
          break block8;
         case 3:
          break block9;
         default:
          break block7;
         };
        }
        FLAC__bitwriter_clear(HEAP32[HEAP32[$0 + 4 >> 2] + 6856 >> 2]);
        $7 = 0;
        $0 = HEAP32[$0 >> 2];
        if (HEAP32[$0 >> 2] == 4) {
         break block1
        }
        HEAP32[$0 >> 2] = 3;
        break block1;
       }
       $7 = HEAP32[$13 + 12 >> 2];
       $6 = HEAP32[$0 >> 2];
       HEAP32[$6 + 608 >> 2] = HEAP32[$13 + 8 >> 2];
       HEAP32[$6 + 612 >> 2] = $7;
       break block7;
      }
      $7 = HEAP32[$0 >> 2];
      if (HEAP32[$7 + 616 >> 2] | HEAP32[$7 + 620 >> 2]) {
       break block7
      }
      $6 = HEAP32[$13 + 12 >> 2];
      HEAP32[$7 + 616 >> 2] = HEAP32[$13 + 8 >> 2];
      HEAP32[$7 + 620 >> 2] = $6;
     }
     $6 = HEAP32[$0 + 4 >> 2];
     $9 = HEAP32[$6 + 7048 >> 2];
     block10 : {
      if (!$9) {
       break block10
      }
      $3 = HEAP32[$0 >> 2];
      $5 = HEAP32[$3 + 624 >> 2];
      $7 = HEAP32[$3 + 628 >> 2];
      $21 = $7;
      if (!($5 | $7)) {
       break block10
      }
      $14 = HEAP32[$9 >> 2];
      if (!$14) {
       break block10
      }
      $7 = HEAP32[$6 + 7292 >> 2];
      if ($14 >>> 0 <= $7 >>> 0) {
       break block10
      }
      $19 = HEAP32[$3 + 36 >> 2];
      $8 = HEAP32[$6 + 7312 >> 2];
      $11 = $19 + $8 | 0;
      $3 = HEAP32[$6 + 7316 >> 2];
      $15 = ($8 >>> 0 > $11 >>> 0 ? $3 + 1 | 0 : $3) - 1 | 0;
      $18 = $11 - 1 | 0;
      $15 = ($18 | 0) != -1 ? $15 + 1 | 0 : $15;
      $20 = HEAP32[$9 + 4 >> 2];
      while (1) {
       $9 = $20 + Math_imul($7, 24) | 0;
       $17 = HEAP32[$9 >> 2];
       $11 = HEAP32[$9 + 4 >> 2];
       if (($15 | 0) == ($11 | 0) & $17 >>> 0 > $18 >>> 0 | $11 >>> 0 > $15 >>> 0) {
        break block10
       }
       if (!(($3 | 0) == ($11 | 0) & $8 >>> 0 > $17 >>> 0 | $3 >>> 0 > $11 >>> 0)) {
        HEAP32[$9 >> 2] = $8;
        HEAP32[$9 + 4 >> 2] = $3;
        $11 = HEAP32[$13 + 8 >> 2];
        $17 = HEAP32[$13 + 12 >> 2];
        HEAP32[$9 + 16 >> 2] = $19;
        HEAP32[$9 + 8 >> 2] = $11 - $5;
        HEAP32[$9 + 12 >> 2] = $17 - ($21 + ($5 >>> 0 > $11 >>> 0) | 0);
       }
       $7 = $7 + 1 | 0;
       HEAP32[$6 + 7292 >> 2] = $7;
       if (($7 | 0) != ($14 | 0)) {
        continue
       }
       break;
      };
     }
     $7 = HEAP32[$6 + 7056 >> 2];
     block13 : {
      if (HEAP32[$6 + 7260 >> 2]) {
       $21 = HEAP32[$6 + 7276 >> 2];
       $19 = HEAP32[$6 + 7288 >> 2];
       $6 = __stack_pointer - 96 | 0;
       __stack_pointer = $6;
       $9 = HEAP32[$0 >> 2] + 632 | 0;
       block70 : {
        block61 : {
         if (HEAP32[$9 + 384 >> 2]) {
          $3 = $6 + 72 | 0;
          HEAP32[$3 >> 2] = 0;
          HEAP32[$3 + 4 >> 2] = 0;
          $3 = $6 + 80 | 0;
          HEAP32[$3 >> 2] = 0;
          HEAP32[$3 + 4 >> 2] = 0;
          $5 = $6 + 88 | 0;
          HEAP32[$5 >> 2] = 0;
          HEAP32[$5 + 4 >> 2] = 0;
          HEAP32[$6 + 64 >> 2] = 0;
          HEAP32[$6 + 68 >> 2] = 0;
          $5 = HEAP32[$9 + 396 >> 2];
          $8 = $5 + 1 | 0;
          $10 = $5;
          $5 = HEAP32[$9 + 392 >> 2] + $1 | 0;
          $8 = $5 >>> 0 < $1 >>> 0 ? $8 : $10;
          HEAP32[$3 >> 2] = $5;
          HEAP32[$3 + 4 >> 2] = $8;
          block22 : {
           block3 : {
            if (HEAP32[$9 + 388 >> 2]) {
             if (($16 | 0) != 38) {
              break block22
             }
             HEAP8[$6 | 0] = HEAPU8[7824];
             $3 = HEAP32[4306];
             $3 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
             HEAP8[$6 + 5 | 0] = 1;
             HEAP8[$6 + 6 | 0] = 0;
             HEAP8[$6 + 1 | 0] = $3;
             HEAP8[$6 + 2 | 0] = $3 >>> 8;
             HEAP8[$6 + 3 | 0] = $3 >>> 16;
             HEAP8[$6 + 4 | 0] = $3 >>> 24;
             $5 = HEAP32[$9 + 4 >> 2];
             $3 = HEAPU8[6517] | HEAPU8[6518] << 8 | (HEAPU8[6519] << 16 | HEAPU8[6520] << 24);
             HEAP8[$6 + 9 | 0] = $3;
             HEAP8[$6 + 10 | 0] = $3 >>> 8;
             HEAP8[$6 + 11 | 0] = $3 >>> 16;
             HEAP8[$6 + 12 | 0] = $3 >>> 24;
             HEAP8[$6 + 8 | 0] = $5;
             HEAP8[$6 + 7 | 0] = $5 >>> 8;
             $3 = $4 + 8 | 0;
             $8 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
             $5 = $6 + 21 | 0;
             $3 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
             HEAP8[$5 | 0] = $3;
             HEAP8[$5 + 1 | 0] = $3 >>> 8;
             HEAP8[$5 + 2 | 0] = $3 >>> 16;
             HEAP8[$5 + 3 | 0] = $3 >>> 24;
             HEAP8[$5 + 4 | 0] = $8;
             HEAP8[$5 + 5 | 0] = $8 >>> 8;
             HEAP8[$5 + 6 | 0] = $8 >>> 16;
             HEAP8[$5 + 7 | 0] = $8 >>> 24;
             $3 = $4 + 16 | 0;
             $8 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
             $5 = $6 + 29 | 0;
             $3 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
             HEAP8[$5 | 0] = $3;
             HEAP8[$5 + 1 | 0] = $3 >>> 8;
             HEAP8[$5 + 2 | 0] = $3 >>> 16;
             HEAP8[$5 + 3 | 0] = $3 >>> 24;
             HEAP8[$5 + 4 | 0] = $8;
             HEAP8[$5 + 5 | 0] = $8 >>> 8;
             HEAP8[$5 + 6 | 0] = $8 >>> 16;
             HEAP8[$5 + 7 | 0] = $8 >>> 24;
             $3 = $4 + 24 | 0;
             $8 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
             $5 = $6 + 37 | 0;
             $3 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
             HEAP8[$5 | 0] = $3;
             HEAP8[$5 + 1 | 0] = $3 >>> 8;
             HEAP8[$5 + 2 | 0] = $3 >>> 16;
             HEAP8[$5 + 3 | 0] = $3 >>> 24;
             HEAP8[$5 + 4 | 0] = $8;
             HEAP8[$5 + 5 | 0] = $8 >>> 8;
             HEAP8[$5 + 6 | 0] = $8 >>> 16;
             HEAP8[$5 + 7 | 0] = $8 >>> 24;
             $3 = $4 + 30 | 0;
             $8 = HEAPU8[$3 + 4 | 0] | HEAPU8[$3 + 5 | 0] << 8 | (HEAPU8[$3 + 6 | 0] << 16 | HEAPU8[$3 + 7 | 0] << 24);
             $5 = $6 + 43 | 0;
             $3 = HEAPU8[$3 | 0] | HEAPU8[$3 + 1 | 0] << 8 | (HEAPU8[$3 + 2 | 0] << 16 | HEAPU8[$3 + 3 | 0] << 24);
             HEAP8[$5 | 0] = $3;
             HEAP8[$5 + 1 | 0] = $3 >>> 8;
             HEAP8[$5 + 2 | 0] = $3 >>> 16;
             HEAP8[$5 + 3 | 0] = $3 >>> 24;
             HEAP8[$5 + 4 | 0] = $8;
             HEAP8[$5 + 5 | 0] = $8 >>> 8;
             HEAP8[$5 + 6 | 0] = $8 >>> 16;
             HEAP8[$5 + 7 | 0] = $8 >>> 24;
             $3 = HEAPU8[$4 + 4 | 0] | HEAPU8[$4 + 5 | 0] << 8 | (HEAPU8[$4 + 6 | 0] << 16 | HEAPU8[$4 + 7 | 0] << 24);
             $4 = HEAPU8[$4 | 0] | HEAPU8[$4 + 1 | 0] << 8 | (HEAPU8[$4 + 2 | 0] << 16 | HEAPU8[$4 + 3 | 0] << 24);
             HEAP8[$6 + 13 | 0] = $4;
             HEAP8[$6 + 14 | 0] = $4 >>> 8;
             HEAP8[$6 + 15 | 0] = $4 >>> 16;
             HEAP8[$6 + 16 | 0] = $4 >>> 24;
             HEAP8[$6 + 17 | 0] = $3;
             HEAP8[$6 + 18 | 0] = $3 >>> 8;
             HEAP8[$6 + 19 | 0] = $3 >>> 16;
             HEAP8[$6 + 20 | 0] = $3 >>> 24;
             HEAP32[$6 + 68 >> 2] = 51;
             HEAP32[$6 + 72 >> 2] = 1;
             HEAP32[$6 + 64 >> 2] = $6;
             HEAP32[$9 + 388 >> 2] = 0;
             break block3;
            }
            HEAP32[$6 + 68 >> 2] = $16;
            HEAP32[$6 + 64 >> 2] = $4;
           }
           if ($2) {
            HEAP32[$6 + 76 >> 2] = 1
           }
           $3 = 0;
           $18 = __stack_pointer - 16 | 0;
           __stack_pointer = $18;
           $2 = $6 - -64 | 0;
           HEAP32[$18 + 8 >> 2] = HEAP32[$2 >> 2];
           HEAP32[$18 + 12 >> 2] = HEAP32[$2 + 4 >> 2];
           $5 = $18 + 8 | 0;
           $28 = HEAP32[$2 + 12 >> 2];
           $24 = HEAP32[$2 + 16 >> 2];
           $25 = HEAP32[$2 + 20 >> 2];
           $4 = 0;
           $8 = -1;
           $2 = $9 + 8 | 0;
           __inlined_func$ogg_stream_iovecin$14 : {
            block : {
             if (!$2) {
              break block
             }
             $11 = HEAP32[$2 >> 2];
             if (!$11) {
              break block
             }
             $10 = 0;
             if (!$5) {
              break __inlined_func$ogg_stream_iovecin$14
             }
             while (1) {
              $14 = HEAP32[(($4 << 3) + $5 | 0) + 4 >> 2];
              if (($14 | 0) < 0 | ($14 ^ 2147483647) < ($3 | 0)) {
               break block
              }
              $3 = $3 + $14 | 0;
              $4 = $4 + 1 | 0;
              if (($4 | 0) != 1) {
               continue
              }
              break;
             };
             $4 = HEAP32[$2 + 12 >> 2];
             if ($4) {
              $15 = HEAP32[$2 + 8 >> 2];
              $14 = $15 - $4 | 0;
              HEAP32[$2 + 8 >> 2] = $14;
              if (!(!$14 | ($4 | 0) == ($15 | 0))) {
               wasm2js_memory_copy($11, $4 + $11 | 0, $14)
              }
              HEAP32[$2 + 12 >> 2] = 0;
             }
             if (_os_body_expand($2, $3)) {
              break block
             }
             $11 = ($3 >>> 0) / 255 | 0;
             $26 = $11 + 1 | 0;
             if (_os_lacing_expand($2, $26)) {
              break block
             }
             $4 = HEAP32[$5 + 4 >> 2];
             if ($4) {
              wasm2js_memory_copy(HEAP32[$2 + 8 >> 2] + HEAP32[$2 >> 2] | 0, HEAP32[$5 >> 2], $4)
             }
             HEAP32[$2 + 8 >> 2] = HEAP32[$2 + 8 >> 2] + HEAP32[$5 + 4 >> 2];
             $4 = HEAP32[$2 + 16 >> 2];
             $20 = HEAP32[$2 + 28 >> 2];
             $10 = $4 + ($20 << 2) | 0;
             block12 : {
              if ($3 >>> 0 <= 254) {
               $23 = HEAP32[$2 + 20 >> 2];
               $4 = 0;
               break block12;
              }
              $23 = HEAP32[$2 + 20 >> 2];
              $5 = $23 + ($20 << 3) | 0;
              $14 = ($20 << 2) + $4 | 0;
              $15 = HEAP32[$2 + 352 >> 2];
              $17 = HEAP32[$2 + 356 >> 2];
              $4 = 0;
              if ($11 - 1 >>> 0 >= 3) {
               $22 = $11 & 33554428;
               $8 = 0;
               while (1) {
                HEAP32[$14 + ($4 << 2) >> 2] = 255;
                $12 = $5 + ($4 << 3) | 0;
                HEAP32[$12 >> 2] = $15;
                HEAP32[$12 + 4 >> 2] = $17;
                $12 = $4 | 1;
                HEAP32[$14 + ($12 << 2) >> 2] = 255;
                $12 = $5 + ($12 << 3) | 0;
                HEAP32[$12 >> 2] = $15;
                HEAP32[$12 + 4 >> 2] = $17;
                $12 = $4 | 2;
                HEAP32[$14 + ($12 << 2) >> 2] = 255;
                $12 = $5 + ($12 << 3) | 0;
                HEAP32[$12 >> 2] = $15;
                HEAP32[$12 + 4 >> 2] = $17;
                $12 = $4 | 3;
                HEAP32[$14 + ($12 << 2) >> 2] = 255;
                $12 = $5 + ($12 << 3) | 0;
                HEAP32[$12 >> 2] = $15;
                HEAP32[$12 + 4 >> 2] = $17;
                $4 = $4 + 4 | 0;
                $8 = $8 + 4 | 0;
                if (($22 | 0) != ($8 | 0)) {
                 continue
                }
                break;
               };
              }
              $8 = $11 & 3;
              if ($8) {
               while (1) {
                HEAP32[$14 + ($4 << 2) >> 2] = 255;
                $22 = $5 + ($4 << 3) | 0;
                HEAP32[$22 >> 2] = $15;
                HEAP32[$22 + 4 >> 2] = $17;
                $4 = $4 + 1 | 0;
                $27 = $27 + 1 | 0;
                if (($8 | 0) != ($27 | 0)) {
                 continue
                }
                break;
               }
              }
              $4 = $11;
             }
             HEAP32[$10 + ($4 << 2) >> 2] = $3 - Math_imul($11, 255);
             $4 = (($20 << 3) + $23 | 0) + ($4 << 3) | 0;
             HEAP32[$4 >> 2] = $24;
             HEAP32[$4 + 4 >> 2] = $25;
             HEAP32[$2 + 352 >> 2] = $24;
             HEAP32[$2 + 356 >> 2] = $25;
             HEAP32[$10 >> 2] = HEAP32[$10 >> 2] | 256;
             HEAP32[$2 + 28 >> 2] = $20 + $26;
             $4 = HEAP32[$2 + 348 >> 2];
             $10 = $4;
             $5 = $4 + 1 | 0;
             $4 = HEAP32[$2 + 344 >> 2] + 1 | 0;
             $3 = $4 ? $10 : $5;
             HEAP32[$2 + 344 >> 2] = $4;
             HEAP32[$2 + 348 >> 2] = $3;
             $8 = 0;
             if (!$28) {
              break block
             }
             HEAP32[$2 + 328 >> 2] = 1;
            }
            $10 = $8;
           }
           $4 = $10;
           __stack_pointer = $18 + 16 | 0;
           if ($4) {
            break block22
           }
           $4 = $9 + 368 | 0;
           if (!$1) {
            while (1) {
             if (!ogg_stream_flush_i($2, $4, 1)) {
              break block61
             }
             if (FUNCTION_TABLE[$21 | 0]($0, HEAP32[$9 + 368 >> 2], HEAP32[$9 + 372 >> 2], 0, $7, $19) | 0) {
              break block22
             }
             if (!(FUNCTION_TABLE[$21 | 0]($0, HEAP32[$9 + 376 >> 2], HEAP32[$9 + 380 >> 2], 0, $7, $19) | 0)) {
              continue
             }
             break block22;
            }
           }
           while (1) {
            if (!$2 | !HEAP32[$2 >> 2]) {
             $10 = 0
            } else {
             $3 = HEAP32[$2 + 28 >> 2];
             block30 : {
              block21 : {
               if (HEAP32[$2 + 328 >> 2]) {
                if ($3) {
                 break block21
                }
                $10 = 0;
                break block30;
               }
               $10 = 0;
               if (HEAP32[$2 + 332 >> 2] | !$3) {
                break block30
               }
              }
              $10 = 1;
             }
             $10 = ogg_stream_flush_i($2, $4, $10);
            }
            if (!$10) {
             break block61
            }
            if (FUNCTION_TABLE[$21 | 0]($0, HEAP32[$9 + 368 >> 2], HEAP32[$9 + 372 >> 2], 0, $7, $19) | 0) {
             break block22
            }
            if (!(FUNCTION_TABLE[$21 | 0]($0, HEAP32[$9 + 376 >> 2], HEAP32[$9 + 380 >> 2], 0, $7, $19) | 0)) {
             continue
            }
            break;
           };
          }
          $2 = 1;
          break block70;
         }
         $2 = 1;
         if ($1 | $7 | ($16 | 0) != 4 | (HEAPU8[$4 | 0] | HEAPU8[$4 + 1 | 0] << 8 | (HEAPU8[$4 + 2 | 0] << 16 | HEAPU8[$4 + 3 | 0] << 24)) != (HEAPU8[6517] | HEAPU8[6518] << 8 | (HEAPU8[6519] << 16 | HEAPU8[6520] << 24))) {
          break block70
         }
         HEAP32[$9 + 384 >> 2] = 1;
        }
        $2 = HEAP32[$9 + 396 >> 2];
        $10 = $2 + 1 | 0;
        $4 = $2;
        $2 = HEAP32[$9 + 392 >> 2] + $1 | 0;
        $4 = $2 >>> 0 < $1 >>> 0 ? $10 : $4;
        HEAP32[$9 + 392 >> 2] = $2;
        HEAP32[$9 + 396 >> 2] = $4;
        $2 = 0;
       }
       __stack_pointer = $6 + 96 | 0;
       break block13;
      }
      $2 = FUNCTION_TABLE[HEAP32[$6 + 7276 >> 2]]($0, $4, $16, $1, $7, HEAP32[$6 + 7288 >> 2]) | 0;
     }
     if (!$2) {
      break block14
     }
    }
    HEAP32[HEAP32[$0 >> 2] >> 2] = 5;
    FLAC__bitwriter_clear(HEAP32[HEAP32[$0 + 4 >> 2] + 6856 >> 2]);
    HEAP32[HEAP32[$0 >> 2] >> 2] = 5;
    $7 = 0;
    break block1;
   }
   $2 = HEAP32[$0 + 4 >> 2];
   $4 = HEAP32[$2 + 7304 >> 2];
   $7 = HEAP32[$2 + 7308 >> 2];
   $4 = $4 + $16 | 0;
   $16 = $4 >>> 0 < $16 >>> 0 ? $7 + 1 | 0 : $7;
   HEAP32[$2 + 7304 >> 2] = $4;
   HEAP32[$2 + 7308 >> 2] = $16;
   $4 = HEAP32[$2 + 7316 >> 2];
   $5 = $4 + 1 | 0;
   $10 = $4;
   $4 = $1 + HEAP32[$2 + 7312 >> 2] | 0;
   $16 = $4 >>> 0 < $1 >>> 0 ? $5 : $10;
   HEAP32[$2 + 7312 >> 2] = $4;
   HEAP32[$2 + 7316 >> 2] = $16;
   $7 = 1;
   $10 = $2;
   $4 = HEAP32[$2 + 7320 >> 2];
   $2 = HEAP32[$2 + 7056 >> 2] + 1 | 0;
   HEAP32[$10 + 7320 >> 2] = $2 >>> 0 < $4 >>> 0 ? $4 : $2;
   FLAC__bitwriter_clear(HEAP32[HEAP32[$0 + 4 >> 2] + 6856 >> 2]);
   if (!$1) {
    break block1
   }
   $1 = HEAP32[$0 + 4 >> 2];
   $2 = HEAP32[$1 + 6896 >> 2];
   $4 = $1;
   $1 = HEAP32[$13 >> 2];
   HEAP32[$4 + 6896 >> 2] = $1 >>> 0 < $2 >>> 0 ? $1 : $2;
   $2 = HEAP32[$0 + 4 >> 2];
   $0 = HEAP32[$2 + 6900 >> 2];
   HEAP32[$2 + 6900 >> 2] = $0 >>> 0 < $1 >>> 0 ? $1 : $0;
  }
  __stack_pointer = $13 + 16 | 0;
  return $7;
 }
 
 function FLAC__stream_encoder_init_ogg_stream($0, $1, $2, $3, $4, $5, $6) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  $6 = $6 | 0;
  return init_stream_internal__299($0, $1, $2, $3, $4, $5, $6, 1) | 0;
 }
 
 function process_subframe_($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10) {
  var $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0.0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0.0, $23 = 0, $24 = 0, $25 = 0, $26 = 0.0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = Math_fround(0), $37 = 0, $38 = 0, $39 = 0.0, $40 = 0.0, $41 = 0, $42 = Math_fround(0), $43 = 0, $44 = 0, $45 = 0.0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0;
  $24 = __stack_pointer - 576 | 0;
  __stack_pointer = $24;
  $12 = HEAP32[HEAP32[$0 >> 2] + 28 >> 2];
  $11 = HEAP32[$3 >> 2];
  block2 : {
   block1 : {
    if (HEAP32[HEAP32[$0 + 4 >> 2] + 7256 >> 2]) {
     $27 = -1;
     if ($11 >>> 0 > 3) {
      break block1
     }
    }
    $13 = HEAP32[$6 >> 2];
    HEAP32[$13 + 4 >> 2] = $5;
    HEAP32[$13 >> 2] = 1;
    $27 = HEAP32[$13 + 288 >> 2] + (HEAP32[1693] + (HEAP32[1692] + (HEAP32[1691] + Math_imul($4, $11) | 0) | 0) | 0) | 0;
    $11 = HEAP32[$3 >> 2];
    if ($11 >>> 0 < 4) {
     break block2
    }
   }
   $13 = FUNCTION_TABLE[HEAP32[HEAP32[$0 + 4 >> 2] + (((Math_clz32(($11 | 1) - 4 | 0) ^ 31) + $4 | 0) + 4 >>> 0 < 33 ? 7224 : 7228) >> 2]]($5 + 16 | 0, $11 - 4 | 0, $24 + 416 | 0) | 0;
   block4 : {
    block3 : {
     $14 = HEAP32[$0 + 4 >> 2];
     if (HEAP32[$14 + 7248 >> 2] | HEAPF32[$24 + 420 >> 2] != Math_fround(0.0)) {
      break block3
     }
     $11 = 1;
     $18 = HEAP32[$5 >> 2];
     $23 = HEAP32[$3 >> 2];
     if ($23 >>> 0 <= 1) {
      break block4
     }
     while (1) {
      if (($18 | 0) != HEAP32[($11 << 2) + $5 >> 2]) {
       break block3
      }
      $11 = $11 + 1 | 0;
      if (($11 | 0) != ($23 | 0)) {
       continue
      }
      break;
     };
     break block4;
    }
    $34 = HEAP32[($12 >>> 0 > 16 ? 6752 : 6748) >> 2];
    $11 = HEAP32[$0 >> 2];
    block6 : {
     if (HEAP32[$14 + 7252 >> 2]) {
      $23 = 0;
      if (HEAP32[$11 + 556 >> 2] | ($27 | 0) != -1) {
       break block6
      }
     }
     $23 = 0;
     $12 = HEAP32[$11 + 568 >> 2];
     $18 = $12 ? 0 : $13;
     $13 = $12 ? 4 : $13;
     $12 = HEAP32[$3 >> 2];
     $32 = $12 >>> 0 > $13 >>> 0 ? $13 : $12 - 1 | 0;
     if ($18 >>> 0 > $32 >>> 0) {
      break block6
     }
     $33 = $18 - 1 | 0;
     $29 = $34 - 1 | 0;
     $30 = HEAP32[1693] + (HEAP32[1691] + HEAP32[1692] | 0) | 0;
     $42 = Math_fround($4 >>> 0);
     while (1) {
      $13 = $18 << 2;
      $36 = HEAPF32[$13 + ($24 + 416 | 0) >> 2];
      if (!($36 >= $42)) {
       $25 = !$23;
       $11 = $25 << 2;
       $28 = HEAP32[$11 + $7 >> 2];
       $16 = HEAP32[$6 + $11 >> 2];
       $35 = HEAP32[HEAP32[$0 >> 2] + 572 >> 2];
       $12 = HEAP32[$0 + 4 >> 2];
       $31 = HEAP32[$12 + 6852 >> 2];
       $38 = HEAP32[$12 + 6848 >> 2];
       $12 = $5 + $13 | 0;
       $13 = HEAP32[$3 >> 2] - $18 | 0;
       $14 = HEAP32[$8 + $11 >> 2];
       $20 = 0;
       __inlined_func$FLAC__fixed_compute_residual$97 : {
        block : {
         switch ($18 | 0) {
         case 4:
          $11 = 0;
          if (($13 | 0) <= 0) {
           break __inlined_func$FLAC__fixed_compute_residual$97
          }
          while (1) {
           $20 = $11 << 2;
           $19 = $20 + $12 | 0;
           HEAP32[$14 + $20 >> 2] = (HEAP32[$19 - 16 >> 2] + (HEAP32[$19 >> 2] + Math_imul(HEAP32[$19 - 8 >> 2], 6) | 0) | 0) - (HEAP32[$19 - 12 >> 2] + HEAP32[$19 - 4 >> 2] << 2);
           $11 = $11 + 1 | 0;
           if (($11 | 0) != ($13 | 0)) {
            continue
           }
           break;
          };
          break __inlined_func$FLAC__fixed_compute_residual$97;
         case 3:
          $11 = 0;
          if (($13 | 0) <= 0) {
           break __inlined_func$FLAC__fixed_compute_residual$97
          }
          while (1) {
           $20 = $11 << 2;
           $19 = $20 + $12 | 0;
           HEAP32[$14 + $20 >> 2] = (HEAP32[$19 >> 2] - HEAP32[$19 - 12 >> 2] | 0) + Math_imul(HEAP32[$19 - 8 >> 2] - HEAP32[$19 - 4 >> 2] | 0, 3);
           $11 = $11 + 1 | 0;
           if (($11 | 0) != ($13 | 0)) {
            continue
           }
           break;
          };
          break __inlined_func$FLAC__fixed_compute_residual$97;
         case 2:
          if (($13 | 0) <= 0) {
           break __inlined_func$FLAC__fixed_compute_residual$97
          }
          $11 = 0;
          if (($13 | 0) != 1) {
           $37 = $13 & 2147483646;
           while (1) {
            $17 = $11 << 2;
            $19 = $17 + $12 | 0;
            HEAP32[$14 + $17 >> 2] = HEAP32[$19 - 8 >> 2] + (HEAP32[$19 >> 2] - (HEAP32[$19 - 4 >> 2] << 1) | 0);
            $17 = $17 | 4;
            $19 = $17 + $12 | 0;
            HEAP32[$14 + $17 >> 2] = HEAP32[$19 - 8 >> 2] + (HEAP32[$19 >> 2] - (HEAP32[$19 - 4 >> 2] << 1) | 0);
            $11 = $11 + 2 | 0;
            $20 = $20 + 2 | 0;
            if (($37 | 0) != ($20 | 0)) {
             continue
            }
            break;
           };
          }
          if (!($13 & 1)) {
           break __inlined_func$FLAC__fixed_compute_residual$97
          }
          $17 = $12;
          $12 = $11 << 2;
          $11 = $17 + $12 | 0;
          HEAP32[$12 + $14 >> 2] = HEAP32[$11 - 8 >> 2] + (HEAP32[$11 >> 2] - (HEAP32[$11 - 4 >> 2] << 1) | 0);
          break __inlined_func$FLAC__fixed_compute_residual$97;
         case 1:
          if (($13 | 0) <= 0) {
           break __inlined_func$FLAC__fixed_compute_residual$97
          }
          $11 = 0;
          if (($13 | 0) != 1) {
           $37 = $13 & 2147483646;
           $19 = 0;
           while (1) {
            $20 = $11 << 2;
            $17 = $20 + $12 | 0;
            HEAP32[$14 + $20 >> 2] = HEAP32[$17 >> 2] - HEAP32[$17 - 4 >> 2];
            $17 = $20 | 4;
            $20 = $17 + $12 | 0;
            HEAP32[$14 + $17 >> 2] = HEAP32[$20 >> 2] - HEAP32[$20 - 4 >> 2];
            $11 = $11 + 2 | 0;
            $19 = $19 + 2 | 0;
            if (($37 | 0) != ($19 | 0)) {
             continue
            }
            break;
           };
          }
          if (!($13 & 1)) {
           break __inlined_func$FLAC__fixed_compute_residual$97
          }
          $17 = $12;
          $12 = $11 << 2;
          $11 = $17 + $12 | 0;
          HEAP32[$12 + $14 >> 2] = HEAP32[$11 >> 2] - HEAP32[$11 - 4 >> 2];
          break __inlined_func$FLAC__fixed_compute_residual$97;
         case 0:
          break block;
         default:
          break __inlined_func$FLAC__fixed_compute_residual$97;
         };
        }
        $11 = $13 << 2;
        if (!$11) {
         break __inlined_func$FLAC__fixed_compute_residual$97
        }
        wasm2js_memory_copy($14, $12, $11);
       }
       HEAP32[$16 + 36 >> 2] = $14;
       HEAP32[$16 + 12 >> 2] = $28;
       HEAP32[$16 >> 2] = 2;
       HEAP32[$16 + 4 >> 2] = 0;
       $12 = HEAP32[$0 + 4 >> 2];
       $15 = +$36 + .5;
       if ($15 < 4294967295.0 & $15 >= 0.0) {
        $11 = ~~$15 >>> 0
       } else {
        $11 = 0
       }
       $11 = $36 > Math_fround(0.0) ? $11 + 1 | 0 : 1;
       $20 = find_best_partition_order_($12, $14, $38, $31, $13, $18, $11 >>> 0 < $34 >>> 0 ? $11 : $29, $34, $1, $2, $4, $35, $16 + 4 | 0);
       HEAP32[$16 + 16 >> 2] = $18;
       block8 : {
        if (!$18) {
         break block8
        }
        $13 = $16 + 20 | 0;
        $12 = 0;
        $11 = 0;
        if ($21 + $33 >>> 0 >= 3) {
         $17 = $18 & -4;
         $19 = 0;
         while (1) {
          $14 = $11 << 2;
          HEAP32[$14 + $13 >> 2] = HEAP32[$5 + $14 >> 2];
          $28 = $14 | 4;
          HEAP32[$28 + $13 >> 2] = HEAP32[$5 + $28 >> 2];
          $28 = $14 | 8;
          HEAP32[$28 + $13 >> 2] = HEAP32[$5 + $28 >> 2];
          $14 = $14 | 12;
          HEAP32[$14 + $13 >> 2] = HEAP32[$5 + $14 >> 2];
          $11 = $11 + 4 | 0;
          $19 = $19 + 4 | 0;
          if (($17 | 0) != ($19 | 0)) {
           continue
          }
          break;
         };
        }
        $14 = $18 & 3;
        if (!$14) {
         break block8
        }
        while (1) {
         $19 = $11 << 2;
         HEAP32[$19 + $13 >> 2] = HEAP32[$5 + $19 >> 2];
         $11 = $11 + 1 | 0;
         $12 = $12 + 1 | 0;
         if (($14 | 0) != ($12 | 0)) {
          continue
         }
         break;
        };
       }
       $11 = HEAP32[$16 + 288 >> 2] + ($30 + ($20 + Math_imul($4, $18) | 0) | 0) | 0;
       $13 = $11 >>> 0 < $27 >>> 0;
       $23 = $13 ? $25 : $23;
       $27 = $13 ? $11 : $27;
      }
      $21 = $21 + 1 | 0;
      $18 = $18 + 1 | 0;
      if ($32 >>> 0 >= $18 >>> 0) {
       continue
      }
      break;
     };
     $11 = HEAP32[$0 >> 2];
    }
    $13 = HEAP32[$11 + 556 >> 2];
    if (!$13) {
     break block2
    }
    $18 = HEAP32[$3 >> 2];
    $13 = $13 >>> 0 < $18 >>> 0 ? $13 : $18 - 1 | 0;
    HEAP32[$24 + 12 >> 2] = $13;
    if (!$13 | !HEAP32[$11 + 40 >> 2]) {
     break block2
    }
    $37 = $34 - 1 | 0;
    $43 = HEAP32[1689] + HEAP32[1690] | 0;
    $44 = HEAP32[1693] + (HEAP32[1691] + HEAP32[1692] | 0) | 0;
    $45 = +($4 >>> 0);
    $46 = $4 >>> 0 < 18;
    $47 = $4 >>> 0 > 16;
    $48 = $4 >>> 0 > 17;
    $32 = 0;
    while (1) {
     $11 = HEAP32[$0 + 4 >> 2];
     $13 = HEAP32[($11 + ($32 << 2) | 0) + 84 >> 2];
     $18 = HEAP32[$11 + 212 >> 2];
     $11 = 0;
     $16 = 0;
     $12 = HEAP32[$3 >> 2];
     block9 : {
      if (!$12) {
       break block9
      }
      if (($12 | 0) != 1) {
       $19 = $12 & -2;
       while (1) {
        $14 = $11 << 2;
        HEAPF32[$14 + $18 >> 2] = HEAPF32[$13 + $14 >> 2] * Math_fround(HEAP32[$5 + $14 >> 2]);
        $14 = $14 | 4;
        HEAPF32[$14 + $18 >> 2] = HEAPF32[$13 + $14 >> 2] * Math_fround(HEAP32[$5 + $14 >> 2]);
        $11 = $11 + 2 | 0;
        $16 = $16 + 2 | 0;
        if (($16 | 0) != ($19 | 0)) {
         continue
        }
        break;
       };
      }
      if (!($12 & 1)) {
       break block9
      }
      $11 = $11 << 2;
      HEAPF32[$18 + $11 >> 2] = HEAPF32[$11 + $13 >> 2] * Math_fround(HEAP32[$5 + $11 >> 2]);
     }
     $11 = HEAP32[$0 + 4 >> 2];
     $13 = $24 + 272 | 0;
     FUNCTION_TABLE[HEAP32[$11 + 7232 >> 2]](HEAP32[$11 + 212 >> 2], HEAP32[$3 >> 2], HEAP32[$24 + 12 >> 2] + 1 | 0, $13);
     block1011 : {
      if (HEAPF32[$24 + 272 >> 2] == Math_fround(0.0)) {
       break block1011
      }
      $20 = HEAP32[$0 + 4 >> 2] + 7628 | 0;
      $33 = $24 + 16 | 0;
      $11 = 0;
      $14 = __stack_pointer - 256 | 0;
      __stack_pointer = $14;
      $29 = $24 + 12 | 0;
      $30 = HEAP32[$29 >> 2];
      $22 = +HEAPF32[$13 >> 2];
      block12 : {
       while (1) {
        if (($11 | 0) == ($30 | 0)) {
         break block12
        }
        $18 = $11 + 1 | 0;
        $15 = +Math_fround(-HEAPF32[($18 << 2) + $13 >> 2]);
        block7 : {
         if ($11) {
          $12 = 0;
          $17 = ($11 | 0) == 1;
          if (!$17) {
           $19 = $11 & -2;
           $16 = 0;
           while (1) {
            $21 = $12 | 1;
            $15 = $15 - HEAPF64[($12 << 3) + $14 >> 3] * +HEAPF32[($11 - $12 << 2) + $13 >> 2] - HEAPF64[($21 << 3) + $14 >> 3] * +HEAPF32[($11 - $21 << 2) + $13 >> 2];
            $12 = $12 + 2 | 0;
            $16 = $16 + 2 | 0;
            if (($19 | 0) != ($16 | 0)) {
             continue
            }
            break;
           };
          }
          $16 = ($11 << 3) + $14 | 0;
          $25 = $11 & 1;
          if ($25) {
           $15 = $15 - HEAPF64[($12 << 3) + $14 >> 3] * +HEAPF32[($11 - $12 << 2) + $13 >> 2]
          }
          $15 = $15 / $22;
          HEAPF64[$16 >> 3] = $15;
          $19 = 0;
          if (!$17) {
           $12 = $11 >>> 1 | 0;
           $19 = $12 >>> 0 <= 1 ? 1 : $12;
           $28 = $19 & 1;
           $12 = 0;
           if ($11 >>> 0 >= 4) {
            $35 = $19 & 2147483646;
            $16 = 0;
            while (1) {
             $17 = ($12 << 3) + $14 | 0;
             $26 = HEAPF64[$17 >> 3];
             $21 = (($12 ^ -1) + $11 << 3) + $14 | 0;
             HEAPF64[$17 >> 3] = $15 * HEAPF64[$21 >> 3] + $26;
             HEAPF64[$21 >> 3] = $15 * $26 + HEAPF64[$21 >> 3];
             $17 = $17 + 8 | 0;
             $26 = HEAPF64[$17 >> 3];
             $31 = $17;
             $17 = (($12 ^ 536870910) + $11 << 3) + $14 | 0;
             HEAPF64[$31 >> 3] = $15 * HEAPF64[$17 >> 3] + $26;
             HEAPF64[$17 >> 3] = $15 * $26 + HEAPF64[$17 >> 3];
             $12 = $12 + 2 | 0;
             $16 = $16 + 2 | 0;
             if (($35 | 0) != ($16 | 0)) {
              continue
             }
             break;
            };
           }
           if ($28) {
            $16 = ($12 << 3) + $14 | 0;
            $26 = HEAPF64[$16 >> 3];
            $12 = (($12 ^ -1) + $11 << 3) + $14 | 0;
            HEAPF64[$16 >> 3] = $15 * HEAPF64[$12 >> 3] + $26;
            HEAPF64[$12 >> 3] = $15 * $26 + HEAPF64[$12 >> 3];
           }
           if (!$25) {
            break block7
           }
          }
          $12 = ($19 << 3) + $14 | 0;
          $26 = HEAPF64[$12 >> 3];
          HEAPF64[$12 >> 3] = $26 * $15 + $26;
          break block7;
         }
         $15 = $15 / $22;
         HEAPF64[($11 << 3) + $14 >> 3] = $15;
        }
        $17 = 0;
        $12 = 0;
        if ($11 >>> 0 >= 3) {
         $21 = $18 & -4;
         $16 = 0;
         while (1) {
          $19 = ($11 << 7) + $20 | 0;
          HEAPF32[$19 + ($12 << 2) >> 2] = -Math_fround(HEAPF64[($12 << 3) + $14 >> 3]);
          $25 = $12 | 1;
          HEAPF32[$19 + ($25 << 2) >> 2] = -Math_fround(HEAPF64[($25 << 3) + $14 >> 3]);
          $25 = $12 | 2;
          HEAPF32[$19 + ($25 << 2) >> 2] = -Math_fround(HEAPF64[($25 << 3) + $14 >> 3]);
          $25 = $12 | 3;
          HEAPF32[$19 + ($25 << 2) >> 2] = -Math_fround(HEAPF64[($25 << 3) + $14 >> 3]);
          $12 = $12 + 4 | 0;
          $16 = $16 + 4 | 0;
          if (($21 | 0) != ($16 | 0)) {
           continue
          }
          break;
         };
        }
        $16 = $18 & 3;
        if ($16) {
         while (1) {
          HEAPF32[(($11 << 7) + $20 | 0) + ($12 << 2) >> 2] = -Math_fround(HEAPF64[($12 << 3) + $14 >> 3]);
          $12 = $12 + 1 | 0;
          $17 = $17 + 1 | 0;
          if (($16 | 0) != ($17 | 0)) {
           continue
          }
          break;
         }
        }
        $22 = $22 * (1.0 - $15 * $15);
        HEAPF64[($11 << 3) + $33 >> 3] = $22;
        $11 = $18;
        if ($22 != 0.0) {
         continue
        }
        break;
       };
       HEAP32[$29 >> 2] = $11;
      }
      __stack_pointer = $14 + 256 | 0;
      $13 = 1;
      $11 = HEAP32[$24 + 12 >> 2];
      $18 = HEAP32[$0 >> 2];
      if (!HEAP32[$18 + 568 >> 2]) {
       $19 = $24 + 16 | 0;
       $14 = HEAP32[$3 >> 2];
       $20 = (HEAP32[$18 + 564 >> 2] ? 5 : HEAP32[$18 + 560 >> 2]) + $4 | 0;
       $13 = 0;
       $12 = 0;
       $18 = 1;
       if ($11) {
        $26 = .5 / +($14 >>> 0);
        $15 = 4294967295.0;
        while (1) {
         $22 = HEAPF64[($13 << 3) + $19 >> 3];
         block219 : {
          if ($22 > 0.0) {
           $22 = log($26 * $22) * .5 / .6931471805599453;
           $22 = $22 >= 0.0 ? $22 : 0.0;
           break block219;
          }
          $22 = $22 < 0.0 ? 1.e+32 : 0.0;
         }
         $22 = $22 * +($14 - $18 >>> 0) + +(Math_imul($18, $20) >>> 0);
         $16 = $22 < $15;
         $15 = $16 ? $22 : $15;
         $12 = $16 ? $13 : $12;
         $18 = $18 + 1 | 0;
         $13 = $13 + 1 | 0;
         if (($13 | 0) != ($11 | 0)) {
          continue
         }
         break;
        };
        $11 = $12 + 1 | 0;
       } else {
        $11 = 1
       }
       HEAP32[$24 + 12 >> 2] = $11;
       $13 = $11;
      }
      $18 = HEAP32[$3 >> 2];
      if ($11 >>> 0 >= $18 >>> 0) {
       $11 = $18 - 1 | 0;
       HEAP32[$24 + 12 >> 2] = $11;
      }
      if ($11 >>> 0 < $13 >>> 0) {
       break block1011
      }
      $49 = $13 - 1 | 0;
      $33 = 0;
      while (1) {
       $11 = HEAP32[$3 >> 2] - $13 | 0;
       $12 = $13 - 1 | 0;
       $15 = HEAPF64[($24 + 16 | 0) + ($12 << 3) >> 3];
       __inlined_func$FLAC__lpc_compute_expected_bits_per_residual_sample$101 : {
        if ($15 > 0.0) {
         $15 = log($15 * (.5 / +($11 >>> 0))) * .5 / .6931471805599453;
         $15 = $15 >= 0.0 ? $15 : 0.0;
         break __inlined_func$FLAC__lpc_compute_expected_bits_per_residual_sample$101;
        }
        $15 = $15 < 0.0 ? 1.e+32 : 0.0;
       }
       if (!($15 >= $45)) {
        $22 = $15 + .5;
        if ($22 < 4294967295.0 & $22 >= 0.0) {
         $11 = ~~$22 >>> 0
        } else {
         $11 = 0
        }
        $11 = $15 > 0.0 ? $11 + 1 | 0 : 1;
        $14 = $11 >>> 0 < $34 >>> 0;
        $18 = HEAP32[$0 >> 2];
        block17 : {
         if (HEAP32[$18 + 564 >> 2]) {
          if ($48) {
           $18 = 5;
           $16 = 15;
           break block17;
          }
          $18 = 5;
          $16 = ((Math_clz32($13) ^ -32) - $4 | 0) + 33 | 0;
          $16 = $16 >>> 0 >= 15 ? 15 : $16;
          $16 = $16 >>> 0 <= 5 ? 5 : $16;
          break block17;
         }
         $18 = HEAP32[$18 + 560 >> 2];
         $16 = $18;
        }
        $50 = $16;
        $51 = $14 ? $11 : $37;
        $52 = $13 & -4;
        $28 = $13 & 3;
        $53 = ($13 << 2) + $5 | 0;
        $11 = Math_clz32($13);
        $54 = ($11 ^ 31) + $4 | 0;
        $35 = (($11 ^ -32) - $4 | 0) + 33 | 0;
        $55 = $12 << 7;
        $56 = $33 + $49 >>> 0 < 3;
        while (1) {
         $57 = HEAP32[$3 >> 2];
         $16 = !$23;
         $11 = $16 << 2;
         $58 = HEAP32[$11 + $7 >> 2];
         $14 = HEAP32[$6 + $11 >> 2];
         $29 = HEAP32[$8 + $11 >> 2];
         $59 = HEAP32[HEAP32[$0 >> 2] + 572 >> 2];
         $12 = HEAP32[$0 + 4 >> 2];
         $60 = HEAP32[$12 + 6852 >> 2];
         $61 = HEAP32[$12 + 6848 >> 2];
         $11 = 0;
         $62 = $16;
         $63 = $23;
         $23 = ($12 + $55 | 0) + 7628 | 0;
         $16 = $46 ? ($18 >>> 0 < $35 >>> 0 ? $18 : $35) : $18;
         $31 = $24 + 448 | 0;
         $19 = $24 + 444 | 0;
         $15 = 0.0;
         $12 = 0;
         $21 = 0;
         $30 = __stack_pointer - 16 | 0;
         __stack_pointer = $30;
         $20 = 2;
         block20 : {
          if (!$13) {
           break block20
          }
          if ($13 >>> 0 >= 4) {
           $25 = $13 & -4;
           while (1) {
            $17 = ($12 << 2) + $23 | 0;
            $22 = +Math_fround(Math_abs(HEAPF32[$17 + 12 >> 2]));
            $26 = +Math_fround(Math_abs(HEAPF32[$17 + 8 >> 2]));
            $39 = +Math_fround(Math_abs(HEAPF32[$17 + 4 >> 2]));
            $40 = +Math_fround(Math_abs(HEAPF32[$17 >> 2]));
            $15 = $15 < $40 ? $40 : $15;
            $15 = $15 < $39 ? $39 : $15;
            $15 = $15 < $26 ? $26 : $15;
            $15 = $15 < $22 ? $22 : $15;
            $12 = $12 + 4 | 0;
            $21 = $21 + 4 | 0;
            if (($25 | 0) != ($21 | 0)) {
             continue
            }
            break;
           };
          }
          $21 = $13 & 3;
          if ($21) {
           $17 = 0;
           while (1) {
            $22 = +Math_fround(Math_abs(HEAPF32[($12 << 2) + $23 >> 2]));
            $15 = $15 < $22 ? $22 : $15;
            $12 = $12 + 1 | 0;
            $17 = $17 + 1 | 0;
            if (($21 | 0) != ($17 | 0)) {
             continue
            }
            break;
           };
          }
          if ($15 <= 0.0) {
           break block20
          }
          $25 = 1 << $16 - 1;
          $38 = $25 - 1 | 0;
          $17 = 0 - $25 | 0;
          frexp($15, $30 + 12 | 0);
          $21 = (HEAP32[$30 + 12 >> 2] ^ -1) + $16 | 0;
          HEAP32[$19 >> 2] = $21;
          block624 : {
           $12 = -1 << HEAP32[1690] - 1;
           $20 = $12 ^ -1;
           block525 : {
            if (($21 | 0) > ($20 | 0)) {
             HEAP32[$19 >> 2] = $20;
             break block525;
            }
            $20 = 1;
            if (($12 | 0) > ($21 | 0)) {
             break block20
            }
            $12 = 0;
            if (($21 | 0) < 0) {
             break block624
            }
           }
           $20 = 0;
           $15 = 0.0;
           $12 = 0;
           while (1) {
            $41 = $12 << 2;
            $15 = $15 + +Math_fround(HEAPF32[$41 + $23 >> 2] * Math_fround(1 << HEAP32[$19 >> 2]));
            $21 = lround($15);
            $21 = ($21 | 0) < ($25 | 0) ? (($17 | 0) < ($21 | 0) ? $21 : $17) : $38;
            HEAP32[$31 + $41 >> 2] = $21;
            $15 = $15 - +($21 | 0);
            $12 = $12 + 1 | 0;
            if (($12 | 0) != ($13 | 0)) {
             continue
            }
            break;
           };
           break block20;
          }
          $36 = Math_fround(1 << 0 - $21);
          $15 = 0.0;
          while (1) {
           $21 = $12 << 2;
           $15 = $15 + +Math_fround(HEAPF32[$21 + $23 >> 2] / $36);
           $20 = lround($15);
           $20 = ($20 | 0) < ($25 | 0) ? (($17 | 0) < ($20 | 0) ? $20 : $17) : $38;
           HEAP32[$21 + $31 >> 2] = $20;
           $15 = $15 - +($20 | 0);
           $12 = $12 + 1 | 0;
           if (($12 | 0) != ($13 | 0)) {
            continue
           }
           break;
          };
          $20 = 0;
          HEAP32[$19 >> 2] = 0;
         }
         __stack_pointer = $30 + 16 | 0;
         if (!$20) {
          $11 = $57 - $13 | 0;
          $12 = $24 + 448 | 0;
          $31 = HEAP32[$24 + 444 >> 2];
          block2128 : {
           if ($16 + $54 >>> 0 <= 32) {
            $23 = HEAP32[$0 + 4 >> 2];
            $17 = $23 + 7244 | 0;
            if (!($16 >>> 0 > 16 | $47)) {
             break block2128
            }
            $17 = $23 + 7236 | 0;
            break block2128;
           }
           $17 = HEAP32[$0 + 4 >> 2] + 7240 | 0;
          }
          FUNCTION_TABLE[HEAP32[$17 >> 2]]($53, $11, $12, $13, $31, $29);
          HEAP32[$14 + 284 >> 2] = $29;
          HEAP32[$14 + 12 >> 2] = $58;
          HEAP32[$14 >> 2] = 3;
          HEAP32[$14 + 4 >> 2] = 0;
          $20 = find_best_partition_order_(HEAP32[$0 + 4 >> 2], $29, $61, $60, $11, $13, $51, $34, $1, $2, $4, $59, $14 + 4 | 0);
          HEAP32[$14 + 20 >> 2] = $16;
          HEAP32[$14 + 16 >> 2] = $13;
          HEAP32[$14 + 24 >> 2] = HEAP32[$24 + 444 >> 2];
          wasm2js_memory_copy($14 + 28 | 0, $12, 128);
          $17 = $4 + $16 | 0;
          block23 : {
           if (!$13) {
            break block23
           }
           $23 = $14 + 156 | 0;
           $12 = 0;
           $11 = 0;
           $19 = 0;
           if (!$56) {
            while (1) {
             $16 = $11 << 2;
             HEAP32[$16 + $23 >> 2] = HEAP32[$5 + $16 >> 2];
             $21 = $16 | 4;
             HEAP32[$21 + $23 >> 2] = HEAP32[$5 + $21 >> 2];
             $21 = $16 | 8;
             HEAP32[$21 + $23 >> 2] = HEAP32[$5 + $21 >> 2];
             $16 = $16 | 12;
             HEAP32[$16 + $23 >> 2] = HEAP32[$5 + $16 >> 2];
             $11 = $11 + 4 | 0;
             $19 = $19 + 4 | 0;
             if (($52 | 0) != ($19 | 0)) {
              continue
             }
             break;
            }
           }
           if (!$28) {
            break block23
           }
           while (1) {
            $16 = $11 << 2;
            HEAP32[$16 + $23 >> 2] = HEAP32[$5 + $16 >> 2];
            $11 = $11 + 1 | 0;
            $12 = $12 + 1 | 0;
            if (($28 | 0) != ($12 | 0)) {
             continue
            }
            break;
           };
          }
          $11 = (HEAP32[$14 + 288 >> 2] + (($20 + Math_imul($13, $17) | 0) + $44 | 0) | 0) + $43 | 0;
         }
         $12 = ($11 | 0) != 0 & $11 >>> 0 < $27 >>> 0;
         $23 = $12 ? $62 : $63;
         $27 = $12 ? $11 : $27;
         $18 = $18 + 1 | 0;
         if ($50 >>> 0 >= $18 >>> 0) {
          continue
         }
         break;
        };
       }
       $33 = $33 + 1 | 0;
       $13 = $13 + 1 | 0;
       if ($13 >>> 0 <= HEAPU32[$24 + 12 >> 2]) {
        continue
       }
       break;
      };
     }
     $32 = $32 + 1 | 0;
     if ($32 >>> 0 < HEAPU32[HEAP32[$0 >> 2] + 40 >> 2]) {
      continue
     }
     break;
    };
    break block2;
   }
   $0 = HEAP32[$6 + 4 >> 2];
   HEAP32[$0 + 4 >> 2] = $18;
   HEAP32[$0 >> 2] = 0;
   $0 = HEAP32[$0 + 288 >> 2] + (HEAP32[1693] + (HEAP32[1692] + (HEAP32[1691] + $4 | 0) | 0) | 0) | 0;
   $23 = $0 >>> 0 < $27 >>> 0;
   $27 = $23 ? $0 : $27;
  }
  if (($27 | 0) == -1) {
   $1 = HEAP32[$3 >> 2];
   $0 = HEAP32[($23 << 2) + $6 >> 2];
   HEAP32[$0 + 4 >> 2] = $5;
   HEAP32[$0 >> 2] = 1;
   $27 = HEAP32[$0 + 288 >> 2] + (HEAP32[1693] + (HEAP32[1692] + (HEAP32[1691] + Math_imul($1, $4) | 0) | 0) | 0) | 0;
  }
  HEAP32[$9 >> 2] = $23;
  HEAP32[$10 >> 2] = $27;
  __stack_pointer = $24 + 576 | 0;
 }
 
 function add_subframe_($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  $8 = 1;
  block4 : {
   block5 : {
    block1 : {
     switch (HEAP32[$3 >> 2]) {
     case 0:
      $5 = $3 + 4 | 0;
      $1 = 0;
      $3 = HEAP32[$3 + 288 >> 2];
      block0 : {
       if (!FLAC__bitwriter_write_raw_uint32($4, HEAP32[1694] | ($3 | 0) != 0, HEAP32[1693] + (HEAP32[1692] + HEAP32[1691] | 0) | 0)) {
        break block0
       }
       if ($3) {
        if (!FLAC__bitwriter_write_unary_unsigned($4, $3 - 1 | 0)) {
         break block0
        }
       }
       $1 = (FLAC__bitwriter_write_raw_int32($4, HEAP32[$5 >> 2], $2) | 0) != 0;
      }
      if (!$1) {
       break block5
      }
      break block4;
     case 2:
      $7 = $1 - HEAP32[$3 + 16 >> 2] | 0;
      $6 = HEAP32[$3 + 288 >> 2];
      $1 = $3 + 4 | 0;
      __inlined_func$FLAC__subframe_add_fixed$104 : {
       block6 : {
        if (!FLAC__bitwriter_write_raw_uint32($4, HEAP32[1696] | ($6 | 0) != 0 | HEAP32[$1 + 12 >> 2] << 1, HEAP32[1693] + (HEAP32[1692] + HEAP32[1691] | 0) | 0)) {
         break block6
        }
        if ($6) {
         if (!FLAC__bitwriter_write_unary_unsigned($4, $6 - 1 | 0)) {
          break block6
         }
        }
        block27 : {
         if (!HEAP32[$1 + 12 >> 2]) {
          break block27
         }
         $6 = $1 + 16 | 0;
         $3 = 0;
         while (1) {
          if (FLAC__bitwriter_write_raw_int32($4, HEAP32[$6 + ($3 << 2) >> 2], $2)) {
           $3 = $3 + 1 | 0;
           if ($3 >>> 0 < HEAPU32[$1 + 12 >> 2]) {
            continue
           }
           break block27;
          }
          break;
         };
         $5 = 0;
         break __inlined_func$FLAC__subframe_add_fixed$104;
        }
        if (!FLAC__bitwriter_write_raw_uint32($4, HEAP32[$1 >> 2], HEAP32[1682])) {
         break block6
        }
        block48 : {
         if (HEAPU32[$1 >> 2] > 1) {
          break block48
         }
         if (!FLAC__bitwriter_write_raw_uint32($4, HEAP32[$1 + 4 >> 2], HEAP32[1683])) {
          break block6
         }
         $2 = HEAP32[$1 >> 2];
         if ($2 >>> 0 > 1) {
          break block48
         }
         $3 = HEAP32[$1 + 8 >> 2];
         if (!add_residual_partitioned_rice_($4, HEAP32[$1 + 32 >> 2], $7, HEAP32[$1 + 12 >> 2], HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$1 + 4 >> 2], ($2 | 0) == 1)) {
          break block6
         }
        }
        $5 = 1;
       }
      }
      if (!$5) {
       break block5
      }
      break block4;
     case 3:
      $6 = $1 - HEAP32[$3 + 16 >> 2] | 0;
      $1 = $3 + 4 | 0;
      $3 = HEAP32[$3 + 288 >> 2];
      __inlined_func$FLAC__subframe_add_lpc$105 : {
       block9 : {
        if (!FLAC__bitwriter_write_raw_uint32($4, (HEAP32[$1 + 12 >> 2] << 1) - 2 | (HEAP32[1697] | ($3 | 0) != 0), HEAP32[1693] + (HEAP32[1692] + HEAP32[1691] | 0) | 0)) {
         break block9
        }
        if ($3) {
         if (!FLAC__bitwriter_write_unary_unsigned($4, $3 - 1 | 0)) {
          break block9
         }
        }
        block210 : {
         if (!HEAP32[$1 + 12 >> 2]) {
          break block210
         }
         $7 = $1 + 152 | 0;
         $3 = 0;
         while (1) {
          if (FLAC__bitwriter_write_raw_int32($4, HEAP32[$7 + ($3 << 2) >> 2], $2)) {
           $3 = $3 + 1 | 0;
           if ($3 >>> 0 < HEAPU32[$1 + 12 >> 2]) {
            continue
           }
           break block210;
          }
          break;
         };
         $5 = 0;
         break __inlined_func$FLAC__subframe_add_lpc$105;
        }
        if (!FLAC__bitwriter_write_raw_uint32($4, HEAP32[$1 + 16 >> 2] - 1 | 0, HEAP32[1689])) {
         break block9
        }
        if (!FLAC__bitwriter_write_raw_int32($4, HEAP32[$1 + 20 >> 2], HEAP32[1690])) {
         break block9
        }
        block412 : {
         if (!HEAP32[$1 + 12 >> 2]) {
          break block412
         }
         $2 = $1 + 24 | 0;
         $3 = 0;
         while (1) {
          if (FLAC__bitwriter_write_raw_int32($4, HEAP32[$2 + ($3 << 2) >> 2], HEAP32[$1 + 16 >> 2])) {
           $3 = $3 + 1 | 0;
           if ($3 >>> 0 < HEAPU32[$1 + 12 >> 2]) {
            continue
           }
           break block412;
          }
          break;
         };
         $5 = 0;
         break __inlined_func$FLAC__subframe_add_lpc$105;
        }
        if (!FLAC__bitwriter_write_raw_uint32($4, HEAP32[$1 >> 2], HEAP32[1682])) {
         break block9
        }
        block613 : {
         if (HEAPU32[$1 >> 2] > 1) {
          break block613
         }
         if (!FLAC__bitwriter_write_raw_uint32($4, HEAP32[$1 + 4 >> 2], HEAP32[1683])) {
          break block9
         }
         $2 = HEAP32[$1 >> 2];
         if ($2 >>> 0 > 1) {
          break block613
         }
         $3 = HEAP32[$1 + 8 >> 2];
         if (!add_residual_partitioned_rice_($4, HEAP32[$1 + 280 >> 2], $6, HEAP32[$1 + 12 >> 2], HEAP32[$3 >> 2], HEAP32[$3 + 4 >> 2], HEAP32[$1 + 4 >> 2], ($2 | 0) == 1)) {
          break block9
         }
        }
        $5 = 1;
       }
      }
      if (!$5) {
       break block5
      }
      break block4;
     case 1:
      break block1;
     default:
      break block4;
     };
    }
    $6 = HEAP32[$3 + 4 >> 2];
    $3 = HEAP32[$3 + 288 >> 2];
    __inlined_func$FLAC__subframe_add_verbatim$106 : {
     block14 : {
      if (!FLAC__bitwriter_write_raw_uint32($4, HEAP32[1695] | ($3 | 0) != 0, HEAP32[1693] + (HEAP32[1692] + HEAP32[1691] | 0) | 0)) {
       break block14
      }
      if ($3) {
       if (!FLAC__bitwriter_write_unary_unsigned($4, $3 - 1 | 0)) {
        break block14
       }
      }
      $5 = 1;
      if (!$1) {
       break __inlined_func$FLAC__subframe_add_verbatim$106
      }
      $3 = 0;
      while (1) {
       if (FLAC__bitwriter_write_raw_int32($4, HEAP32[$6 + ($3 << 2) >> 2], $2)) {
        $5 = 1;
        $3 = $3 + 1 | 0;
        if (($1 | 0) != ($3 | 0)) {
         continue
        }
        break block14;
       }
       break;
      };
      $5 = 0;
     }
    }
    if ($5) {
     break block4
    }
   }
   HEAP32[HEAP32[$0 >> 2] >> 2] = 7;
   $8 = 0;
  }
  return $8;
 }
 
 function FLAC__stream_encoder_set_ogg_serial_number($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $0 = HEAP32[$0 >> 2];
  if (HEAP32[$0 >> 2] == 1) {
   HEAP32[$0 + 632 >> 2] = $1;
   $0 = 1;
  } else {
   $0 = 0
  }
  return $0 | 0;
 }
 
 function FLAC__stream_encoder_set_verify($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $0 = HEAP32[$0 >> 2];
  if (HEAP32[$0 >> 2] == 1) {
   HEAP32[$0 + 4 >> 2] = $1;
   $2 = 1;
  }
  return $2 | 0;
 }
 
 function FLAC__stream_encoder_set_channels($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $0 = HEAP32[$0 >> 2];
  if (HEAP32[$0 >> 2] == 1) {
   HEAP32[$0 + 24 >> 2] = $1;
   $2 = 1;
  }
  return $2 | 0;
 }
 
 function FLAC__stream_encoder_set_bits_per_sample($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $0 = HEAP32[$0 >> 2];
  if (HEAP32[$0 >> 2] == 1) {
   HEAP32[$0 + 28 >> 2] = $1;
   $2 = 1;
  }
  return $2 | 0;
 }
 
 function FLAC__stream_encoder_set_sample_rate($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $0 = HEAP32[$0 >> 2];
  if (HEAP32[$0 >> 2] == 1) {
   HEAP32[$0 + 32 >> 2] = $1;
   $2 = 1;
  }
  return $2 | 0;
 }
 
 function FLAC__stream_encoder_set_compression_level($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0;
  $3 = HEAP32[$0 >> 2];
  block : {
   if (HEAP32[$3 >> 2] != 1) {
    break block
   }
   $2 = Math_imul($1 >>> 0 >= 8 ? 8 : $1, 44) + 17536 | 0;
   $1 = HEAP32[$2 + 4 >> 2];
   HEAP32[$3 + 16 >> 2] = HEAP32[$2 >> 2];
   HEAP32[$3 + 20 >> 2] = $1;
   $1 = FLAC__stream_encoder_set_apodization($0, HEAP32[$2 + 40 >> 2]);
   $0 = HEAP32[$0 >> 2];
   if (HEAP32[$0 >> 2] != 1) {
    break block
   }
   HEAP32[$0 + 576 >> 2] = 0;
   HEAP32[$0 + 568 >> 2] = 0;
   HEAP32[$0 + 560 >> 2] = 0;
   HEAP32[$0 + 564 >> 2] = 0;
   HEAP32[$0 + 580 >> 2] = HEAP32[$2 + 32 >> 2];
   HEAP32[$0 + 556 >> 2] = HEAP32[$2 + 8 >> 2];
   $4 = $1;
  }
  return $4 | 0;
 }
 
 function FLAC__stream_encoder_set_blocksize($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $0 = HEAP32[$0 >> 2];
  if (HEAP32[$0 >> 2] == 1) {
   HEAP32[$0 + 36 >> 2] = $1;
   $2 = 1;
  }
  return $2 | 0;
 }
 
 function FLAC__stream_encoder_set_metadata($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0;
  $3 = HEAP32[$0 >> 2];
  if (HEAP32[$3 >> 2] != 1) {
   return 0
  }
  $4 = HEAP32[$3 + 600 >> 2];
  if ($4) {
   emscripten_builtin_free($4);
   $3 = HEAP32[$0 >> 2];
   HEAP32[$3 + 600 >> 2] = 0;
   HEAP32[$3 + 604 >> 2] = 0;
  }
  $2 = $1 ? $2 : 0;
  if ($2) {
   $4 = safe_malloc_mul_2op_p(4, $2);
   if (!$4) {
    return 0
   }
   $3 = $2 << 2;
   if ($3) {
    wasm2js_memory_copy($4, $1, $3)
   }
   $3 = HEAP32[$0 >> 2];
   HEAP32[$3 + 604 >> 2] = $2;
   HEAP32[$3 + 600 >> 2] = $4;
  }
  if ($2 >>> HEAP32[1957] | 0) {
   $0 = 0
  } else {
   HEAP32[($3 + 632 | 0) + 4 >> 2] = $2;
   $0 = 1;
  }
  return ($0 | 0) != 0 | 0;
 }
 
 function FLAC__stream_encoder_get_verify_decoder_state($0) {
  $0 = $0 | 0;
  if (!HEAP32[HEAP32[$0 >> 2] + 4 >> 2]) {
   return 9
  }
  return FLAC__stream_decoder_get_state(HEAP32[HEAP32[$0 + 4 >> 2] + 11752 >> 2]) | 0;
 }
 
 function FLAC__stream_encoder_get_verify($0) {
  $0 = $0 | 0;
  return HEAP32[HEAP32[$0 >> 2] + 4 >> 2];
 }
 
 function FLAC__stream_encoder_process($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0;
  $4 = HEAP32[$0 >> 2];
  $11 = HEAP32[$4 + 24 >> 2];
  $19 = $11 & -4;
  $17 = $11 & 3;
  $20 = $11 & -2;
  $21 = $11 & 1;
  $13 = HEAP32[$4 + 36 >> 2];
  $22 = $13 + 1 | 0;
  $5 = HEAP32[$0 + 4 >> 2];
  $12 = $13 << 2;
  block6 : {
   while (1) {
    $3 = $22 - HEAP32[$5 + 7052 >> 2] | 0;
    $6 = $2 - $10 | 0;
    $6 = $3 >>> 0 < $6 >>> 0 ? $3 : $6;
    if (HEAP32[$4 + 4 >> 2]) {
     block1 : {
      if (!$11) {
       break block1
      }
      $9 = $5 + 11764 | 0;
      $4 = $6 << 2;
      $3 = 0;
      $7 = 0;
      if (($11 | 0) != 1) {
       while (1) {
        $16 = $10 << 2;
        $8 = $3 << 2;
        $14 = !$4;
        if (!$14) {
         wasm2js_memory_copy(HEAP32[$9 + $8 >> 2] + (HEAP32[$5 + 11800 >> 2] << 2) | 0, $16 + HEAP32[$1 + $8 >> 2] | 0, $4)
        }
        if (!$14) {
         $8 = $8 | 4;
         wasm2js_memory_copy(HEAP32[$8 + $9 >> 2] + (HEAP32[$5 + 11800 >> 2] << 2) | 0, $16 + HEAP32[$1 + $8 >> 2] | 0, $4);
        }
        $3 = $3 + 2 | 0;
        $7 = $7 + 2 | 0;
        if (($7 | 0) != ($20 | 0)) {
         continue
        }
        break;
       }
      }
      if (!$21 | !$4) {
       break block1
      }
      $3 = $3 << 2;
      wasm2js_memory_copy(HEAP32[$3 + $9 >> 2] + (HEAP32[$5 + 11800 >> 2] << 2) | 0, HEAP32[$1 + $3 >> 2] + ($10 << 2) | 0, $4);
     }
     HEAP32[$5 + 11800 >> 2] = HEAP32[$5 + 11800 >> 2] + $6;
    }
    if ($11) {
     $5 = $6 << 2;
     $4 = 0;
     $3 = 0;
     while (1) {
      $9 = $3 << 2;
      $8 = HEAP32[$9 + $1 >> 2];
      if (!$8) {
       break block6
      }
      if ($5) {
       $7 = $9;
       $9 = HEAP32[$0 + 4 >> 2];
       wasm2js_memory_copy(HEAP32[($7 + $9 | 0) + 4 >> 2] + (HEAP32[$9 + 7052 >> 2] << 2) | 0, $8 + ($10 << 2) | 0, $5);
      }
      $3 = $3 + 1 | 0;
      if (($3 | 0) != ($11 | 0)) {
       continue
      }
      break;
     };
    }
    $4 = HEAP32[$0 >> 2];
    block9 : {
     if (HEAP32[$4 + 16 >> 2]) {
      $5 = HEAP32[$0 + 4 >> 2];
      $3 = HEAP32[$5 + 7052 >> 2];
      if ($2 >>> 0 <= $10 >>> 0 | $3 >>> 0 > $13 >>> 0) {
       break block9
      }
      $9 = HEAP32[$5 + 36 >> 2];
      $8 = HEAP32[$5 + 40 >> 2];
      $7 = HEAP32[$1 + 4 >> 2];
      $16 = HEAP32[$1 >> 2];
      while (1) {
       $14 = $3 << 2;
       $15 = $10 << 2;
       $18 = $15 + $16 | 0;
       $15 = $7 + $15 | 0;
       HEAP32[$14 + $8 >> 2] = HEAP32[$18 >> 2] - HEAP32[$15 >> 2];
       HEAP32[$9 + $14 >> 2] = HEAP32[$15 >> 2] + HEAP32[$18 >> 2] >> 1;
       $10 = $10 + 1 | 0;
       $3 = $3 + 1 | 0;
       if ($3 >>> 0 > $13 >>> 0) {
        break block9
       }
       if ($2 >>> 0 > $10 >>> 0) {
        continue
       }
       break;
      };
      break block9;
     }
     $10 = $6 + $10 | 0;
     $5 = HEAP32[$0 + 4 >> 2];
    }
    $3 = HEAP32[$5 + 7052 >> 2] + $6 | 0;
    HEAP32[$5 + 7052 >> 2] = $3;
    if ($3 >>> 0 > $13 >>> 0) {
     $4 = 0;
     if (!process_frame_($0, 0, 0)) {
      break block6
     }
     $5 = HEAP32[$0 + 4 >> 2];
     block11 : {
      if (!$11) {
       break block11
      }
      $9 = $5 + 4 | 0;
      $8 = 0;
      $3 = 0;
      if ($11 >>> 0 >= 4) {
       while (1) {
        $6 = $9 + ($3 << 2) | 0;
        $7 = HEAP32[$6 >> 2];
        HEAP32[$7 >> 2] = HEAP32[$7 + $12 >> 2];
        $7 = HEAP32[$6 + 4 >> 2];
        HEAP32[$7 >> 2] = HEAP32[$7 + $12 >> 2];
        $7 = HEAP32[$6 + 8 >> 2];
        HEAP32[$7 >> 2] = HEAP32[$7 + $12 >> 2];
        $6 = HEAP32[$6 + 12 >> 2];
        HEAP32[$6 >> 2] = HEAP32[$6 + $12 >> 2];
        $3 = $3 + 4 | 0;
        $4 = $4 + 4 | 0;
        if (($4 | 0) != ($19 | 0)) {
         continue
        }
        break;
       }
      }
      if (!$17) {
       break block11
      }
      while (1) {
       $4 = HEAP32[$9 + ($3 << 2) >> 2];
       HEAP32[$4 >> 2] = HEAP32[$4 + $12 >> 2];
       $3 = $3 + 1 | 0;
       $8 = $8 + 1 | 0;
       if (($8 | 0) != ($17 | 0)) {
        continue
       }
       break;
      };
     }
     $4 = HEAP32[$0 >> 2];
     if (HEAP32[$4 + 16 >> 2]) {
      $3 = HEAP32[$5 + 36 >> 2];
      HEAP32[$3 >> 2] = HEAP32[$3 + $12 >> 2];
      $3 = HEAP32[$5 + 40 >> 2];
      HEAP32[$3 >> 2] = HEAP32[$3 + $12 >> 2];
     }
     HEAP32[$5 + 7052 >> 2] = 1;
    }
    if ($2 >>> 0 > $10 >>> 0) {
     continue
    }
    break;
   };
   $4 = 1;
  }
  return $4 | 0;
 }
 
 function FLAC__stream_encoder_process_interleaved($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
  $3 = HEAP32[$0 >> 2];
  $13 = HEAP32[$3 + 36 >> 2];
  $19 = $13 + 1 | 0;
  $5 = HEAP32[$3 + 24 >> 2];
  block12 : {
   block15 : {
    if (!(!!HEAP32[$3 + 16 >> 2] & ($5 | 0) == 2)) {
     $24 = $5 & -4;
     $17 = $5 & 3;
     $18 = $1 + 4 | 0;
     $20 = $5 & -2;
     $21 = $5 & 1;
     $22 = $5 - 1 | 0;
     $6 = HEAP32[$0 + 4 >> 2];
     while (1) {
      if (HEAP32[HEAP32[$0 >> 2] + 4 >> 2]) {
       $7 = HEAP32[$6 + 11800 >> 2];
       $3 = $19 - HEAP32[$6 + 7052 >> 2] | 0;
       $4 = $2 - $8 | 0;
       $10 = $3 >>> 0 < $4 >>> 0 ? $3 : $4;
       block3 : {
        if (!$10) {
         break block3
        }
        if ($5) {
         $15 = $6 + 11764 | 0;
         $3 = Math_imul($5, $8);
         $14 = 0;
         while (1) {
          $4 = 0;
          $11 = 0;
          if ($22) {
           while (1) {
            $23 = $7 << 2;
            $16 = $15 + ($4 << 2) | 0;
            $12 = $3 << 2;
            HEAP32[$23 + HEAP32[$16 >> 2] >> 2] = HEAP32[$12 + $1 >> 2];
            HEAP32[$23 + HEAP32[$16 + 4 >> 2] >> 2] = HEAP32[$18 + $12 >> 2];
            $4 = $4 + 2 | 0;
            $3 = $3 + 2 | 0;
            $11 = $11 + 2 | 0;
            if (($20 | 0) != ($11 | 0)) {
             continue
            }
            break;
           }
          }
          if ($21) {
           HEAP32[HEAP32[$15 + ($4 << 2) >> 2] + ($7 << 2) >> 2] = HEAP32[($3 << 2) + $1 >> 2];
           $3 = $3 + 1 | 0;
          }
          $7 = $7 + 1 | 0;
          $14 = $14 + 1 | 0;
          if (($14 | 0) != ($10 | 0)) {
           continue
          }
          break;
         };
         break block3;
        }
        $7 = $7 + $10 | 0;
       }
       HEAP32[$6 + 11800 >> 2] = $7;
      }
      $10 = $2 >>> 0 > $8 >>> 0;
      $7 = HEAP32[$6 + 7052 >> 2];
      block7 : {
       if ($2 >>> 0 <= $8 >>> 0 | $7 >>> 0 > $13 >>> 0) {
        break block7
       }
       if ($5) {
        $11 = $6 + 4 | 0;
        while (1) {
         $3 = 0;
         $4 = 0;
         if ($22) {
          while (1) {
           $15 = $7 << 2;
           $10 = $11 + ($3 << 2) | 0;
           $14 = $9 << 2;
           HEAP32[$15 + HEAP32[$10 >> 2] >> 2] = HEAP32[$14 + $1 >> 2];
           HEAP32[$15 + HEAP32[$10 + 4 >> 2] >> 2] = HEAP32[$14 + $18 >> 2];
           $3 = $3 + 2 | 0;
           $9 = $9 + 2 | 0;
           $4 = $4 + 2 | 0;
           if (($20 | 0) != ($4 | 0)) {
            continue
           }
           break;
          }
         }
         if ($21) {
          HEAP32[HEAP32[$11 + ($3 << 2) >> 2] + ($7 << 2) >> 2] = HEAP32[($9 << 2) + $1 >> 2];
          $9 = $9 + 1 | 0;
         }
         $8 = $8 + 1 | 0;
         $10 = $8 >>> 0 < $2 >>> 0;
         $7 = $7 + 1 | 0;
         if ($7 >>> 0 > $13 >>> 0) {
          break block7
         }
         if ($2 >>> 0 > $8 >>> 0) {
          continue
         }
         break;
        };
        break block7;
       }
       while (1) {
        $8 = $8 + 1 | 0;
        $10 = $8 >>> 0 < $2 >>> 0;
        $7 = $7 + 1 | 0;
        if ($7 >>> 0 > $13 >>> 0) {
         break block7
        }
        if ($2 >>> 0 > $8 >>> 0) {
         continue
        }
        break;
       };
      }
      HEAP32[$6 + 7052 >> 2] = $7;
      if ($7 >>> 0 > $13 >>> 0) {
       $12 = 0;
       if (!process_frame_($0, 0, 0)) {
        break block12
       }
       $6 = HEAP32[$0 + 4 >> 2];
       block13 : {
        if (!$5) {
         break block13
        }
        $15 = $6 + 4 | 0;
        $14 = 0;
        $3 = 0;
        $7 = 0;
        if ($5 >>> 0 >= 4) {
         while (1) {
          $4 = $15 + ($3 << 2) | 0;
          $11 = HEAP32[$4 >> 2];
          $12 = $11;
          $11 = $13 << 2;
          HEAP32[$12 >> 2] = HEAP32[$12 + $11 >> 2];
          $16 = HEAP32[$4 + 4 >> 2];
          HEAP32[$16 >> 2] = HEAP32[$11 + $16 >> 2];
          $16 = HEAP32[$4 + 8 >> 2];
          HEAP32[$16 >> 2] = HEAP32[$11 + $16 >> 2];
          $4 = HEAP32[$4 + 12 >> 2];
          HEAP32[$4 >> 2] = HEAP32[$4 + $11 >> 2];
          $3 = $3 + 4 | 0;
          $7 = $7 + 4 | 0;
          if (($7 | 0) != ($24 | 0)) {
           continue
          }
          break;
         }
        }
        if (!$17) {
         break block13
        }
        while (1) {
         $4 = HEAP32[$15 + ($3 << 2) >> 2];
         HEAP32[$4 >> 2] = HEAP32[$4 + ($13 << 2) >> 2];
         $3 = $3 + 1 | 0;
         $14 = $14 + 1 | 0;
         if (($14 | 0) != ($17 | 0)) {
          continue
         }
         break;
        };
       }
       HEAP32[$6 + 7052 >> 2] = 1;
      }
      if ($10) {
       continue
      }
      break;
     };
     break block15;
    }
    $5 = HEAP32[$0 + 4 >> 2];
    while (1) {
     if (HEAP32[HEAP32[$0 >> 2] + 4 >> 2]) {
      $9 = HEAP32[$5 + 11800 >> 2];
      $3 = $19 - HEAP32[$5 + 7052 >> 2] | 0;
      $6 = $2 - $4 | 0;
      $6 = $3 >>> 0 < $6 >>> 0 ? $3 : $6;
      if ($6) {
       $3 = $4 << 1;
       $8 = HEAP32[$5 + 11768 >> 2];
       $7 = HEAP32[$5 + 11764 >> 2];
       $10 = 0;
       while (1) {
        $17 = $9 << 2;
        $18 = ($3 << 2) + $1 | 0;
        HEAP32[$17 + $7 >> 2] = HEAP32[$18 >> 2];
        HEAP32[$8 + $17 >> 2] = HEAP32[$18 + 4 >> 2];
        $9 = $9 + 1 | 0;
        $3 = $3 + 2 | 0;
        $10 = $10 + 1 | 0;
        if (($6 | 0) != ($10 | 0)) {
         continue
        }
        break;
       };
      }
      HEAP32[$5 + 11800 >> 2] = $9;
     }
     $9 = $2 >>> 0 > $4 >>> 0;
     $3 = HEAP32[$5 + 7052 >> 2];
     block18 : {
      if ($2 >>> 0 <= $4 >>> 0 | $3 >>> 0 > $13 >>> 0) {
       break block18
      }
      $7 = HEAP32[$5 + 36 >> 2];
      $10 = HEAP32[$5 + 40 >> 2];
      $17 = HEAP32[$5 + 8 >> 2];
      $18 = HEAP32[$5 + 4 >> 2];
      while (1) {
       $9 = $3 << 2;
       $8 = ($11 << 2) + $1 | 0;
       $6 = HEAP32[$8 >> 2];
       HEAP32[$9 + $18 >> 2] = $6;
       $8 = HEAP32[$8 + 4 >> 2];
       HEAP32[$9 + $17 >> 2] = $8;
       HEAP32[$9 + $10 >> 2] = $6 - $8;
       HEAP32[$7 + $9 >> 2] = $6 + $8 >> 1;
       $11 = $11 + 2 | 0;
       $4 = $4 + 1 | 0;
       $9 = $4 >>> 0 < $2 >>> 0;
       $3 = $3 + 1 | 0;
       if ($3 >>> 0 > $13 >>> 0) {
        break block18
       }
       if ($2 >>> 0 > $4 >>> 0) {
        continue
       }
       break;
      };
     }
     HEAP32[$5 + 7052 >> 2] = $3;
     if ($3 >>> 0 > $13 >>> 0) {
      $12 = 0;
      if (!process_frame_($0, 0, 0)) {
       break block12
      }
      $5 = HEAP32[$0 + 4 >> 2];
      $3 = HEAP32[$5 + 4 >> 2];
      $12 = $3;
      $3 = $13 << 2;
      HEAP32[$12 >> 2] = HEAP32[$12 + $3 >> 2];
      $6 = HEAP32[$5 + 8 >> 2];
      HEAP32[$6 >> 2] = HEAP32[$3 + $6 >> 2];
      $6 = HEAP32[$5 + 36 >> 2];
      HEAP32[$6 >> 2] = HEAP32[$3 + $6 >> 2];
      $6 = HEAP32[$5 + 40 >> 2];
      HEAP32[$6 >> 2] = HEAP32[$3 + $6 >> 2];
      HEAP32[$5 + 7052 >> 2] = 1;
     }
     if ($9) {
      continue
     }
     break;
    };
   }
   $12 = 1;
  }
  return $12 | 0;
 }
 
 function find_best_partition_order_($0, $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12) {
  var $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0;
  $31 = $4 + $5 | 0;
  $14 = $31;
  while (1) {
   $15 = $9;
   if ($9) {
    $9 = $9 - 1 | 0;
    if ($14 >>> $15 >>> 0 <= $5 >>> 0) {
     continue
    }
   }
   break;
  };
  $14 = $15;
  $27 = $8 >>> 0 < $14 >>> 0 ? $8 : $14;
  FUNCTION_TABLE[HEAP32[$0 + 7220 >> 2]]($1, $2, $4, $5, $27, $14, $10);
  block : {
   if (!$11) {
    break block
   }
   $9 = 0;
   $8 = 0;
   if (($14 | 0) >= 0) {
    $25 = $1 + 12 | 0;
    $26 = $1 + 8 | 0;
    $28 = $1 + 4 | 0;
    $22 = $31 >>> $14 | 0;
    $8 = 1 << $14;
    while (1) {
     $29 = ($20 << 2) + $3 | 0;
     $16 = $20 ? 0 : $5;
     if (($22 | 0) == ($16 | 0)) {
      $10 = 1
     } else {
      $17 = $22 - $16 | 0;
      $21 = $17 & 3;
      $15 = 0;
      $13 = 0;
      $10 = $23;
      if ($16 - $22 >>> 0 <= 4294967292) {
       $30 = $17 & -4;
       $17 = 0;
       while (1) {
        $18 = $10 << 2;
        $19 = HEAP32[$18 + $25 >> 2];
        $24 = $19 >> 31 ^ $19;
        $19 = HEAP32[$1 + $18 >> 2];
        $19 = $13 | $19 >> 31 ^ $19;
        $13 = HEAP32[$18 + $28 >> 2];
        $19 = $19 | $13 >> 31 ^ $13;
        $13 = HEAP32[$18 + $26 >> 2];
        $13 = $24 | ($19 | $13 >> 31 ^ $13);
        $10 = $10 + 4 | 0;
        $17 = $17 + 4 | 0;
        if (($30 | 0) != ($17 | 0)) {
         continue
        }
        break;
       };
      }
      if ($21) {
       while (1) {
        $17 = HEAP32[($10 << 2) + $1 >> 2];
        $13 = $13 | $17 >> 31 ^ $17;
        $10 = $10 + 1 | 0;
        $15 = $15 + 1 | 0;
        if (($21 | 0) != ($15 | 0)) {
         continue
        }
        break;
       }
      }
      $23 = ($22 + $23 | 0) - $16 | 0;
      $10 = $13 ? (Math_clz32($13) ^ 31) + 2 | 0 : 1;
     }
     HEAP32[$29 >> 2] = $10;
     $20 = $20 + 1 | 0;
     if (($20 | 0) != ($8 | 0)) {
      continue
     }
     break;
    };
   }
   if (($14 | 0) <= ($27 | 0)) {
    break block
   }
   $15 = $14;
   while (1) {
    $15 = $15 - 1 | 0;
    $10 = 0;
    while (1) {
     $1 = ($9 << 2) + $3 | 0;
     $13 = HEAP32[$1 >> 2];
     $1 = HEAP32[$1 + 4 >> 2];
     HEAP32[($8 << 2) + $3 >> 2] = $1 >>> 0 < $13 >>> 0 ? $13 : $1;
     $8 = $8 + 1 | 0;
     $9 = $9 + 2 | 0;
     $10 = $10 + 1 | 0;
     if (!($10 >>> $15 | 0)) {
      continue
     }
     break;
    };
    if (($15 | 0) > ($27 | 0)) {
     continue
    }
    break;
   };
  }
  $25 = 0;
  $23 = 0;
  $18 = 0;
  block6 : {
   if (($14 | 0) < ($27 | 0)) {
    break block6
   }
   $32 = HEAP32[1684];
   $37 = $32 + (Math_imul($6 + 1 | 0, $4) - ($4 >>> 1 | 0) | 0) | 0;
   $38 = $7 - 1 | 0;
   $39 = $0 + 11724 | 0;
   $30 = HEAP32[1686] + HEAP32[1685] | 0;
   $22 = HEAP32[1683] + HEAP32[1682] | 0;
   $19 = $6 - 1 | 0;
   $26 = 0;
   while (1) {
    $33 = $23 ^ 1;
    $1 = Math_imul($33, 12) + $39 | 0;
    FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size($1, $14 >>> 0 <= 6 ? 6 : $14);
    $34 = ($26 << 2) + $3 | 0;
    $28 = ($26 << 3) + $2 | 0;
    $35 = HEAP32[$1 + 4 >> 2];
    $29 = HEAP32[$1 >> 2];
    block17 : {
     if ($14) {
      $36 = $31 >>> $14 | 0;
      $21 = 0;
      $1 = 0;
      $17 = $22;
      while (1) {
       if (!$21 & $5 >>> 0 >= $36 >>> 0) {
        break block6
       }
       $15 = $36 - ($21 ? 0 : $5) | 0;
       $8 = $28 + ($21 << 3) | 0;
       $13 = HEAP32[$8 >> 2];
       $8 = HEAP32[$8 + 4 >> 2];
       $16 = $8;
       block14 : {
        block11 : {
         block10 : {
          if (!(!$8 & $13 >>> 0 > 268435456 | ($8 | 0) != 0)) {
           $8 = 0;
           $9 = $15;
           if ($13 >>> 0 > $9 << 3 >>> 0) {
            break block10
           }
           break block11;
          }
          $9 = $15;
          $20 = 0;
          $8 = 0;
          block13 : {
           if (!(!$13 & ($16 | 0) == 16777216 | $16 >>> 0 < 16777216)) {
            $10 = 0;
            break block13;
           }
           $10 = 0;
           $24 = $9 >>> 25 | 0;
           if (($16 | 0) == ($24 | 0) & $13 >>> 0 <= $9 << 7 >>> 0 | $16 >>> 0 < $24 >>> 0) {
            break block13
           }
           while (1) {
            $8 = $8 + 8 | 0;
            $24 = $20 << 15 | $9 >>> 17;
            $40 = $9 << 15;
            $10 = $20 << 8 | $9 >>> 24;
            $9 = $9 << 8;
            $20 = $10;
            if (($16 | 0) == ($24 | 0) & $13 >>> 0 > $40 >>> 0 | $16 >>> 0 > $24 >>> 0) {
             continue
            }
            break;
           };
          }
          if (($10 | 0) == ($16 | 0) & $9 >>> 0 >= $13 >>> 0 | $10 >>> 0 > $16 >>> 0) {
           break block14
          }
          while (1) {
           $8 = $8 + 1 | 0;
           $10 = $10 << 1 | $9 >>> 31;
           $9 = $9 << 1;
           if (($16 | 0) == ($10 | 0) & $13 >>> 0 > $9 >>> 0 | $10 >>> 0 < $16 >>> 0) {
            continue
           }
           break;
          };
          break block14;
         }
         while (1) {
          $8 = $8 + 4 | 0;
          $10 = $9 << 7;
          $9 = $9 << 4;
          if ($10 >>> 0 < $13 >>> 0) {
           continue
          }
          break;
         };
        }
        if ($9 >>> 0 >= $13 >>> 0) {
         break block14
        }
        while (1) {
         $8 = $8 + 1 | 0;
         $9 = $9 << 1;
         if ($13 >>> 0 > $9 >>> 0) {
          continue
         }
         break;
        };
       }
       $9 = $7 >>> 0 > $8 >>> 0 ? $8 : $38;
       $20 = ($32 - ($15 >>> 1 | 0) | 0) + Math_imul($15, $9 + 1 | 0) | 0;
       $10 = $9 - 1 | 0;
       $8 = $10 & 31;
       if (($10 & 63) >>> 0 >= 32) {
        $8 = $16 >>> $8 | 0
       } else {
        $8 = ((1 << $8) - 1 & $16) << 32 - $8 | $13 >>> $8
       }
       $8 = $20 + ($9 ? $8 : $13 << 1) | 0;
       $10 = $21 << 2;
       $16 = $29 + $10 | 0;
       if ($11) {
        $1 = $15;
        $15 = $10;
        $13 = HEAP32[$10 + $34 >> 2];
        $1 = $30 + Math_imul($1, $13) | 0;
        $10 = $1 >>> 0 > $8 >>> 0;
        HEAP32[$15 + $35 >> 2] = $10 ? 0 : $13;
        $8 = $1 >>> 0 < $8 >>> 0 ? $1 : $8;
        $1 = $10 ? $9 : 0;
       } else {
        $1 = ($8 | 0) == -1 ? $1 : $9
       }
       HEAP32[$16 >> 2] = $1;
       $17 = $8 + $17 | 0;
       $21 = $21 + 1 | 0;
       if (!($21 >>> $14 | 0)) {
        continue
       }
       break;
      };
      break block17;
     }
     $8 = HEAP32[$28 + 4 >> 2];
     $9 = HEAP32[$28 >> 2];
     $1 = $19 & 31;
     if (($19 & 63) >>> 0 >= 32) {
      $1 = $8 >>> $1 | 0
     } else {
      $1 = ((1 << $1) - 1 & $8) << 32 - $1 | $9 >>> $1
     }
     $8 = ($6 ? $1 : $9 << 1) + $37 | 0;
     if ($11) {
      $10 = HEAP32[$34 >> 2];
      $1 = $30 + Math_imul($10, $4) | 0;
      $9 = $1 >>> 0 > $8 >>> 0;
      HEAP32[$35 >> 2] = $9 ? 0 : $10;
      $8 = $1 >>> 0 < $8 >>> 0 ? $1 : $8;
      $1 = $9 ? $6 : 0;
     } else {
      $1 = ($8 | 0) != -1 ? $6 : 0
     }
     HEAP32[$29 >> 2] = $1;
     $17 = $8 + $22 | 0;
    }
    $1 = $25 - 1 >>> 0 < $17 >>> 0;
    $18 = $1 ? $18 : $14;
    $23 = $1 ? $23 : $33;
    $25 = $1 ? $25 : $17;
    $26 = (1 << $14) + $26 | 0;
    $1 = ($14 | 0) > ($27 | 0);
    $14 = $14 - 1 | 0;
    if ($1) {
     continue
    }
    break;
   };
  }
  HEAP32[$12 + 4 >> 2] = $18;
  $1 = HEAP32[$12 + 8 >> 2];
  FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size($1, $18 >>> 0 <= 6 ? 6 : $18);
  $0 = Math_imul($23, 12) + $0 | 0;
  $2 = 4 << $18;
  $3 = !$2;
  if (!$3) {
   wasm2js_memory_copy(HEAP32[$1 >> 2], HEAP32[$0 + 11724 >> 2], $2)
  }
  if (!($3 | !$11)) {
   wasm2js_memory_copy(HEAP32[$1 + 4 >> 2], HEAP32[($0 + 11724 | 0) + 4 >> 2], $2)
  }
  $0 = HEAP32[1687];
  $1 = HEAP32[$1 >> 2];
  $8 = 0;
  block23 : {
   while (1) {
    if (HEAPU32[$1 + ($8 << 2) >> 2] < $0 >>> 0) {
     $8 = $8 + 1 | 0;
     if (!($8 >>> $18 | 0)) {
      continue
     }
     break block23;
    }
    break;
   };
   HEAP32[$12 >> 2] = 1;
  }
  return $25;
 }
 
 function _emscripten_stack_restore($0) {
  $0 = $0 | 0;
  __stack_pointer = $0;
 }
 
 function _emscripten_stack_alloc($0) {
  $0 = $0 | 0;
  $0 = __stack_pointer - $0 & -16;
  __stack_pointer = $0;
  return $0 | 0;
 }
 
 function emscripten_stack_get_current() {
  return __stack_pointer | 0;
 }
 
 function legalstub$FLAC__stream_encoder_set_total_samples_estimate($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0;
  $4 = HEAP32[$0 >> 2];
  if (HEAP32[$4 >> 2] == 1) {
   $3 = HEAP32[1640];
   $0 = $3 & 31;
   $5 = $1;
   if (($3 & 63) >>> 0 >= 32) {
    $0 = -1 << $0;
    $3 = 0;
   } else {
    $3 = -1 << $0;
    $0 = $3 | (1 << $0) - 1 & -1 >>> 32 - $0;
   }
   $3 = $3 ^ -1;
   $0 = $0 ^ -1;
   $1 = ($0 | 0) == ($2 | 0) & $1 >>> 0 < $3 >>> 0 | $0 >>> 0 > $2 >>> 0;
   HEAP32[$4 + 592 >> 2] = $1 ? $5 : $3;
   HEAP32[$4 + 596 >> 2] = $1 ? $2 : $0;
   $0 = 1;
  } else {
   $0 = 0
  }
  return $0 | 0;
 }
 
 function legalstub$dynCall_jiji($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  return FUNCTION_TABLE[$0 | 0]($1, $2, $3, $4) | 0;
 }
 
 function _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  label$1 : {
   label$2 : {
    label$3 : {
     label$4 : {
      label$5 : {
       label$6 : {
        label$7 : {
         label$9 : {
          label$11 : {
           if ($1) {
            if (!$2) {
             break label$11
            }
            break label$9;
           }
           $1 = $0;
           $0 = ($0 >>> 0) / ($2 >>> 0) | 0;
           __wasm_intrinsics_temp_i64 = $1 - Math_imul($0, $2) | 0;
           __wasm_intrinsics_temp_i64$hi = 0;
           i64toi32_i32$HIGH_BITS = 0;
           return $0;
          }
          if (!$0) {
           break label$7
          }
          break label$6;
         }
         $3 = $2 - 1 | 0;
         if (!($3 & $2)) {
          break label$5
         }
         $6 = (Math_clz32($2) + 33 | 0) - Math_clz32($1) | 0;
         $5 = 0 - $6 | 0;
         break label$3;
        }
        __wasm_intrinsics_temp_i64 = 0;
        $0 = ($1 >>> 0) / 0 | 0;
        __wasm_intrinsics_temp_i64$hi = $1 - Math_imul($0, 0) | 0;
        i64toi32_i32$HIGH_BITS = 0;
        return $0;
       }
       $3 = 32 - Math_clz32($1) | 0;
       if ($3 >>> 0 < 31) {
        break label$4
       }
       break label$2;
      }
      __wasm_intrinsics_temp_i64 = $0 & $3;
      __wasm_intrinsics_temp_i64$hi = 0;
      if (($2 | 0) == 1) {
       break label$1
      }
      $3 = __wasm_ctz_i32($2);
      $2 = $3 & 31;
      if (($3 & 63) >>> 0 >= 32) {
       $0 = $1 >>> $2 | 0
      } else {
       $4 = $1 >>> $2 | 0;
       $0 = ((1 << $2) - 1 & $1) << 32 - $2 | $0 >>> $2;
      }
      i64toi32_i32$HIGH_BITS = $4;
      return $0;
     }
     $6 = $3 + 1 | 0;
     $5 = 63 - $3 | 0;
    }
    $4 = $6 & 63;
    $3 = $4 & 31;
    if ($4 >>> 0 >= 32) {
     $4 = 0;
     $7 = $1 >>> $3 | 0;
    } else {
     $4 = $1 >>> $3 | 0;
     $7 = ((1 << $3) - 1 & $1) << 32 - $3 | $0 >>> $3;
    }
    $5 = $5 & 63;
    $3 = $5 & 31;
    if ($5 >>> 0 >= 32) {
     $1 = $0 << $3;
     $0 = 0;
    } else {
     $1 = (1 << $3) - 1 & $0 >>> 32 - $3 | $1 << $3;
     $0 = $0 << $3;
    }
    if ($6) {
     $3 = $2 - 1 | 0;
     $10 = ($3 | 0) == -1 ? -1 : 0;
     while (1) {
      $8 = $4 << 1 | $7 >>> 31;
      $4 = $7 << 1 | $1 >>> 31;
      $5 = $10 - ($8 + ($4 >>> 0 > $3 >>> 0) | 0) >> 31;
      $9 = $2 & $5;
      $7 = $4 - $9 | 0;
      $4 = $8 - ($4 >>> 0 < $9 >>> 0) | 0;
      $1 = $1 << 1 | $0 >>> 31;
      $0 = $11 | $0 << 1;
      $8 = $5 & 1;
      $11 = $8;
      $6 = $6 - 1 | 0;
      if ($6) {
       continue
      }
      break;
     };
    }
    __wasm_intrinsics_temp_i64 = $7;
    __wasm_intrinsics_temp_i64$hi = $4;
    i64toi32_i32$HIGH_BITS = $1 << 1 | $0 >>> 31;
    return $8 | $0 << 1;
   }
   __wasm_intrinsics_temp_i64 = $0;
   __wasm_intrinsics_temp_i64$hi = $1;
   $0 = 0;
   $1 = 0;
  }
  i64toi32_i32$HIGH_BITS = $1;
  return $0;
 }
 
 function __wasm_ctz_i32($0) {
  if ($0) {
   return 31 - Math_clz32($0 - 1 ^ $0) | 0
  }
  return 32;
 }
 
 function __wasm_i64_mul($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  $4 = $2 >>> 16 | 0;
  $5 = $0 >>> 16 | 0;
  $9 = Math_imul($4, $5);
  $6 = $2 & 65535;
  $7 = $0 & 65535;
  $8 = Math_imul($6, $7);
  $5 = ($8 >>> 16 | 0) + Math_imul($5, $6) | 0;
  $4 = ($5 & 65535) + Math_imul($4, $7) | 0;
  i64toi32_i32$HIGH_BITS = (Math_imul($1, $2) + $9 | 0) + Math_imul($0, $3) + ($5 >>> 16) + ($4 >>> 16) | 0;
  return $8 & 65535 | $4 << 16;
 }
 
 function __wasm_i64_udiv($0, $1, $2) {
  return _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2);
 }
 
 function __wasm_i64_urem($0, $1) {
  _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, 588);
  i64toi32_i32$HIGH_BITS = __wasm_intrinsics_temp_i64$hi;
  return __wasm_intrinsics_temp_i64;
 }
 
 function __wasm_rotl_i32($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = $1 & 31;
  $3 = (-1 >>> $2 & $0) << $2;
  $2 = $0;
  $0 = 0 - $1 & 31;
  return $3 | ($2 & -1 << $0) >>> $0;
 }
 
 // EMSCRIPTEN_END_FUNCS
;
 bufferView = HEAPU8;
 initActiveSegments(imports);
 var FUNCTION_TABLE = Table([null, wrapper_cmp, seekpoint_compare_, __stdio_close, __stdio_read, __stdio_seek, FLAC__lpc_restore_signal, FLAC__lpc_restore_signal_wide, read_callback_, read_callback_proxy_, __emscripten_stdout_close, __stdio_write, __emscripten_stdout_seek, FLAC__lpc_compute_residual_from_qlp_coefficients, FLAC__lpc_compute_residual_from_qlp_coefficients_wide, FLAC__fixed_compute_best_predictor_wide, FLAC__fixed_compute_best_predictor, precompute_partition_info_sums_, FLAC__lpc_compute_autocorrelation, verify_read_callback_, verify_write_callback_, verify_metadata_callback_, verify_error_callback_]);
 function __wasm_memory_size() {
  return buffer.byteLength / 65536 | 0;
 }
 
 function __wasm_memory_grow(pagesToAdd) {
  pagesToAdd = pagesToAdd | 0;
  var oldPages = __wasm_memory_size() | 0;
  var newPages = oldPages + pagesToAdd | 0;
  if ((oldPages < newPages) && (newPages < 65536)) {
   var newBuffer = new ArrayBuffer(Math_imul(newPages, 65536));
   var newHEAP8 = new Int8Array(newBuffer);
   newHEAP8.set(HEAP8);
   HEAP8 = new Int8Array(newBuffer);
   HEAP16 = new Int16Array(newBuffer);
   HEAP32 = new Int32Array(newBuffer);
   HEAPU8 = new Uint8Array(newBuffer);
   HEAPU16 = new Uint16Array(newBuffer);
   HEAPU32 = new Uint32Array(newBuffer);
   HEAPF32 = new Float32Array(newBuffer);
   HEAPF64 = new Float64Array(newBuffer);
   buffer = newBuffer;
   bufferView = HEAPU8;
  }
  return oldPages;
 }
 
 return {
  "memory": Object.create(Object.prototype, {
   "grow": {
    "value": __wasm_memory_grow
   }, 
   "buffer": {
    "get": function () {
     return buffer;
    }
    
   }
  }), 
  "__wasm_call_ctors": __wasm_call_ctors, 
  "FLAC__stream_decoder_new": FLAC__stream_decoder_new, 
  "FLAC__stream_decoder_delete": FLAC__stream_decoder_delete, 
  "FLAC__stream_decoder_finish": FLAC__stream_decoder_finish, 
  "FLAC__stream_decoder_init_stream": FLAC__stream_decoder_init_stream, 
  "FLAC__stream_decoder_reset": FLAC__stream_decoder_reset, 
  "FLAC__stream_decoder_init_ogg_stream": FLAC__stream_decoder_init_ogg_stream, 
  "FLAC__stream_decoder_set_ogg_serial_number": FLAC__stream_decoder_set_ogg_serial_number, 
  "FLAC__stream_decoder_set_md5_checking": FLAC__stream_decoder_set_md5_checking, 
  "FLAC__stream_decoder_set_metadata_respond": FLAC__stream_decoder_set_metadata_respond, 
  "FLAC__stream_decoder_set_metadata_respond_application": FLAC__stream_decoder_set_metadata_respond_application, 
  "FLAC__stream_decoder_set_metadata_respond_all": FLAC__stream_decoder_set_metadata_respond_all, 
  "FLAC__stream_decoder_set_metadata_ignore": FLAC__stream_decoder_set_metadata_ignore, 
  "FLAC__stream_decoder_set_metadata_ignore_application": FLAC__stream_decoder_set_metadata_ignore_application, 
  "FLAC__stream_decoder_set_metadata_ignore_all": FLAC__stream_decoder_set_metadata_ignore_all, 
  "FLAC__stream_decoder_get_state": FLAC__stream_decoder_get_state, 
  "FLAC__stream_decoder_get_md5_checking": FLAC__stream_decoder_get_md5_checking, 
  "FLAC__stream_decoder_process_single": FLAC__stream_decoder_process_single, 
  "FLAC__stream_decoder_process_until_end_of_metadata": FLAC__stream_decoder_process_until_end_of_metadata, 
  "FLAC__stream_decoder_process_until_end_of_stream": FLAC__stream_decoder_process_until_end_of_stream, 
  "FLAC__stream_encoder_new": FLAC__stream_encoder_new, 
  "FLAC__stream_encoder_delete": FLAC__stream_encoder_delete, 
  "FLAC__stream_encoder_finish": FLAC__stream_encoder_finish, 
  "FLAC__stream_encoder_init_stream": FLAC__stream_encoder_init_stream, 
  "FLAC__stream_encoder_init_ogg_stream": FLAC__stream_encoder_init_ogg_stream, 
  "FLAC__stream_encoder_set_ogg_serial_number": FLAC__stream_encoder_set_ogg_serial_number, 
  "FLAC__stream_encoder_set_verify": FLAC__stream_encoder_set_verify, 
  "FLAC__stream_encoder_set_channels": FLAC__stream_encoder_set_channels, 
  "FLAC__stream_encoder_set_bits_per_sample": FLAC__stream_encoder_set_bits_per_sample, 
  "FLAC__stream_encoder_set_sample_rate": FLAC__stream_encoder_set_sample_rate, 
  "FLAC__stream_encoder_set_compression_level": FLAC__stream_encoder_set_compression_level, 
  "FLAC__stream_encoder_set_blocksize": FLAC__stream_encoder_set_blocksize, 
  "FLAC__stream_encoder_set_total_samples_estimate": legalstub$FLAC__stream_encoder_set_total_samples_estimate, 
  "FLAC__stream_encoder_set_metadata": FLAC__stream_encoder_set_metadata, 
  "FLAC__stream_encoder_get_state": FLAC__stream_decoder_get_state, 
  "FLAC__stream_encoder_get_verify_decoder_state": FLAC__stream_encoder_get_verify_decoder_state, 
  "FLAC__stream_encoder_get_verify": FLAC__stream_encoder_get_verify, 
  "FLAC__stream_encoder_process": FLAC__stream_encoder_process, 
  "FLAC__stream_encoder_process_interleaved": FLAC__stream_encoder_process_interleaved, 
  "_emscripten_stack_restore": _emscripten_stack_restore, 
  "_emscripten_stack_alloc": _emscripten_stack_alloc, 
  "emscripten_stack_get_current": emscripten_stack_get_current, 
  "__indirect_function_table": FUNCTION_TABLE, 
  "dynCall_jiji": legalstub$dynCall_jiji
 };
}

  return asmFunc(info);
}

)(info);
  },

  instantiate: /** @suppress{checkTypes} */ function(binary, info) {
    return {
      then: function(ok) {
        var module = new WebAssembly.Module(binary);
        ok({
          'instance': new WebAssembly.Instance(module, info)
        });
      }
    };
  },

  RuntimeError: Error,

  isWasm2js: true,
};
// end include: wasm2js.js
if (WebAssembly.isWasm2js) {
  // We don't need to actually download a wasm binary, mark it as present but
  // empty.
  wasmBinary = [];
}

// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we
// don't define it at all in release modes.  This matches the behaviour of
// MINIMAL_RUNTIME.
// TODO(sbc): Make this the default even without STRICT enabled.
/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    // This build was created without ASSERTIONS defined.  `assert()` should not
    // ever be called in this configuration but in case there are callers in
    // the wild leave this simple abort() implementation here for now.
    abort(text);
  }
}

// Memory management

var HEAP,
/** @type {!Int8Array} */
  HEAP8,
/** @type {!Uint8Array} */
  HEAPU8,
/** @type {!Int16Array} */
  HEAP16,
/** @type {!Uint16Array} */
  HEAPU16,
/** @type {!Int32Array} */
  HEAP32,
/** @type {!Uint32Array} */
  HEAPU32,
/** @type {!Float32Array} */
  HEAPF32,
/** @type {!Float64Array} */
  HEAPF64;

var runtimeInitialized = false;

// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

/**
 * Indicates whether filename is a base64 data URI.
 * @noinline
 */
var isDataURI = (filename) => filename.startsWith(dataURIPrefix);

/**
 * Indicates whether filename is delivered via file protocol (as opposed to http/https)
 * @noinline
 */
var isFileURI = (filename) => filename.startsWith('file://');

// include: runtime_shared.js
// include: runtime_stack_check.js
// end include: runtime_stack_check.js
// include: runtime_exceptions.js
// end include: runtime_exceptions.js
// include: runtime_debug.js
// end include: runtime_debug.js
// include: memoryprofiler.js
// end include: memoryprofiler.js


function updateMemoryViews() {
  var b = wasmMemory.buffer;
  Module['HEAP8'] = HEAP8 = new Int8Array(b);
  Module['HEAP16'] = HEAP16 = new Int16Array(b);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);
  Module['HEAP32'] = HEAP32 = new Int32Array(b);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);
}

// end include: runtime_shared.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

function preRun() {
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;

  
if (!Module['noFSInit'] && !FS.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  Module['monitorRunDependencies']?.(runDependencies);

}

function removeRunDependency(id) {
  runDependencies--;

  Module['monitorRunDependencies']?.(runDependencies);

  if (runDependencies == 0) {
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

/** @param {string|number=} what */
function abort(what) {
  Module['onAbort']?.(what);

  what = 'Aborted(' + what + ')';
  // TODO(sbc): Should we remove printing and leave it up to whoever
  // catches the exception?
  err(what);

  ABORT = true;

  what += '. Build with -sASSERTIONS for more info.';

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  // FIXME This approach does not work in Wasm EH because it currently does not assume
  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from
  // a trap or not based on a hidden field within the object. So at the moment
  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that
  // allows this in the wasm spec.

  // Suppress closure compiler warning here. Closure compiler's builtin extern
  // definition for WebAssembly.RuntimeError claims it takes no arguments even
  // though it can.
  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.
  /** @suppress {checkTypes} */
  var e = new WebAssembly.RuntimeError(what);

  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

var wasmBinaryFile;
function findWasmBinary() {
    var f = 'libflac.wasm';
    if (!isDataURI(f)) {
      return locateFile(f);
    }
    return f;
}

function getBinarySync(file) {
  if (file == wasmBinaryFile && wasmBinary) {
    return new Uint8Array(wasmBinary);
  }
  if (readBinary) {
    return readBinary(file);
  }
  throw 'both async and sync fetching of the wasm failed';
}

async function getWasmBinary(binaryFile) {
  // If we don't have the binary yet, load it asynchronously using readAsync.
  if (!wasmBinary) {
    // Fetch the binary using readAsync
    try {
      var response = await readAsync(binaryFile);
      return new Uint8Array(response);
    } catch {
      // Fall back to getBinarySync below;
    }
  }

  // Otherwise, getBinarySync should be able to get it synchronously
  return getBinarySync(binaryFile);
}

async function instantiateArrayBuffer(binaryFile, imports) {
  try {
    var binary = await getWasmBinary(binaryFile);
    var instance = await WebAssembly.instantiate(binary, imports);
    return instance;
  } catch (reason) {
    err(`failed to asynchronously prepare wasm: ${reason}`);

    abort(reason);
  }
}

async function instantiateAsync(binary, binaryFile, imports) {
  if (!binary &&
      typeof WebAssembly.instantiateStreaming == 'function' &&
      !isDataURI(binaryFile)
      // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
      && !isFileURI(binaryFile)
      // Avoid instantiateStreaming() on Node.js environment for now, as while
      // Node.js v18.1.0 implements it, it does not have a full fetch()
      // implementation yet.
      //
      // Reference:
      //   https://github.com/emscripten-core/emscripten/pull/16917
      && !ENVIRONMENT_IS_NODE
     ) {
    try {
      var response = fetch(binaryFile, { credentials: 'same-origin' });
      var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);
      return instantiationResult;
    } catch (reason) {
      // We expect the most common failure cause to be a bad MIME type for the binary,
      // in which case falling back to ArrayBuffer instantiation should work.
      err(`wasm streaming compile failed: ${reason}`);
      err('falling back to ArrayBuffer instantiation');
      // fall back of instantiateArrayBuffer below
    };
  }
  return instantiateArrayBuffer(binaryFile, imports);
}

function getWasmImports() {
  // prepare imports
  return {
    'env': wasmImports,
    'wasi_snapshot_preview1': wasmImports,
  }
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
async function createWasm() {
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    wasmExports = instance.exports;

    

    wasmMemory = wasmExports['memory'];
    
    updateMemoryViews();

    wasmTable = wasmExports['__indirect_function_table'];
    

    addOnInit(wasmExports['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');
    return wasmExports;
  }
  // wait for the pthread pool (if any)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above PTHREADS-enabled path.
    return receiveInstance(result['instance']);
  }

  var info = getWasmImports();

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to
  // run the instantiation parallel to any other async startup actions they are
  // performing.
  // Also pthreads and wasm workers initialize the wasm instance through this
  // path.
  if (Module['instantiateWasm']) {
    try {
      return Module['instantiateWasm'](info, receiveInstance);
    } catch(e) {
      err(`Module.instantiateWasm callback failed with error: ${e}`);
        return false;
    }
  }

  wasmBinaryFile ??= findWasmBinary();

    var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);
    var exports = receiveInstantiationResult(result);
    return exports;
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// === Body ===
// end include: preamble.js


  class ExitStatus {
      name = 'ExitStatus';
      constructor(status) {
        this.message = `Program terminated with exit(${status})`;
        this.status = status;
      }
    }

  var callRuntimeCallbacks = (callbacks) => {
      while (callbacks.length > 0) {
        // Pass the module as the first argument.
        callbacks.shift()(Module);
      }
    };

  
    /**
     * @param {number} ptr
     * @param {string} type
     */
  function getValue(ptr, type = 'i8') {
    if (type.endsWith('*')) type = '*';
    switch (type) {
      case 'i1': return HEAP8[ptr];
      case 'i8': return HEAP8[ptr];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': abort('to do getValue(i64) use WASM_BIGINT');
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      case '*': return HEAPU32[((ptr)>>2)];
      default: abort(`invalid type for getValue: ${type}`);
    }
  }

  var noExitRuntime = Module['noExitRuntime'] || true;

  
    /**
     * @param {number} ptr
     * @param {number} value
     * @param {string} type
     */
  function setValue(ptr, value, type = 'i8') {
    if (type.endsWith('*')) type = '*';
    switch (type) {
      case 'i1': HEAP8[ptr] = value; break;
      case 'i8': HEAP8[ptr] = value; break;
      case 'i16': HEAP16[((ptr)>>1)] = value; break;
      case 'i32': HEAP32[((ptr)>>2)] = value; break;
      case 'i64': abort('to do setValue(i64) use WASM_BIGINT');
      case 'float': HEAPF32[((ptr)>>2)] = value; break;
      case 'double': HEAPF64[((ptr)>>3)] = value; break;
      case '*': HEAPU32[((ptr)>>2)] = value; break;
      default: abort(`invalid type for setValue: ${type}`);
    }
  }

  var stackRestore = (val) => __emscripten_stack_restore(val);

  var stackSave = () => _emscripten_stack_get_current();

  var getHeapMax = () =>
      // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
      // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
      // for any code that deals with heap sizes, which would require special
      // casing all heap size related code to treat 0 specially.
      2147483648;
  
  var alignMemory = (size, alignment) => {
      return Math.ceil(size / alignment) * alignment;
    };
  
  var growMemory = (size) => {
      var b = wasmMemory.buffer;
      var pages = ((size - b.byteLength + 65535) / 65536) | 0;
      try {
        // round size grow request up to wasm page size (fixed 64KB per spec)
        wasmMemory.grow(pages); // .grow() takes a delta compared to the previous size
        updateMemoryViews();
        return 1 /*success*/;
      } catch(e) {
      }
      // implicit 0 return to save code size (caller will cast "undefined" into 0
      // anyhow)
    };
  var _emscripten_resize_heap = (requestedSize) => {
      var oldSize = HEAPU8.length;
      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.
      requestedSize >>>= 0;
      // With multithreaded builds, races can happen (another thread might increase the size
      // in between), so return a failure, and let the caller retry.
  
      // Memory resize rules:
      // 1.  Always increase heap size to at least the requested size, rounded up
      //     to next page multiple.
      // 2a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap
      //     geometrically: increase the heap size according to
      //     MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%), At most
      //     overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
      // 2b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap
      //     linearly: increase the heap size by at least
      //     MEMORY_GROWTH_LINEAR_STEP bytes.
      // 3.  Max size for the heap is capped at 2048MB-WASM_PAGE_SIZE, or by
      //     MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
      // 4.  If we were unable to allocate as much memory, it may be due to
      //     over-eager decision to excessively reserve due to (3) above.
      //     Hence if an allocation fails, cut down on the amount of excess
      //     growth, in an attempt to succeed to perform a smaller allocation.
  
      // A limit is set for how much we can grow. We should not exceed that
      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
  
      // Loop through potential heap size increases. If we attempt a too eager
      // reservation that fails, cut down on the attempted size and reserve a
      // smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
        // but limit overreserving (default to capping at +96MB overgrowth at most)
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
  
        var replacement = growMemory(newSize);
        if (replacement) {
  
          return true;
        }
      }
      return false;
    };

  var PATH = {
  isAbs:(path) => path.charAt(0) === '/',
  splitPath:(filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },
  normalizeArray:(parts, allowAboveRoot) => {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },
  normalize:(path) => {
        var isAbsolute = PATH.isAbs(path),
            trailingSlash = path.slice(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },
  dirname:(path) => {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.slice(0, -1);
        }
        return root + dir;
      },
  basename:(path) => path && path.match(/([^\/]+|\/)\/*$/)[1],
  join:(...paths) => PATH.normalize(paths.join('/')),
  join2:(l, r) => PATH.normalize(l + '/' + r),
  };
  
  var initRandomFill = () => {
      // This block is not needed on v19+ since crypto.getRandomValues is builtin
      if (ENVIRONMENT_IS_NODE) {
        var nodeCrypto = require('crypto');
        return (view) => nodeCrypto.randomFillSync(view);
      }
  
      return (view) => crypto.getRandomValues(view);
    };
  var randomFill = (view) => {
      // Lazily init on the first invocation.
      (randomFill = initRandomFill())(view);
    };
  
  
  
  var PATH_FS = {
  resolve:(...args) => {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? args[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path != 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },
  relative:(from, to) => {
        from = PATH_FS.resolve(from).slice(1);
        to = PATH_FS.resolve(to).slice(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      },
  };
  
  
  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;
  
    /**
     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given
     * array that contains uint8 values, returns a copy of that string as a
     * Javascript String object.
     * heapOrArray is either a regular array, or a JavaScript typed array view.
     * @param {number=} idx
     * @param {number=} maxBytesToRead
     * @return {string}
     */
  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      // TextDecoder needs to know the byte length in advance, it doesn't stop on
      // null terminator by itself.  Also, use the length info to avoid running tiny
      // strings through TextDecoder, since .subarray() allocates garbage.
      // (As a tiny code save trick, compare endPtr against endIdx using a negation,
      // so that undefined/NaN means Infinity)
      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
  
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = '';
      // If building with TextDecoder, we have already computed the string length
      // above, so test loop end condition against that
      while (idx < endPtr) {
        // For UTF8 byte structure, see:
        // http://en.wikipedia.org/wiki/UTF-8#Description
        // https://www.ietf.org/rfc/rfc2279.txt
        // https://tools.ietf.org/html/rfc3629
        var u0 = heapOrArray[idx++];
        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 0xF0) == 0xE0) {
          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
        } else {
          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);
        }
  
        if (u0 < 0x10000) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 0x10000;
          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
        }
      }
      return str;
    };
  
  var FS_stdin_getChar_buffer = [];
  
  var lengthBytesUTF8 = (str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        var c = str.charCodeAt(i); // possibly a lead surrogate
        if (c <= 0x7F) {
          len++;
        } else if (c <= 0x7FF) {
          len += 2;
        } else if (c >= 0xD800 && c <= 0xDFFF) {
          len += 4; ++i;
        } else {
          len += 3;
        }
      }
      return len;
    };
  
  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,
      // undefined and false each don't write out any bytes.
      if (!(maxBytesToWrite > 0))
        return 0;
  
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
      for (var i = 0; i < str.length; ++i) {
        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code
        // unit, not a Unicode code point of the character! So decode
        // UTF16->UTF32->UTF8.
        // See http://unicode.org/faq/utf_bom.html#utf16-3
        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description
        // and https://www.ietf.org/rfc/rfc2279.txt
        // and https://tools.ietf.org/html/rfc3629
        var u = str.charCodeAt(i); // possibly a lead surrogate
        if (u >= 0xD800 && u <= 0xDFFF) {
          var u1 = str.charCodeAt(++i);
          u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
        }
        if (u <= 0x7F) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 0x7FF) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 0xC0 | (u >> 6);
          heap[outIdx++] = 0x80 | (u & 63);
        } else if (u <= 0xFFFF) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 0xE0 | (u >> 12);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 0xF0 | (u >> 18);
          heap[outIdx++] = 0x80 | ((u >> 12) & 63);
          heap[outIdx++] = 0x80 | ((u >> 6) & 63);
          heap[outIdx++] = 0x80 | (u & 63);
        }
      }
      // Null-terminate the pointer to the buffer.
      heap[outIdx] = 0;
      return outIdx - startIdx;
    };
  /** @type {function(string, boolean=, number=)} */
  var intArrayFromString = (stringy, dontAddNull, length) => {
      var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
      if (dontAddNull) u8array.length = numBytesWritten;
      return u8array;
    };
  var FS_stdin_getChar = () => {
      if (!FS_stdin_getChar_buffer.length) {
        var result = null;
        if (ENVIRONMENT_IS_NODE) {
          // we will read data by chunks of BUFSIZE
          var BUFSIZE = 256;
          var buf = Buffer.alloc(BUFSIZE);
          var bytesRead = 0;
  
          // For some reason we must suppress a closure warning here, even though
          // fd definitely exists on process.stdin, and is even the proper way to
          // get the fd of stdin,
          // https://github.com/nodejs/help/issues/2136#issuecomment-523649904
          // This started to happen after moving this logic out of library_tty.js,
          // so it is related to the surrounding code in some unclear manner.
          /** @suppress {missingProperties} */
          var fd = process.stdin.fd;
  
          try {
            bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);
          } catch(e) {
            // Cross-platform differences: on Windows, reading EOF throws an
            // exception, but on other OSes, reading EOF returns 0. Uniformize
            // behavior by treating the EOF exception to return 0.
            if (e.toString().includes('EOF')) bytesRead = 0;
            else throw e;
          }
  
          if (bytesRead > 0) {
            result = buf.slice(0, bytesRead).toString('utf-8');
          }
        } else
        if (typeof window != 'undefined' &&
          typeof window.prompt == 'function') {
          // Browser.
          result = window.prompt('Input: ');  // returns null on cancel
          if (result !== null) {
            result += '\n';
          }
        } else
        {}
        if (!result) {
          return null;
        }
        FS_stdin_getChar_buffer = intArrayFromString(result, true);
      }
      return FS_stdin_getChar_buffer.shift();
    };
  var TTY = {
  ttys:[],
  init() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process.stdin.setEncoding('utf8');
        // }
      },
  shutdown() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process.stdin.pause();
        // }
      },
  register(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },
  stream_ops:{
  open(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },
  close(stream) {
          // flush any pending line data
          stream.tty.ops.fsync(stream.tty);
        },
  fsync(stream) {
          stream.tty.ops.fsync(stream.tty);
        },
  read(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.atime = Date.now();
          }
          return bytesRead;
        },
  write(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.mtime = stream.node.ctime = Date.now();
          }
          return i;
        },
  },
  default_tty_ops:{
  get_char(tty) {
          return FS_stdin_getChar();
        },
  put_char(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },
  fsync(tty) {
          if (tty.output?.length > 0) {
            out(UTF8ArrayToString(tty.output));
            tty.output = [];
          }
        },
  ioctl_tcgets(tty) {
          // typical setting
          return {
            c_iflag: 25856,
            c_oflag: 5,
            c_cflag: 191,
            c_lflag: 35387,
            c_cc: [
              0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a, 0x00,
              0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            ]
          };
        },
  ioctl_tcsets(tty, optional_actions, data) {
          // currently just ignore
          return 0;
        },
  ioctl_tiocgwinsz(tty) {
          return [24, 80];
        },
  },
  default_tty1_ops:{
  put_char(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },
  fsync(tty) {
          if (tty.output?.length > 0) {
            err(UTF8ArrayToString(tty.output));
            tty.output = [];
          }
        },
  },
  };
  
  
  var zeroMemory = (address, size) => {
      HEAPU8.fill(0, address, address + size);
    };
  
  var mmapAlloc = (size) => {
      abort();
    };
  var MEMFS = {
  ops_table:null,
  mount(mount) {
        return MEMFS.createNode(null, '/', 16895, 0);
      },
  createNode(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        MEMFS.ops_table ||= {
          dir: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              lookup: MEMFS.node_ops.lookup,
              mknod: MEMFS.node_ops.mknod,
              rename: MEMFS.node_ops.rename,
              unlink: MEMFS.node_ops.unlink,
              rmdir: MEMFS.node_ops.rmdir,
              readdir: MEMFS.node_ops.readdir,
              symlink: MEMFS.node_ops.symlink
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek
            }
          },
          file: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: {
              llseek: MEMFS.stream_ops.llseek,
              read: MEMFS.stream_ops.read,
              write: MEMFS.stream_ops.write,
              allocate: MEMFS.stream_ops.allocate,
              mmap: MEMFS.stream_ops.mmap,
              msync: MEMFS.stream_ops.msync
            }
          },
          link: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr,
              readlink: MEMFS.node_ops.readlink
            },
            stream: {}
          },
          chrdev: {
            node: {
              getattr: MEMFS.node_ops.getattr,
              setattr: MEMFS.node_ops.setattr
            },
            stream: FS.chrdev_stream_ops
          }
        };
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.atime = node.mtime = node.ctime = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
          parent.atime = parent.mtime = parent.ctime = node.atime;
        }
        return node;
      },
  getFileDataAsTypedArray(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },
  expandFileStorage(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
      },
  resizeFileStorage(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
        }
      },
  node_ops:{
  getattr(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.atime);
          attr.mtime = new Date(node.mtime);
          attr.ctime = new Date(node.ctime);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },
  setattr(node, attr) {
          for (const key of ["mode", "atime", "mtime", "ctime"]) {
            if (attr[key] != null) {
              node[key] = attr[key];
            }
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },
  lookup(parent, name) {
          throw MEMFS.doesNotExistError;
        },
  mknod(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },
  rename(old_node, new_dir, new_name) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {}
          if (new_node) {
            if (FS.isDir(old_node.mode)) {
              // if we're overwriting a directory at new_name, make sure it's empty.
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
            FS.hashRemoveNode(new_node);
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          new_dir.contents[new_name] = old_node;
          old_node.name = new_name;
          new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
        },
  unlink(parent, name) {
          delete parent.contents[name];
          parent.ctime = parent.mtime = Date.now();
        },
  rmdir(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.ctime = parent.mtime = Date.now();
        },
  readdir(node) {
          return ['.', '..', ...Object.keys(node.contents)];
        },
  symlink(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 0o777 | 40960, 0);
          node.link = oldpath;
          return node;
        },
  readlink(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        },
  },
  stream_ops:{
  read(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },
  write(stream, buffer, offset, length, position, canOwn) {
          // If the buffer is located in main memory (HEAP), and if
          // memory can grow, we can't hold on to references of the
          // memory buffer, as they may get invalidated. That means we
          // need to do copy its contents.
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
  
          if (!length) return 0;
          var node = stream.node;
          node.mtime = node.ctime = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            // Use typed array write which is available.
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },
  llseek(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },
  allocate(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },
  mmap(stream, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
            // We can't emulate MAP_SHARED when the file is not backed by the
            // buffer we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            if (contents) {
              // Try to avoid unnecessary slices.
              if (position > 0 || position + length < contents.length) {
                if (contents.subarray) {
                  contents = contents.subarray(position, position + length);
                } else {
                  contents = Array.prototype.slice.call(contents, position, position + length);
                }
              }
              HEAP8.set(contents, ptr);
            }
          }
          return { ptr, allocated };
        },
  msync(stream, buffer, offset, length, mmapFlags) {
          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        },
  },
  };
  
  var asyncLoad = async (url) => {
      var arrayBuffer = await readAsync(url);
      return new Uint8Array(arrayBuffer);
    };
  
  
  var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
    };
  
  var preloadPlugins = Module['preloadPlugins'] || [];
  var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
      // Ensure plugins are ready.
      if (typeof Browser != 'undefined') Browser.init();
  
      var handled = false;
      preloadPlugins.forEach((plugin) => {
        if (handled) return;
        if (plugin['canHandle'](fullname)) {
          plugin['handle'](byteArray, fullname, finish, onerror);
          handled = true;
        }
      });
      return handled;
    };
  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
      // TODO we should allow people to just pass in a complete filename instead
      // of parent and name being that we just join them anyways
      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
      var dep = getUniqueRunDependency(`cp ${fullname}`); // might have several active requests for the same fullname
      function processData(byteArray) {
        function finish(byteArray) {
          preFinish?.();
          if (!dontCreateFile) {
            FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
          }
          onload?.();
          removeRunDependency(dep);
        }
        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
          onerror?.();
          removeRunDependency(dep);
        })) {
          return;
        }
        finish(byteArray);
      }
      addRunDependency(dep);
      if (typeof url == 'string') {
        asyncLoad(url).then(processData, onerror);
      } else {
        processData(url);
      }
    };
  
  var FS_modeStringToFlags = (str) => {
      var flagModes = {
        'r': 0,
        'r+': 2,
        'w': 512 | 64 | 1,
        'w+': 512 | 64 | 2,
        'a': 1024 | 64 | 1,
        'a+': 1024 | 64 | 2,
      };
      var flags = flagModes[str];
      if (typeof flags == 'undefined') {
        throw new Error(`Unknown file open mode: ${str}`);
      }
      return flags;
    };
  
  var FS_getMode = (canRead, canWrite) => {
      var mode = 0;
      if (canRead) mode |= 292 | 73;
      if (canWrite) mode |= 146;
      return mode;
    };
  
  
  
  var FS = {
  root:null,
  mounts:[],
  devices:{
  },
  streams:[],
  nextInode:1,
  nameTable:null,
  currentPath:"/",
  initialized:false,
  ignorePermissions:true,
  ErrnoError:class {
        name = 'ErrnoError';
        // We set the `name` property to be able to identify `FS.ErrnoError`
        // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
        // - when using PROXYFS, an error can come from an underlying FS
        // as different FS objects have their own FS.ErrnoError each,
        // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
        // we'll use the reliable test `err.name == "ErrnoError"` instead
        constructor(errno) {
          this.errno = errno;
        }
      },
  filesystems:null,
  syncFSRequests:0,
  readFiles:{
  },
  FSStream:class {
        shared = {};
        get object() {
          return this.node;
        }
        set object(val) {
          this.node = val;
        }
        get isRead() {
          return (this.flags & 2097155) !== 1;
        }
        get isWrite() {
          return (this.flags & 2097155) !== 0;
        }
        get isAppend() {
          return (this.flags & 1024);
        }
        get flags() {
          return this.shared.flags;
        }
        set flags(val) {
          this.shared.flags = val;
        }
        get position() {
          return this.shared.position;
        }
        set position(val) {
          this.shared.position = val;
        }
      },
  FSNode:class {
        node_ops = {};
        stream_ops = {};
        readMode = 292 | 73;
        writeMode = 146;
        mounted = null;
        constructor(parent, name, mode, rdev) {
          if (!parent) {
            parent = this;  // root node sets parent to itself
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.id = FS.nextInode++;
          this.name = name;
          this.mode = mode;
          this.rdev = rdev;
          this.atime = this.mtime = this.ctime = Date.now();
        }
        get read() {
          return (this.mode & this.readMode) === this.readMode;
        }
        set read(val) {
          val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
        }
        get write() {
          return (this.mode & this.writeMode) === this.writeMode;
        }
        set write(val) {
          val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
        }
        get isFolder() {
          return FS.isDir(this.mode);
        }
        get isDevice() {
          return FS.isChrdev(this.mode);
        }
      },
  lookupPath(path, opts = {}) {
        if (!path) {
          throw new FS.ErrnoError(44);
        }
        opts.follow_mount ??= true
  
        if (!PATH.isAbs(path)) {
          path = FS.cwd() + '/' + path;
        }
  
        // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
        linkloop: for (var nlinks = 0; nlinks < 40; nlinks++) {
          // split the absolute path
          var parts = path.split('/').filter((p) => !!p);
  
          // start at the root
          var current = FS.root;
          var current_path = '/';
  
          for (var i = 0; i < parts.length; i++) {
            var islast = (i === parts.length-1);
            if (islast && opts.parent) {
              // stop resolving
              break;
            }
  
            if (parts[i] === '.') {
              continue;
            }
  
            if (parts[i] === '..') {
              current_path = PATH.dirname(current_path);
              current = current.parent;
              continue;
            }
  
            current_path = PATH.join2(current_path, parts[i]);
            try {
              current = FS.lookupNode(current, parts[i]);
            } catch (e) {
              // if noent_okay is true, suppress a ENOENT in the last component
              // and return an object with an undefined node. This is needed for
              // resolving symlinks in the path when creating a file.
              if ((e?.errno === 44) && islast && opts.noent_okay) {
                return { path: current_path };
              }
              throw e;
            }
  
            // jump to the mount's root node if this is a mountpoint
            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
              current = current.mounted.root;
            }
  
            // by default, lookupPath will not follow a symlink if it is the final path component.
            // setting opts.follow = true will override this behavior.
            if (FS.isLink(current.mode) && (!islast || opts.follow)) {
              if (!current.node_ops.readlink) {
                throw new FS.ErrnoError(52);
              }
              var link = current.node_ops.readlink(current);
              if (!PATH.isAbs(link)) {
                link = PATH.dirname(current_path) + '/' + link;
              }
              path = link + '/' + parts.slice(i + 1).join('/');
              continue linkloop;
            }
          }
          return { path: current_path, node: current };
        }
        throw new FS.ErrnoError(32);
      },
  getPath(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? `${mount}/${path}` : mount + path;
          }
          path = path ? `${node.name}/${path}` : node.name;
          node = node.parent;
        }
      },
  hashName(parentid, name) {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },
  hashAddNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },
  hashRemoveNode(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },
  lookupNode(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },
  createNode(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },
  destroyNode(node) {
        FS.hashRemoveNode(node);
      },
  isRoot(node) {
        return node === node.parent;
      },
  isMountpoint(node) {
        return !!node.mounted;
      },
  isFile(mode) {
        return (mode & 61440) === 32768;
      },
  isDir(mode) {
        return (mode & 61440) === 16384;
      },
  isLink(mode) {
        return (mode & 61440) === 40960;
      },
  isChrdev(mode) {
        return (mode & 61440) === 8192;
      },
  isBlkdev(mode) {
        return (mode & 61440) === 24576;
      },
  isFIFO(mode) {
        return (mode & 61440) === 4096;
      },
  isSocket(mode) {
        return (mode & 49152) === 49152;
      },
  flagsToPermissionString(flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },
  nodePermissions(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },
  mayLookup(dir) {
        if (!FS.isDir(dir.mode)) return 54;
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },
  mayCreate(dir, name) {
        if (!FS.isDir(dir.mode)) {
          return 54;
        }
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },
  mayDelete(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },
  mayOpen(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' // opening for write
              || (flags & (512 | 64))) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },
  checkOpExists(op, err) {
        if (!op) {
          throw new FS.ErrnoError(err);
        }
        return op;
      },
  MAX_OPEN_FDS:4096,
  nextfd() {
        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },
  getStreamChecked(fd) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        return stream;
      },
  getStream:(fd) => FS.streams[fd],
  createStream(stream, fd = -1) {
  
        // clone it, so we can return an instance of FSStream
        stream = Object.assign(new FS.FSStream(), stream);
        if (fd == -1) {
          fd = FS.nextfd();
        }
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },
  closeStream(fd) {
        FS.streams[fd] = null;
      },
  dupStream(origStream, fd = -1) {
        var stream = FS.createStream(origStream, fd);
        stream.stream_ops?.dup?.(stream);
        return stream;
      },
  doSetAttr(stream, node, attr) {
        var setattr = stream?.stream_ops.setattr;
        var arg = setattr ? stream : node;
        setattr ??= node.node_ops.setattr;
        FS.checkOpExists(setattr, 63)
        setattr(arg, attr);
      },
  chrdev_stream_ops:{
  open(stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          stream.stream_ops.open?.(stream);
        },
  llseek() {
          throw new FS.ErrnoError(70);
        },
  },
  major:(dev) => ((dev) >> 8),
  minor:(dev) => ((dev) & 0xff),
  makedev:(ma, mi) => ((ma) << 8 | (mi)),
  registerDevice(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },
  getDevice:(dev) => FS.devices[dev],
  getMounts(mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push(...m.mounts);
        }
  
        return mounts;
      },
  syncfs(populate, callback) {
        if (typeof populate == 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },
  mount(type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type,
          opts,
          mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },
  unmount(mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach((hash) => {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },
  lookup(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },
  mknod(path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name) {
          throw new FS.ErrnoError(28);
        }
        if (name === '.' || name === '..') {
          throw new FS.ErrnoError(20);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },
  statfs(path) {
        return FS.statfsNode(FS.lookupPath(path, {follow: true}).node);
      },
  statfsStream(stream) {
        // We keep a separate statfsStream function because noderawfs overrides
        // it. In noderawfs, stream.node is sometimes null. Instead, we need to
        // look at stream.path.
        return FS.statfsNode(stream.node);
      },
  statfsNode(node) {
        // NOTE: None of the defaults here are true. We're just returning safe and
        //       sane values. Currently nodefs and rawfs replace these defaults,
        //       other file systems leave them alone.
        var rtn = {
          bsize: 4096,
          frsize: 4096,
          blocks: 1e6,
          bfree: 5e5,
          bavail: 5e5,
          files: FS.nextInode,
          ffree: FS.nextInode - 1,
          fsid: 42,
          flags: 2,
          namelen: 255,
        };
  
        if (node.node_ops.statfs) {
          Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
        }
        return rtn;
      },
  create(path, mode = 0o666) {
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },
  mkdir(path, mode = 0o777) {
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },
  mkdirTree(path, mode) {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },
  mkdev(path, mode, dev) {
        if (typeof dev == 'undefined') {
          dev = mode;
          mode = 0o666;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },
  symlink(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },
  rename(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
  
        // let the errors from non existent directories percolate up
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
          // update old node (we do this here to avoid each backend
          // needing to)
          old_node.parent = new_dir;
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },
  rmdir(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },
  readdir(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
        return readdir(node);
      },
  unlink(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },
  readlink(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return link.node_ops.readlink(link);
      },
  stat(path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
        return getattr(node);
      },
  fstat(fd) {
        var stream = FS.getStreamChecked(fd);
        var node = stream.node;
        var getattr = stream.stream_ops.getattr;
        var arg = getattr ? stream : node;
        getattr ??= node.node_ops.getattr;
        FS.checkOpExists(getattr, 63)
        return getattr(arg);
      },
  lstat(path) {
        return FS.stat(path, true);
      },
  doChmod(stream, node, mode, dontFollow) {
        FS.doSetAttr(stream, node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          ctime: Date.now(),
          dontFollow
        });
      },
  chmod(path, mode, dontFollow) {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        FS.doChmod(null, node, mode, dontFollow);
      },
  lchmod(path, mode) {
        FS.chmod(path, mode, true);
      },
  fchmod(fd, mode) {
        var stream = FS.getStreamChecked(fd);
        FS.doChmod(stream, stream.node, mode, false);
      },
  doChown(stream, node, dontFollow) {
        FS.doSetAttr(stream, node, {
          timestamp: Date.now(),
          dontFollow
          // we ignore the uid / gid for now
        });
      },
  chown(path, uid, gid, dontFollow) {
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        FS.doChown(null, node, dontFollow);
      },
  lchown(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },
  fchown(fd, uid, gid) {
        var stream = FS.getStreamChecked(fd);
        FS.doChown(stream, stream.node, false);
      },
  doTruncate(stream, node, len) {
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.doSetAttr(stream, node, {
          size: len,
          timestamp: Date.now()
        });
      },
  truncate(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        FS.doTruncate(null, node, len);
      },
  ftruncate(fd, len) {
        var stream = FS.getStreamChecked(fd);
        if (len < 0 || (stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.doTruncate(stream, stream.node, len);
      },
  utime(path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
        setattr(node, {
          atime: atime,
          mtime: mtime
        });
      },
  open(path, flags, mode = 0o666) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        var isDirPath;
        if (typeof path == 'object') {
          node = path;
        } else {
          isDirPath = path.endsWith("/");
          // noent_okay makes it so that if the final component of the path
          // doesn't exist, lookupPath returns `node: undefined`. `path` will be
          // updated to point to the target of all symlinks.
          var lookup = FS.lookupPath(path, {
            follow: !(flags & 131072),
            noent_okay: true
          });
          node = lookup.node;
          path = lookup.path;
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else if (isDirPath) {
            throw new FS.ErrnoError(31);
          } else {
            // node doesn't exist, try to create it
            // Ignore the permission bits here to ensure we can `open` this new
            // file below. We use chmod below the apply the permissions once the
            // file is open.
            node = FS.mknod(path, mode | 0o777, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512) && !created) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        });
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (created) {
          FS.chmod(node, mode & 0o777);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      },
  close(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },
  isClosed(stream) {
        return stream.fd === null;
      },
  llseek(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },
  read(stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },
  write(stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },
  allocate(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },
  mmap(stream, length, position, prot, flags) {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        if (!length) {
          throw new FS.ErrnoError(28);
        }
        return stream.stream_ops.mmap(stream, length, position, prot, flags);
      },
  msync(stream, buffer, offset, length, mmapFlags) {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },
  ioctl(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },
  readFile(path, opts = {}) {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error(`Invalid encoding type "${opts.encoding}"`);
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },
  writeFile(path, data, opts = {}) {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },
  cwd:() => FS.currentPath,
  chdir(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },
  createDefaultDirectories() {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },
  createDefaultDevices() {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: () => 0,
          write: (stream, buffer, offset, length, pos) => length,
          llseek: () => 0,
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using err() rather than out()
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        // use a buffer to avoid overhead of individual crypto calls per byte
        var randomBuffer = new Uint8Array(1024), randomLeft = 0;
        var randomByte = () => {
          if (randomLeft === 0) {
            randomFill(randomBuffer);
            randomLeft = randomBuffer.byteLength;
          }
          return randomBuffer[--randomLeft];
        };
        FS.createDevice('/dev', 'random', randomByte);
        FS.createDevice('/dev', 'urandom', randomByte);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },
  createSpecialDirectories() {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
        // name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount() {
            var node = FS.createNode(proc_self, 'fd', 16895, 73);
            node.stream_ops = {
              llseek: MEMFS.stream_ops.llseek,
            };
            node.node_ops = {
              lookup(parent, name) {
                var fd = +name;
                var stream = FS.getStreamChecked(fd);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: () => stream.path },
                  id: fd + 1,
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              },
              readdir() {
                return Array.from(FS.streams.entries())
                  .filter(([k, v]) => v)
                  .map(([k, v]) => k.toString());
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },
  createStandardStreams(input, output, error) {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (input) {
          FS.createDevice('/dev', 'stdin', input);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (output) {
          FS.createDevice('/dev', 'stdout', null, output);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (error) {
          FS.createDevice('/dev', 'stderr', null, error);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },
  staticInit() {
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },
  init(input, output, error) {
        FS.initialized = true;
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        input ??= Module['stdin'];
        output ??= Module['stdout'];
        error ??= Module['stderr'];
  
        FS.createStandardStreams(input, output, error);
      },
  quit() {
        FS.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },
  findObject(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      },
  analyzePath(path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },
  createPath(parent, path, canRead, canWrite) {
        parent = typeof parent == 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },
  createFile(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS_getMode(canRead, canWrite);
        return FS.create(path, mode);
      },
  createDataFile(parent, name, data, canRead, canWrite, canOwn) {
        var path = name;
        if (parent) {
          parent = typeof parent == 'string' ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS_getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
      },
  createDevice(parent, name, input, output) {
        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);
        var mode = FS_getMode(!!input, !!output);
        FS.createDevice.major ??= 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open(stream) {
            stream.seekable = false;
          },
          close(stream) {
            // flush any pending line data
            if (output?.buffer?.length) {
              output(10);
            }
          },
          read(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.atime = Date.now();
            }
            return bytesRead;
          },
          write(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.mtime = stream.node.ctime = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },
  forceLoadFile(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else { // Command-line.
          try {
            obj.contents = readBinary(obj.url);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
      },
  createLazyFile(parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array).
        // Actual getting is abstracted away for eventual reuse.
        class LazyUint8Array {
          lengthKnown = false;
          chunks = []; // Loaded chunks. Index is the chunk number
          get(idx) {
            if (idx > this.length-1 || idx < 0) {
              return undefined;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = (idx / this.chunkSize)|0;
            return this.getter(chunkNum)[chunkOffset];
          }
          setDataGetter(getter) {
            this.getter = getter;
          }
          cacheLength() {
            // Find length
            var xhr = new XMLHttpRequest();
            xhr.open('HEAD', url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
            var chunkSize = 1024*1024; // Chunk size in bytes
  
            if (!hasByteServing) chunkSize = datalength;
  
            // Function to get a range from the remote URL.
            var doXHR = (from, to) => {
              if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
              // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
              var xhr = new XMLHttpRequest();
              xhr.open('GET', url, false);
              if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
              // Some hints to the browser that we want binary data.
              xhr.responseType = 'arraybuffer';
              if (xhr.overrideMimeType) {
                xhr.overrideMimeType('text/plain; charset=x-user-defined');
              }
  
              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              if (xhr.response !== undefined) {
                return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
              }
              return intArrayFromString(xhr.responseText || '', true);
            };
            var lazyArray = this;
            lazyArray.setDataGetter((chunkNum) => {
              var start = chunkNum * chunkSize;
              var end = (chunkNum+1) * chunkSize - 1; // including this byte
              end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
              if (typeof lazyArray.chunks[chunkNum] == 'undefined') {
                lazyArray.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');
              return lazyArray.chunks[chunkNum];
            });
  
            if (usesGzip || !datalength) {
              // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
              chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out("LazyFiles on gzip forces download of the whole file when length is accessed");
            }
  
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          }
          get length() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._length;
          }
          get chunkSize() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._chunkSize;
          }
        }
  
        if (typeof XMLHttpRequest != 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach((key) => {
          var fn = node.stream_ops[key];
          stream_ops[key] = (...args) => {
            FS.forceLoadFile(node);
            return fn(...args);
          };
        });
        function writeChunks(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        }
        // use a custom read function
        stream_ops.read = (stream, buffer, offset, length, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length, position)
        };
        // use a custom mmap function
        stream_ops.mmap = (stream, length, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length, position);
          return { ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      },
  };
  
  
    /**
     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the
     * emscripten HEAP, returns a copy of that string as a Javascript String object.
     *
     * @param {number} ptr
     * @param {number=} maxBytesToRead - An optional length that specifies the
     *   maximum number of bytes to read. You can omit this parameter to scan the
     *   string until the first 0 byte. If maxBytesToRead is passed, and the string
     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the
     *   string will cut short at that byte index (i.e. maxBytesToRead will not
     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing
     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw
     *   JS JIT optimizations off, so it is worth to consider consistently using one
     * @return {string}
     */
  var UTF8ToString = (ptr, maxBytesToRead) => {
      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
    };
  var SYSCALLS = {
  DEFAULT_POLLMASK:5,
  calculateAt(dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        // relative path
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return dir + '/' + path;
      },
  writeStat(buf, stat) {
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(4))>>2)] = stat.mode;
        HEAPU32[(((buf)+(8))>>2)] = stat.nlink;
        HEAP32[(((buf)+(12))>>2)] = stat.uid;
        HEAP32[(((buf)+(16))>>2)] = stat.gid;
        HEAP32[(((buf)+(20))>>2)] = stat.rdev;
        (tempI64 = [stat.size>>>0,(tempDouble = stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(24))>>2)] = tempI64[0],HEAP32[(((buf)+(28))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(32))>>2)] = 4096;
        HEAP32[(((buf)+(36))>>2)] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        (tempI64 = [Math.floor(atime / 1000)>>>0,(tempDouble = Math.floor(atime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(48))>>2)] = (atime % 1000) * 1000 * 1000;
        (tempI64 = [Math.floor(mtime / 1000)>>>0,(tempDouble = Math.floor(mtime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(56))>>2)] = tempI64[0],HEAP32[(((buf)+(60))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(64))>>2)] = (mtime % 1000) * 1000 * 1000;
        (tempI64 = [Math.floor(ctime / 1000)>>>0,(tempDouble = Math.floor(ctime / 1000),(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(72))>>2)] = tempI64[0],HEAP32[(((buf)+(76))>>2)] = tempI64[1]);
        HEAPU32[(((buf)+(80))>>2)] = (ctime % 1000) * 1000 * 1000;
        (tempI64 = [stat.ino>>>0,(tempDouble = stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[(((buf)+(88))>>2)] = tempI64[0],HEAP32[(((buf)+(92))>>2)] = tempI64[1]);
        return 0;
      },
  writeStatFs(buf, stats) {
        HEAP32[(((buf)+(4))>>2)] = stats.bsize;
        HEAP32[(((buf)+(40))>>2)] = stats.bsize;
        HEAP32[(((buf)+(8))>>2)] = stats.blocks;
        HEAP32[(((buf)+(12))>>2)] = stats.bfree;
        HEAP32[(((buf)+(16))>>2)] = stats.bavail;
        HEAP32[(((buf)+(20))>>2)] = stats.files;
        HEAP32[(((buf)+(24))>>2)] = stats.ffree;
        HEAP32[(((buf)+(28))>>2)] = stats.fsid;
        HEAP32[(((buf)+(44))>>2)] = stats.flags;  // ST_NOSUID
        HEAP32[(((buf)+(36))>>2)] = stats.namelen;
      },
  doMsync(addr, stream, len, flags, offset) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          // MAP_PRIVATE calls need not to be synced back to underlying fs
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },
  getStreamFromFD(fd) {
        var stream = FS.getStreamChecked(fd);
        return stream;
      },
  varargs:undefined,
  getStr(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },
  };
  function _fd_close(fd) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }

  /** @param {number=} offset */
  var doReadv = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.read(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break; // nothing more to read
        if (typeof offset != 'undefined') {
          offset += curr;
        }
      }
      return ret;
    };
  
  function _fd_read(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doReadv(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }

  
  var convertI32PairToI53Checked = (lo, hi) => {
      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;
    };
  function _fd_seek(fd,offset_low, offset_high,whence,newOffset) {
    var offset = convertI32PairToI53Checked(offset_low, offset_high);
  
    
  try {
  
      if (isNaN(offset)) return 61;
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble = stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? (+(Math.floor((tempDouble)/4294967296.0)))>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)], HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  ;
  }

  /** @param {number=} offset */
  var doWritev = (stream, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[((iov)>>2)];
        var len = HEAPU32[(((iov)+(4))>>2)];
        iov += 8;
        var curr = FS.write(stream, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) {
          // No more space to write.
          break;
        }
        if (typeof offset != 'undefined') {
          offset += curr;
        }
      }
      return ret;
    };
  
  function _fd_write(fd, iov, iovcnt, pnum) {
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = doWritev(stream, iov, iovcnt);
      HEAPU32[((pnum)>>2)] = num;
      return 0;
    } catch (e) {
    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;
    return e.errno;
  }
  }

  var getCFunc = (ident) => {
      var func = Module['_' + ident]; // closure exported function
      return func;
    };
  
  var writeArrayToMemory = (array, buffer) => {
      HEAP8.set(array, buffer);
    };
  
  
  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    };
  
  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
  var stringToUTF8OnStack = (str) => {
      var size = lengthBytesUTF8(str) + 1;
      var ret = stackAlloc(size);
      stringToUTF8(str, ret, size);
      return ret;
    };
  
  
  
  
  
    /**
     * @param {string|null=} returnType
     * @param {Array=} argTypes
     * @param {Arguments|Array=} args
     * @param {Object=} opts
     */
  var ccall = (ident, returnType, argTypes, args, opts) => {
      // For fast lookup of conversion functions
      var toC = {
        'string': (str) => {
          var ret = 0;
          if (str !== null && str !== undefined && str !== 0) { // null string
            ret = stringToUTF8OnStack(str);
          }
          return ret;
        },
        'array': (arr) => {
          var ret = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret);
          return ret;
        }
      };
  
      function convertReturnValue(ret) {
        if (returnType === 'string') {
          return UTF8ToString(ret);
        }
        if (returnType === 'boolean') return Boolean(ret);
        return ret;
      }
  
      var func = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];
          if (converter) {
            if (stack === 0) stack = stackSave();
            cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }
      var ret = func(...cArgs);
      function onDone(ret) {
        if (stack !== 0) stackRestore(stack);
        return convertReturnValue(ret);
      }
  
      ret = onDone(ret);
      return ret;
    };

  
  
    /**
     * @param {string=} returnType
     * @param {Array=} argTypes
     * @param {Object=} opts
     */
  var cwrap = (ident, returnType, argTypes, opts) => {
      // When the function takes numbers and returns a number, we can just return
      // the original function
      var numericArgs = !argTypes || argTypes.every((type) => type === 'number' || type === 'boolean');
      var numericRet = returnType !== 'string';
      if (numericRet && numericArgs && !opts) {
        return getCFunc(ident);
      }
      return (...args) => ccall(ident, returnType, argTypes, args, opts);
    };



  var uleb128Encode = (n, target) => {
      if (n < 128) {
        target.push(n);
      } else {
        target.push((n % 128) | 128, n >> 7);
      }
    };
  
  var sigToWasmTypes = (sig) => {
      var typeNames = {
        'i': 'i32',
        'j': 'i64',
        'f': 'f32',
        'd': 'f64',
        'e': 'externref',
        'p': 'i32',
      };
      var type = {
        parameters: [],
        results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
      };
      for (var i = 1; i < sig.length; ++i) {
        type.parameters.push(typeNames[sig[i]]);
      }
      return type;
    };
  
  var generateFuncType = (sig, target) => {
      var sigRet = sig.slice(0, 1);
      var sigParam = sig.slice(1);
      var typeCodes = {
        'i': 0x7f, // i32
        'p': 0x7f, // i32
        'j': 0x7e, // i64
        'f': 0x7d, // f32
        'd': 0x7c, // f64
        'e': 0x6f, // externref
      };
  
      // Parameters, length + signatures
      target.push(0x60 /* form: func */);
      uleb128Encode(sigParam.length, target);
      for (var i = 0; i < sigParam.length; ++i) {
        target.push(typeCodes[sigParam[i]]);
      }
  
      // Return values, length + signatures
      // With no multi-return in MVP, either 0 (void) or 1 (anything else)
      if (sigRet == 'v') {
        target.push(0x00);
      } else {
        target.push(0x01, typeCodes[sigRet]);
      }
    };
  var convertJsFunctionToWasm = (func, sig) => {
      // return func;
    };
  
  var wasmTableMirror = [];
  
  /** @type {WebAssembly.Table} */
  var wasmTable;
  var getWasmTableEntry = (funcPtr) => {
      var func = wasmTableMirror[funcPtr];
      if (!func) {
        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;
        /** @suppress {checkTypes} */
        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
      }
      return func;
    };
  
  var updateTableMap = (offset, count) => {
      if (functionsInTableMap) {
        for (var i = offset; i < offset + count; i++) {
          var item = getWasmTableEntry(i);
          // Ignore null values.
          if (item) {
            functionsInTableMap.set(item, i);
          }
        }
      }
    };
  
  var functionsInTableMap;
  
  var getFunctionAddress = (func) => {
      // First, create the map if this is the first use.
      if (!functionsInTableMap) {
        functionsInTableMap = new WeakMap();
        updateTableMap(0, wasmTable.length);
      }
      return functionsInTableMap.get(func) || 0;
    };
  
  
  var freeTableIndexes = [];
  
  var getEmptyTableSlot = () => {
      // Reuse a free index if there is one, otherwise grow.
      if (freeTableIndexes.length) {
        return freeTableIndexes.pop();
      }
      // Grow the table
      try {
        /** @suppress {checkTypes} */
        wasmTable.grow(1);
      } catch (err) {
        if (!(err instanceof RangeError)) {
          throw err;
        }
        throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
      }
      return wasmTable.length - 1;
    };
  
  
  
  var setWasmTableEntry = (idx, func) => {
      /** @suppress {checkTypes} */
      wasmTable.set(idx, func);
      // With ABORT_ON_WASM_EXCEPTIONS wasmTable.get is overridden to return wrapped
      // functions so we need to call it here to retrieve the potential wrapper correctly
      // instead of just storing 'func' directly into wasmTableMirror
      /** @suppress {checkTypes} */
      wasmTableMirror[idx] = wasmTable.get(idx);
    };
  
  /** @param {string=} sig */
  var addFunction = (func, sig) => {
      // Check if the function is already in the table, to ensure each function
      // gets a unique index.
      var rtn = getFunctionAddress(func);
      if (rtn) {
        return rtn;
      }
  
      // It's not in the table, add it now.
  
      var ret = getEmptyTableSlot();
  
      // Set the new value.
      try {
        // Attempting to call this with JS function will cause of table.set() to fail
        setWasmTableEntry(ret, func);
      } catch (err) {
        if (!(err instanceof TypeError)) {
          throw err;
        }
        var wrapped = convertJsFunctionToWasm(func, sig);
        setWasmTableEntry(ret, wrapped);
      }
  
      functionsInTableMap.set(func, ret);
  
      return ret;
    };

  FS.createPreloadedFile = FS_createPreloadedFile;
  FS.staticInit();
  // Set module methods based on EXPORTED_RUNTIME_METHODS
  ;

      // This error may happen quite a bit. To avoid overhead we reuse it (and
      // suffer a lack of stack info).
      MEMFS.doesNotExistError = new FS.ErrnoError(44);
      /** @suppress {checkTypes} */
      MEMFS.doesNotExistError.stack = '<generic error, no stack>';
      ;
var wasmImports = {
  /** @export */
  emscripten_resize_heap: _emscripten_resize_heap,
  /** @export */
  fd_close: _fd_close,
  /** @export */
  fd_read: _fd_read,
  /** @export */
  fd_seek: _fd_seek,
  /** @export */
  fd_write: _fd_write
};
var wasmExports;
createWasm();
var ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports['__wasm_call_ctors'])();
var _FLAC__stream_decoder_new = Module['_FLAC__stream_decoder_new'] = () => (_FLAC__stream_decoder_new = Module['_FLAC__stream_decoder_new'] = wasmExports['FLAC__stream_decoder_new'])();
var _FLAC__stream_decoder_delete = Module['_FLAC__stream_decoder_delete'] = (a0) => (_FLAC__stream_decoder_delete = Module['_FLAC__stream_decoder_delete'] = wasmExports['FLAC__stream_decoder_delete'])(a0);
var _FLAC__stream_decoder_finish = Module['_FLAC__stream_decoder_finish'] = (a0) => (_FLAC__stream_decoder_finish = Module['_FLAC__stream_decoder_finish'] = wasmExports['FLAC__stream_decoder_finish'])(a0);
var _FLAC__stream_decoder_init_stream = Module['_FLAC__stream_decoder_init_stream'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_FLAC__stream_decoder_init_stream = Module['_FLAC__stream_decoder_init_stream'] = wasmExports['FLAC__stream_decoder_init_stream'])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
var _FLAC__stream_decoder_reset = Module['_FLAC__stream_decoder_reset'] = (a0) => (_FLAC__stream_decoder_reset = Module['_FLAC__stream_decoder_reset'] = wasmExports['FLAC__stream_decoder_reset'])(a0);
var _FLAC__stream_decoder_init_ogg_stream = Module['_FLAC__stream_decoder_init_ogg_stream'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_FLAC__stream_decoder_init_ogg_stream = Module['_FLAC__stream_decoder_init_ogg_stream'] = wasmExports['FLAC__stream_decoder_init_ogg_stream'])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
var _FLAC__stream_decoder_set_ogg_serial_number = Module['_FLAC__stream_decoder_set_ogg_serial_number'] = (a0, a1) => (_FLAC__stream_decoder_set_ogg_serial_number = Module['_FLAC__stream_decoder_set_ogg_serial_number'] = wasmExports['FLAC__stream_decoder_set_ogg_serial_number'])(a0, a1);
var _FLAC__stream_decoder_set_md5_checking = Module['_FLAC__stream_decoder_set_md5_checking'] = (a0, a1) => (_FLAC__stream_decoder_set_md5_checking = Module['_FLAC__stream_decoder_set_md5_checking'] = wasmExports['FLAC__stream_decoder_set_md5_checking'])(a0, a1);
var _FLAC__stream_decoder_set_metadata_respond = Module['_FLAC__stream_decoder_set_metadata_respond'] = (a0, a1) => (_FLAC__stream_decoder_set_metadata_respond = Module['_FLAC__stream_decoder_set_metadata_respond'] = wasmExports['FLAC__stream_decoder_set_metadata_respond'])(a0, a1);
var _FLAC__stream_decoder_set_metadata_respond_application = Module['_FLAC__stream_decoder_set_metadata_respond_application'] = (a0, a1) => (_FLAC__stream_decoder_set_metadata_respond_application = Module['_FLAC__stream_decoder_set_metadata_respond_application'] = wasmExports['FLAC__stream_decoder_set_metadata_respond_application'])(a0, a1);
var _FLAC__stream_decoder_set_metadata_respond_all = Module['_FLAC__stream_decoder_set_metadata_respond_all'] = (a0) => (_FLAC__stream_decoder_set_metadata_respond_all = Module['_FLAC__stream_decoder_set_metadata_respond_all'] = wasmExports['FLAC__stream_decoder_set_metadata_respond_all'])(a0);
var _FLAC__stream_decoder_set_metadata_ignore = Module['_FLAC__stream_decoder_set_metadata_ignore'] = (a0, a1) => (_FLAC__stream_decoder_set_metadata_ignore = Module['_FLAC__stream_decoder_set_metadata_ignore'] = wasmExports['FLAC__stream_decoder_set_metadata_ignore'])(a0, a1);
var _FLAC__stream_decoder_set_metadata_ignore_application = Module['_FLAC__stream_decoder_set_metadata_ignore_application'] = (a0, a1) => (_FLAC__stream_decoder_set_metadata_ignore_application = Module['_FLAC__stream_decoder_set_metadata_ignore_application'] = wasmExports['FLAC__stream_decoder_set_metadata_ignore_application'])(a0, a1);
var _FLAC__stream_decoder_set_metadata_ignore_all = Module['_FLAC__stream_decoder_set_metadata_ignore_all'] = (a0) => (_FLAC__stream_decoder_set_metadata_ignore_all = Module['_FLAC__stream_decoder_set_metadata_ignore_all'] = wasmExports['FLAC__stream_decoder_set_metadata_ignore_all'])(a0);
var _FLAC__stream_decoder_get_state = Module['_FLAC__stream_decoder_get_state'] = (a0) => (_FLAC__stream_decoder_get_state = Module['_FLAC__stream_decoder_get_state'] = wasmExports['FLAC__stream_decoder_get_state'])(a0);
var _FLAC__stream_decoder_get_md5_checking = Module['_FLAC__stream_decoder_get_md5_checking'] = (a0) => (_FLAC__stream_decoder_get_md5_checking = Module['_FLAC__stream_decoder_get_md5_checking'] = wasmExports['FLAC__stream_decoder_get_md5_checking'])(a0);
var _FLAC__stream_decoder_process_single = Module['_FLAC__stream_decoder_process_single'] = (a0) => (_FLAC__stream_decoder_process_single = Module['_FLAC__stream_decoder_process_single'] = wasmExports['FLAC__stream_decoder_process_single'])(a0);
var _FLAC__stream_decoder_process_until_end_of_metadata = Module['_FLAC__stream_decoder_process_until_end_of_metadata'] = (a0) => (_FLAC__stream_decoder_process_until_end_of_metadata = Module['_FLAC__stream_decoder_process_until_end_of_metadata'] = wasmExports['FLAC__stream_decoder_process_until_end_of_metadata'])(a0);
var _FLAC__stream_decoder_process_until_end_of_stream = Module['_FLAC__stream_decoder_process_until_end_of_stream'] = (a0) => (_FLAC__stream_decoder_process_until_end_of_stream = Module['_FLAC__stream_decoder_process_until_end_of_stream'] = wasmExports['FLAC__stream_decoder_process_until_end_of_stream'])(a0);
var _FLAC__stream_encoder_new = Module['_FLAC__stream_encoder_new'] = () => (_FLAC__stream_encoder_new = Module['_FLAC__stream_encoder_new'] = wasmExports['FLAC__stream_encoder_new'])();
var _FLAC__stream_encoder_delete = Module['_FLAC__stream_encoder_delete'] = (a0) => (_FLAC__stream_encoder_delete = Module['_FLAC__stream_encoder_delete'] = wasmExports['FLAC__stream_encoder_delete'])(a0);
var _FLAC__stream_encoder_finish = Module['_FLAC__stream_encoder_finish'] = (a0) => (_FLAC__stream_encoder_finish = Module['_FLAC__stream_encoder_finish'] = wasmExports['FLAC__stream_encoder_finish'])(a0);
var _FLAC__stream_encoder_init_stream = Module['_FLAC__stream_encoder_init_stream'] = (a0, a1, a2, a3, a4, a5) => (_FLAC__stream_encoder_init_stream = Module['_FLAC__stream_encoder_init_stream'] = wasmExports['FLAC__stream_encoder_init_stream'])(a0, a1, a2, a3, a4, a5);
var _FLAC__stream_encoder_init_ogg_stream = Module['_FLAC__stream_encoder_init_ogg_stream'] = (a0, a1, a2, a3, a4, a5, a6) => (_FLAC__stream_encoder_init_ogg_stream = Module['_FLAC__stream_encoder_init_ogg_stream'] = wasmExports['FLAC__stream_encoder_init_ogg_stream'])(a0, a1, a2, a3, a4, a5, a6);
var _FLAC__stream_encoder_set_ogg_serial_number = Module['_FLAC__stream_encoder_set_ogg_serial_number'] = (a0, a1) => (_FLAC__stream_encoder_set_ogg_serial_number = Module['_FLAC__stream_encoder_set_ogg_serial_number'] = wasmExports['FLAC__stream_encoder_set_ogg_serial_number'])(a0, a1);
var _FLAC__stream_encoder_set_verify = Module['_FLAC__stream_encoder_set_verify'] = (a0, a1) => (_FLAC__stream_encoder_set_verify = Module['_FLAC__stream_encoder_set_verify'] = wasmExports['FLAC__stream_encoder_set_verify'])(a0, a1);
var _FLAC__stream_encoder_set_channels = Module['_FLAC__stream_encoder_set_channels'] = (a0, a1) => (_FLAC__stream_encoder_set_channels = Module['_FLAC__stream_encoder_set_channels'] = wasmExports['FLAC__stream_encoder_set_channels'])(a0, a1);
var _FLAC__stream_encoder_set_bits_per_sample = Module['_FLAC__stream_encoder_set_bits_per_sample'] = (a0, a1) => (_FLAC__stream_encoder_set_bits_per_sample = Module['_FLAC__stream_encoder_set_bits_per_sample'] = wasmExports['FLAC__stream_encoder_set_bits_per_sample'])(a0, a1);
var _FLAC__stream_encoder_set_sample_rate = Module['_FLAC__stream_encoder_set_sample_rate'] = (a0, a1) => (_FLAC__stream_encoder_set_sample_rate = Module['_FLAC__stream_encoder_set_sample_rate'] = wasmExports['FLAC__stream_encoder_set_sample_rate'])(a0, a1);
var _FLAC__stream_encoder_set_compression_level = Module['_FLAC__stream_encoder_set_compression_level'] = (a0, a1) => (_FLAC__stream_encoder_set_compression_level = Module['_FLAC__stream_encoder_set_compression_level'] = wasmExports['FLAC__stream_encoder_set_compression_level'])(a0, a1);
var _FLAC__stream_encoder_set_blocksize = Module['_FLAC__stream_encoder_set_blocksize'] = (a0, a1) => (_FLAC__stream_encoder_set_blocksize = Module['_FLAC__stream_encoder_set_blocksize'] = wasmExports['FLAC__stream_encoder_set_blocksize'])(a0, a1);
var _FLAC__stream_encoder_set_total_samples_estimate = Module['_FLAC__stream_encoder_set_total_samples_estimate'] = (a0, a1, a2) => (_FLAC__stream_encoder_set_total_samples_estimate = Module['_FLAC__stream_encoder_set_total_samples_estimate'] = wasmExports['FLAC__stream_encoder_set_total_samples_estimate'])(a0, a1, a2);
var _FLAC__stream_encoder_set_metadata = Module['_FLAC__stream_encoder_set_metadata'] = (a0, a1, a2) => (_FLAC__stream_encoder_set_metadata = Module['_FLAC__stream_encoder_set_metadata'] = wasmExports['FLAC__stream_encoder_set_metadata'])(a0, a1, a2);
var _FLAC__stream_encoder_get_state = Module['_FLAC__stream_encoder_get_state'] = (a0) => (_FLAC__stream_encoder_get_state = Module['_FLAC__stream_encoder_get_state'] = wasmExports['FLAC__stream_encoder_get_state'])(a0);
var _FLAC__stream_encoder_get_verify_decoder_state = Module['_FLAC__stream_encoder_get_verify_decoder_state'] = (a0) => (_FLAC__stream_encoder_get_verify_decoder_state = Module['_FLAC__stream_encoder_get_verify_decoder_state'] = wasmExports['FLAC__stream_encoder_get_verify_decoder_state'])(a0);
var _FLAC__stream_encoder_get_verify = Module['_FLAC__stream_encoder_get_verify'] = (a0) => (_FLAC__stream_encoder_get_verify = Module['_FLAC__stream_encoder_get_verify'] = wasmExports['FLAC__stream_encoder_get_verify'])(a0);
var _FLAC__stream_encoder_process = Module['_FLAC__stream_encoder_process'] = (a0, a1, a2) => (_FLAC__stream_encoder_process = Module['_FLAC__stream_encoder_process'] = wasmExports['FLAC__stream_encoder_process'])(a0, a1, a2);
var _FLAC__stream_encoder_process_interleaved = Module['_FLAC__stream_encoder_process_interleaved'] = (a0, a1, a2) => (_FLAC__stream_encoder_process_interleaved = Module['_FLAC__stream_encoder_process_interleaved'] = wasmExports['FLAC__stream_encoder_process_interleaved'])(a0, a1, a2);
var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(a0);
var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);
var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'])();
var dynCall_jiji = Module['dynCall_jiji'] = (a0, a1, a2, a3, a4) => (dynCall_jiji = Module['dynCall_jiji'] = wasmExports['dynCall_jiji'])(a0, a1, a2, a3, a4);


// include: postamble.js
// === Auto-generated postamble setup entry stuff ===

Module['ccall'] = ccall;
Module['cwrap'] = cwrap;
Module['addFunction'] = addFunction;
Module['setValue'] = setValue;
Module['getValue'] = getValue;


function run() {

  if (runDependencies > 0) {
    dependenciesFulfilled = run;
    return;
  }

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    dependenciesFulfilled = run;
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    Module['onRuntimeInitialized']?.();

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(() => {
      setTimeout(() => Module['setStatus'](''), 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

run();

// end include: postamble.js

// include: /home/tema/libflac.js/libflac_post.js
//libflac function wrappers

/**
 * HELPER read/extract stream info meta-data from frame header / meta-data
 * @param {POINTER} p_streaminfo
 * @returns StreamInfo
 */
function _readStreamInfo(p_streaminfo){//-> FLAC__StreamMetadata.type (FLAC__MetadataType) === FLAC__METADATA_TYPE_STREAMINFO (0)

	/*
	typedef struct {
		unsigned min_blocksize, max_blocksize;
		unsigned min_framesize, max_framesize;
		unsigned sample_rate;
		unsigned channels;
		unsigned bits_per_sample;
		FLAC__uint64 total_samples;
		FLAC__byte md5sum[16];
	} FLAC__StreamMetadata_StreamInfo;
	 */

	var min_blocksize = Module.getValue(p_streaminfo,'i32');//4 bytes
	var max_blocksize = Module.getValue(p_streaminfo+4,'i32');//4 bytes

	var min_framesize = Module.getValue(p_streaminfo+8,'i32');//4 bytes
	var max_framesize = Module.getValue(p_streaminfo+12,'i32');//4 bytes

	var sample_rate = Module.getValue(p_streaminfo+16,'i32');//4 bytes
	var channels = Module.getValue(p_streaminfo+20,'i32');//4 bytes

	var bits_per_sample = Module.getValue(p_streaminfo+24,'i32');//4 bytes

	//FIXME should be at p_streaminfo+28, but seems to be at p_streaminfo+32
	var total_samples = Module.getValue(p_streaminfo+32,'i64');//8 bytes

	var md5sum = _readMd5(p_streaminfo+40);//16 bytes

	return {
		min_blocksize: min_blocksize,
		max_blocksize: max_blocksize,
		min_framesize: min_framesize,
		max_framesize: max_framesize,
		sampleRate: sample_rate,
		channels: channels,
		bitsPerSample: bits_per_sample,
		total_samples: total_samples,
		md5sum: md5sum
	};
}

/**
 * read MD5 checksum
 * @param {POINTER} p_md5
 * @returns {String} as HEX string representation
 */
function _readMd5(p_md5){

	var sb = [], v, str;
	for(var i=0, len = 16; i < len; ++i){
		v = Module.getValue(p_md5+i,'i8');//1 byte
		if(v < 0) v = 256 + v;//<- "convert" to uint8, if necessary
		str = v.toString(16);
		if(str.length < 2) str = '0' + str;//<- add padding, if necessary
		sb.push(str);
	}
	return sb.join('');
}

/**
 * HELPER: read frame data
 *
 * @param {POINTER} p_frame
 * @param {CodingOptions} [enc_opt]
 * @returns FrameHeader
 */
function _readFrameHdr(p_frame, enc_opt){

	/*
	typedef struct {
		unsigned blocksize;
		unsigned sample_rate;
		unsigned channels;
		FLAC__ChannelAssignment channel_assignment;
		unsigned bits_per_sample;
		FLAC__FrameNumberType number_type;
		union {
			FLAC__uint32 frame_number;
			FLAC__uint64 sample_number;
		} number;
		FLAC__uint8 crc;
	} FLAC__FrameHeader;
	 */

	var blocksize = Module.getValue(p_frame,'i32');//4 bytes
	var sample_rate = Module.getValue(p_frame+4,'i32');//4 bytes
	var channels = Module.getValue(p_frame+8,'i32');//4 bytes

	// 0: FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT	independent channels
	// 1: FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE 	left+side stereo
	// 2: FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE 	right+side stereo
	// 3: FLAC__CHANNEL_ASSIGNMENT_MID_SIDE 	mid+side stereo
	var channel_assignment = Module.getValue(p_frame+12,'i32');//4 bytes

	var bits_per_sample = Module.getValue(p_frame+16,'i32');

	// 0: FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER 	number contains the frame number
	// 1: FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER	number contains the sample number of first sample in frame
	var number_type = Module.getValue(p_frame+20,'i32');

	// union {} number: The frame number or sample number of first sample in frame; use the number_type value to determine which to use.
	var frame_number = Module.getValue(p_frame+24,'i32');
	var sample_number = Module.getValue(p_frame+24,'i64');

	var number = number_type === 0? frame_number : sample_number;
	var numberType = number_type === 0? 'frames' : 'samples';

	var crc = Module.getValue(p_frame+36,'i8');

	var subframes;
	if(enc_opt && enc_opt.analyseSubframes){
		var subOffset = {offset: 40};
		subframes = [];
		for(var i=0; i < channels; ++i){
			subframes.push(_readSubFrameHdr(p_frame, subOffset, blocksize, enc_opt));
		}
		//TODO read footer
		// console.log('  footer crc ', Module.getValue(p_frame + subOffset.offset,'i16'));
	}

	return {
		blocksize: blocksize,
		sampleRate: sample_rate,
		channels: channels,
		channelAssignment: channel_assignment,
		bitsPerSample: bits_per_sample,
		number: number,
		numberType: numberType,
		crc: crc,
		subframes: subframes
	};
}


function _readSubFrameHdr(p_subframe, subOffset, block_size, enc_opt){
	/*
	FLAC__SubframeType 	type
	union {
	   FLAC__Subframe_Constant   constant
	   FLAC__Subframe_Fixed   fixed
	   FLAC__Subframe_LPC   lpc
	   FLAC__Subframe_Verbatim   verbatim
	} 	data
	unsigned 	wasted_bits
	*/

	var type = Module.getValue(p_subframe + subOffset.offset, 'i32');
	subOffset.offset += 4;

	var data;
	switch(type){
		case 0:	//FLAC__SUBFRAME_TYPE_CONSTANT
			data = {value: Module.getValue(p_subframe + subOffset.offset, 'i32')};
			subOffset.offset += 284;//4;
			break;
		case 1:	//FLAC__SUBFRAME_TYPE_VERBATIM
			data = Module.getValue(p_subframe + subOffset.offset, 'i32');
			subOffset.offset += 284;//4;
			break;
		case 2:	//FLAC__SUBFRAME_TYPE_FIXED
			data = _readSubFrameHdrFixedData(p_subframe, subOffset, block_size, false, enc_opt);
			break;
		case 3:	//FLAC__SUBFRAME_TYPE_LPC
			data = _readSubFrameHdrFixedData(p_subframe, subOffset, block_size, true, enc_opt);
			break;
	}

	var offset =  subOffset.offset;
	var wasted_bits = Module.getValue(p_subframe + offset, 'i32');
	subOffset.offset += 4;

	return {
		type: type,//['CONSTANT', 'VERBATIM', 'FIXED', 'LPC'][type],
		data: data,
		wastedBits: wasted_bits
	}
}

function _readSubFrameHdrFixedData(p_subframe_data, subOffset, block_size, is_lpc, enc_opt){

	var offset = subOffset.offset;

	var data = {order: -1, contents: {parameters: [], rawBits: []}};
	//FLAC__Subframe_Fixed:
	// FLAC__EntropyCodingMethod 	entropy_coding_method
	// unsigned 	order
	// FLAC__int32 	warmup [FLAC__MAX_FIXED_ORDER]
	// const FLAC__int32 * 	residual

	//FLAC__EntropyCodingMethod:
	// FLAC__EntropyCodingMethodType 	type
	// union {
	//    FLAC__EntropyCodingMethod_PartitionedRice   partitioned_rice
	// } 	data

	//FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE	0		Residual is coded by partitioning into contexts, each with it's own 4-bit Rice parameter.
	//FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2 1	Residual is coded by partitioning into contexts, each with it's own 5-bit Rice parameter.
	var entropyType = Module.getValue(p_subframe_data, 'i32');
	offset += 4;

	//FLAC__EntropyCodingMethod_PartitionedRice:
	//	unsigned 	order
	var entropyOrder = Module.getValue(p_subframe_data + offset, 'i32');
	data.order = entropyOrder;
	offset += 4;

	//FLAC__EntropyCodingMethod_PartitionedRice:
	//	FLAC__EntropyCodingMethod_PartitionedRiceContents * 	contents
	var partitions = 1 << entropyOrder, params = data.contents.parameters, raws = data.contents.rawBits;
	//FLAC__EntropyCodingMethod_PartitionedRiceContents
	// unsigned * 	parameters
	// unsigned * 	raw_bits
	// unsigned 	capacity_by_order
	var ppart = Module.getValue(p_subframe_data + offset, 'i32');
	var pparams = Module.getValue(ppart, 'i32');
	var praw = Module.getValue(ppart + 4, 'i32');
	data.contents.capacityByOrder = Module.getValue(ppart + 8, 'i32');
	for(var i=0; i < partitions; ++i){
		params.push(Module.getValue(pparams + (i*4), 'i32'));
		raws.push(Module.getValue(praw + (i*4), 'i32'));
	}
	offset += 4;

	//FLAC__Subframe_Fixed:
	//	unsigned 	order
	var order = Module.getValue(p_subframe_data + offset, 'i32');
	offset += 4;

	var warmup = [], res;

	if(is_lpc){
		//FLAC__Subframe_LPC

		// unsigned 	qlp_coeff_precision
		var qlp_coeff_precision = Module.getValue(p_subframe_data + offset, 'i32');
		offset += 4;
		// int 	quantization_level
		var quantization_level = Module.getValue(p_subframe_data + offset, 'i32');
		offset += 4;

		//FLAC__Subframe_LPC :
		// FLAC__int32 	qlp_coeff [FLAC__MAX_LPC_ORDER]
		var qlp_coeff = [];
		for(var i=0; i < order; ++i){
			qlp_coeff.push(Module.getValue(p_subframe_data + offset, 'i32'));
			offset += 4;
		}
		data.qlp_coeff = qlp_coeff;
		data.qlp_coeff_precision = qlp_coeff_precision;
		data.quantization_level = quantization_level;

		//FLAC__Subframe_LPC:
		// FLAC__int32 	warmup [FLAC__MAX_LPC_ORDER]
		offset = subOffset.offset + 152;
		offset = _readSubFrameHdrWarmup(p_subframe_data, offset, warmup, order);

		//FLAC__Subframe_LPC:
		// const FLAC__int32 * 	residual
		if(enc_opt && enc_opt.analyseResiduals){
			offset = subOffset.offset + 280;
			res = _readSubFrameHdrResidual(p_subframe_data + offset, block_size, order);
		}

	} else {

		//FLAC__Subframe_Fixed:
		// FLAC__int32 	warmup [FLAC__MAX_FIXED_ORDER]
		offset = _readSubFrameHdrWarmup(p_subframe_data, offset, warmup, order);

		//FLAC__Subframe_Fixed:
		// const FLAC__int32 * 	residual
		offset = subOffset.offset + 32;
		if(enc_opt && enc_opt.analyseResiduals){
			res = _readSubFrameHdrResidual(p_subframe_data + offset, block_size, order);
		}
	}

	subOffset.offset += 284;
	return {
		partition: {
			type: entropyType,
			data: data
		},
		order: order,
		warmup: warmup,
		residual: res
	}
}


function _readSubFrameHdrWarmup(p_subframe_data, offset, warmup, order){

	// FLAC__int32 	warmup [FLAC__MAX_FIXED_ORDER | FLAC__MAX_LPC_ORDER]
	for(var i=0; i < order; ++i){
		warmup.push(Module.getValue(p_subframe_data + offset, 'i32'));
		offset += 4;
	}
	return offset;
}


function _readSubFrameHdrResidual(p_subframe_data_res, block_size, order){
	// const FLAC__int32 * 	residual
	var pres = Module.getValue(p_subframe_data_res, 'i32');
	var res = [];//Module.getValue(pres, 'i32');
	//TODO read residual all values(?)
	// -> "The residual signal, length == (blocksize minus order) samples.
	for(var i=0, size = block_size - order; i < size; ++i){
		res.push(Module.getValue(pres + (i*4), 'i32'));
	}
	return res;
}

function _readConstChar(ptr, length, sb){
	sb.splice(0);
	var ch;
	for(var i=0; i < length; ++i){
		ch = Module.getValue(ptr + i,'i8');
		if(ch === 0){
			break;
		}
		sb.push(String.fromCodePoint(ch));
	}
	return sb.join('');
}

function _readNullTerminatedChar(ptr, sb){
	sb.splice(0);
	var ch = 1, i = 0;
	while(ch > 0){
		ch = Module.getValue(ptr + i++, 'i8');
		if(ch === 0){
			break;
		}
		sb.push(String.fromCodePoint(ch));
	}
	return sb.join('');
}


/**
 * HELPER read/extract padding metadata meta-data from meta-data block
 * @param {POINTER} p_padding_metadata
 * @returns PaddingMetadata
 */
function _readPaddingMetadata(p_padding_metadata){//-> FLAC__StreamMetadata.type (FLAC__MetadataType) === FLAC__METADATA_TYPE_PADDING (1)

	//FLAC__StreamMetadata_Padding:
	//		int 	dummy
	return {
		dummy: Module.getValue(p_padding_metadata,'i32')
	}
}

/**
 * HELPER read/extract application metadata meta-data from meta-data block
 * @param {POINTER} p_application_metadata
 * @returns ApplicationMetadata
 */
function _readApplicationMetadata(p_application_metadata){//-> FLAC__StreamMetadata.type (FLAC__MetadataType) === FLAC__METADATA_TYPE_APPLICATION (2)

	//FLAC__StreamMetadata_Application:
	// FLAC__byte 	id [4]
	// FLAC__byte * 	data
	return {
		id : Module.getValue(p_application_metadata,'i32'),
		data: Module.getValue(p_application_metadata + 4,'i32')//TODO should read (binary) data?
	}
}


/**
 * HELPER read/extract seek table metadata meta-data from meta-data block
 * @param {POINTER} p_seek_table_metadata
 * @returns SeekTableMetadata
 */
function _readSeekTableMetadata(p_seek_table_metadata){//-> FLAC__StreamMetadata.type (FLAC__MetadataType) === FLAC__METADATA_TYPE_SEEKTABLE (3)

	//FLAC__StreamMetadata_SeekTable:
	// 	unsigned 	num_points
	// 	FLAC__StreamMetadata_SeekPoint * 	points

	var num_points = Module.getValue(p_seek_table_metadata,'i32');

	var ptrPoints = Module.getValue(p_seek_table_metadata + 4,'i32');
	var points = [];
	for(var i=0; i < num_points; ++i){

		//FLAC__StreamMetadata_SeekPoint:
		// 	FLAC__uint64 	sample_number
		// 	FLAC__uint64 	stream_offset
		// 	unsigned 	frame_samples

		points.push({
			sample_number: Module.getValue(ptrPoints + (i * 24),'i64'),
			stream_offset: Module.getValue(ptrPoints + (i * 24) + 8,'i64'),
			frame_samples: Module.getValue(ptrPoints + (i * 24) + 16,'i32')
		});
	}

	return {
		num_points: num_points,
		points: points
	}
}

/**
 * HELPER read/extract vorbis comment meta-data from meta-data block
 * @param {POINTER} p_vorbiscomment
 * @returns VorbisComment
 */
function _readVorbisComment(p_vorbiscomment){//-> FLAC__StreamMetadata.type (FLAC__MetadataType) === FLAC__METADATA_TYPE_VORBIS_COMMENT (4)

	// FLAC__StreamMetadata_VorbisComment
	// FLAC__StreamMetadata_VorbisComment_Entry vendor_string:
	// 		FLAC__uint32 	length
	// 		FLAC__byte * 	entry
	var length = Module.getValue(p_vorbiscomment,'i32');
	var entry = Module.getValue(p_vorbiscomment + 4,'i32');

	var sb = [];
	var strEntry = _readConstChar(entry, length, sb);

	// FLAC__uint32 	num_comments
	var num_comments = Module.getValue(p_vorbiscomment + 8,'i32');

	// FLAC__StreamMetadata_VorbisComment_Entry * 	comments
	var comments = [], clen, centry;
	var pc = Module.getValue(p_vorbiscomment + 12, 'i32')
	for(var i=0; i < num_comments; ++i){

		// FLAC__StreamMetadata_VorbisComment_Entry
		// 		FLAC__uint32 	length
		// 		FLAC__byte * 	entry

		clen = Module.getValue(pc + (i*8), 'i32');
		if(clen === 0){
			continue;
		}

		centry = Module.getValue(pc + (i*8) + 4, 'i32');
		comments.push(_readConstChar(centry, clen, sb));
	}

	return {
		vendor_string: strEntry,
		num_comments: num_comments,
		comments: comments
	}
}

/**
 * HELPER read/extract cue sheet meta-data from meta-data block
 * @param {POINTER} p_cue_sheet
 * @returns CueSheetMetadata
 */
function _readCueSheetMetadata(p_cue_sheet){//-> FLAC__StreamMetadata.type (FLAC__MetadataType) === FLAC__METADATA_TYPE_CUESHEET (5)

	// char 	media_catalog_number [129]
	// FLAC__uint64 	lead_in
	// FLAC__bool 	is_cd
	// unsigned 	num_tracks
	// FLAC__StreamMetadata_CueSheet_Track * 	tracks

	var sb = [];
	var media_catalog_number = _readConstChar(p_cue_sheet, 129, sb);

	var lead_in = Module.getValue(p_cue_sheet + 136,'i64');

	var is_cd = Module.getValue(p_cue_sheet + 144,'i8');
	var num_tracks = Module.getValue(p_cue_sheet + 148,'i32');

	var ptrTrack = Module.getValue(p_cue_sheet + 152,'i32');
	var tracks = [], trackOffset = ptrTrack;
	if(ptrTrack !== 0){

		for(var i=0; i < num_tracks; ++i){

			var tr = _readCueSheetMetadata_track(trackOffset, sb);
			tracks.push(tr);
			trackOffset += 32;
		}
	}

	return {
		media_catalog_number: media_catalog_number,
		lead_in: lead_in,
		is_cd: is_cd,
		num_tracks: num_tracks,
		tracks: tracks
	}
}

/**
 * helper read track data for cue-sheet metadata
 * @param       {POINTER} p_cue_sheet_track pointer to the track data
 * @param       {string[]} sb "string buffer" temporary buffer for reading string (may be reset)
 * @return      {CueSheetTrack}
 */
function _readCueSheetMetadata_track(p_cue_sheet_track, sb){

	// FLAC__StreamMetadata_CueSheet_Track:
	// 		FLAC__uint64 	offset
	// 		FLAC__byte 	number
	// 		char 	isrc [13]
	//		 unsigned 	type:1
	// 		unsigned 	pre_emphasis:1
	// 		FLAC__byte 	num_indices
	// 		FLAC__StreamMetadata_CueSheet_Index * 	indices

	var typePremph = Module.getValue(p_cue_sheet_track + 22,'i8');
	var num_indices = Module.getValue(p_cue_sheet_track + 23,'i8');

	var indices = [];
	var track = {
		offset: Module.getValue(p_cue_sheet_track,'i64'),
		number: Module.getValue(p_cue_sheet_track + 8,'i8') &255,
		isrc: _readConstChar(p_cue_sheet_track + 9, 13, sb),
		type: typePremph & 1? 'NON_AUDIO' : 'AUDIO',
		pre_emphasis: !!(typePremph & 2),
		num_indices: num_indices,
		indices: indices
	}

	var idx;
	if(num_indices > 0){
		idx = Module.getValue(p_cue_sheet_track + 24,'i32');

		//FLAC__StreamMetadata_CueSheet_Index:
		// 	FLAC__uint64 	offset
		// 	FLAC__byte 	number

		for(var i=0; i < num_indices; ++i){
			indices.push({
				offset: Module.getValue(idx + (i*16),'i64'),
				number: Module.getValue(idx + (i*16) + 8,'i8')
			});
		}
	}

	return track;
}

/**
 * HELPER read/extract picture meta-data from meta-data block
 * @param {POINTER} p_picture_metadata
 * @returns PictureMetadata
 */
function _readPictureMetadata(p_picture_metadata){//-> FLAC__StreamMetadata.type (FLAC__MetadataType) === FLAC__METADATA_TYPE_PICTURE (6)

	// FLAC__StreamMetadata_Picture_Type 	type
	// char * 	mime_type
	// FLAC__byte * 	description
	// FLAC__uint32 	width
	// FLAC__uint32 	height
	// FLAC__uint32 	depth
	// FLAC__uint32 	colors
	// FLAC__uint32 	data_length
	// FLAC__byte * 	data

	var type = Module.getValue(p_picture_metadata,'i32');

	var mime = Module.getValue(p_picture_metadata + 4,'i32');

	var sb = [];
	var mime_type = _readNullTerminatedChar(mime, sb);

	var desc = Module.getValue(p_picture_metadata + 8,'i32');
	var description = _readNullTerminatedChar(desc, sb);

	var width  = Module.getValue(p_picture_metadata + 12,'i32');
	var height = Module.getValue(p_picture_metadata + 16,'i32');
	var depth  = Module.getValue(p_picture_metadata + 20,'i32');
	var colors = Module.getValue(p_picture_metadata + 24,'i32');
	var data_length = Module.getValue(p_picture_metadata + 28,'i32');

	var data = Module.getValue(p_picture_metadata + 32,'i32');

	var buffer = Uint8Array.from(Module.HEAPU8.subarray(data, data + data_length));

	return {
		type: type,
		mime_type: mime_type,
		description: description,
		width: width,
		height: height,
		depth: depth,
		colors: colors,
		data_length: data_length,
		data: buffer
	}
}

/**
 * HELPER workaround / fix for returned write-buffer when decoding FLAC
 *
 * @param {number} heapOffset
 * 				the offset for the data on HEAPU8
 * @param {Uint8Array} newBuffer
 * 				the target buffer into which the data should be written -- with the correct (block) size
 * @param {boolean} applyFix
 * 				whether or not to apply the data repair heuristics
 * 				(handling duplicated/triplicated values in raw data)
 */
function __fix_write_buffer(heapOffset, newBuffer, applyFix){

	var dv = new DataView(newBuffer.buffer);
	var targetSize = newBuffer.length;

	var increase = !applyFix? 1 : 2;//<- for FIX/workaround, NOTE: e.g. if 24-bit padding occurres, there is no fix/increase needed (more details comment below)
	var buffer = HEAPU8.subarray(heapOffset, heapOffset + targetSize * increase);

	// FIXME for some reason, the bytes values 0 (min) and 255 (max) get "triplicated",
	//		or inserted "doubled" which should be ignored, i.e.
	//		x x x	-> x
	//		x x		-> <ignored>
	//		where x is 0 or 255
	// -> HACK for now: remove/"over-read" 2 of the values, for each of these triplets/doublications
	var jump, isPrint;
	for(var i=0, j=0, size = buffer.length; i < size && j < targetSize; ++i, ++j){

		if(i === size-1 && j < targetSize - 1){
			//increase heap-view, in order to read more (valid) data into the target buffer
			buffer = HEAPU8.subarray(heapOffset, size + targetSize);
			size = buffer.length;
		}

		// NOTE if e.g. 24-bit padding occurres, there does not seem to be no duplication/triplication of 255 or 0, so must not try to fix!
		if(applyFix && (buffer[i] === 0 || buffer[i] === 255)){

			jump = 0;
			isPrint = true;

			if(i + 1 < size && buffer[i] === buffer[i+1]){

				++jump;

				if(i + 2 < size){
					if(buffer[i] === buffer[i+2]){
						++jump;
					} else {
						//if only 2 occurrences: ignore value
						isPrint = false;
					}
				}
			}//else: if single value: do print (an do not jump)


			if(isPrint){
				dv.setUint8(j, buffer[i]);
				if(jump === 2 && i + 3 < size && buffer[i] === buffer[i+3]){
					//special case for reducing triples in case the following value is also the same
					// (ie. something like: x x x |+ x)
					// -> then: do write the value one more time, and jump one further ahead
					// i.e. if value occurs 4 times in a row, write 2 values
					++jump;
					dv.setUint8(++j, buffer[i]);
				}
			} else {
				--j;
			}

			i += jump;//<- apply jump, if there were value duplications

		} else {
			dv.setUint8(j, buffer[i]);
		}

	}
}


// FLAC__STREAM_DECODER_READ_STATUS_CONTINUE     	The read was OK and decoding can continue.
// FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM   The read was attempted while at the end of the stream. Note that the client must only return this value when the read callback was called when already at the end of the stream. Otherwise, if the read itself moves to the end of the stream, the client should still return the data and FLAC__STREAM_DECODER_READ_STATUS_CONTINUE, and then on the next read callback it should return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM with a byte count of 0.
// FLAC__STREAM_DECODER_READ_STATUS_ABORT       	An unrecoverable error occurred. The decoder will return from the process call.
var FLAC__STREAM_DECODER_READ_STATUS_CONTINUE = 0;
var FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM = 1;
var FLAC__STREAM_DECODER_READ_STATUS_ABORT = 2;

// FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE   The write was OK and decoding can continue.
// FLAC__STREAM_DECODER_WRITE_STATUS_ABORT     	An unrecoverable error occurred. The decoder will return from the process call.
var FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE = 0;
var FLAC__STREAM_DECODER_WRITE_STATUS_ABORT = 1;

/**
 * @interface FLAC__StreamDecoderInitStatus
 * @memberOf Flac
 *
 * @property {"FLAC__STREAM_DECODER_INIT_STATUS_OK"}						0 	Initialization was successful.
 * @property {"FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER"}		1 	The library was not compiled with support for the given container format.
 * @property {"FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS"}			2 	A required callback was not supplied.
 * @property {"FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR"}	3 	An error occurred allocating memory.
 * @property {"FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE"}		4 	fopen() failed in FLAC__stream_decoder_init_file() or FLAC__stream_decoder_init_ogg_file().
 * @property {"FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED"}		5 	FLAC__stream_decoder_init_*() was called when the decoder was already initialized, usually because FLAC__stream_decoder_finish() was not called.
 */
var FLAC__STREAM_DECODER_INIT_STATUS_OK	= 0;
var FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER	= 1;
var FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS	= 2;
var FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR = 3;
var FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE = 4;
var FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED = 5;

/**
 * @interface FLAC__StreamEncoderInitStatus
 * @memberOf Flac
 *
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_OK"}									0 	Initialization was successful.
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR"}							1 	General failure to set up encoder; call FLAC__stream_encoder_get_state() for cause.
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER"}					2 	The library was not compiled with support for the given container format.
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS"}						3 	A required callback was not supplied.
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS"}			4 	The encoder has an invalid setting for number of channels.
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE"}				5 	The encoder has an invalid setting for bits-per-sample. FLAC supports 4-32 bps but the reference encoder currently supports only up to 24 bps.
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE"}					6 	The encoder has an invalid setting for the input sample rate.
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE"}					7 	The encoder has an invalid setting for the block size.
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER"}					8 	The encoder has an invalid setting for the maximum LPC order.
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION"}			9 	The encoder has an invalid setting for the precision of the quantized linear predictor coefficients.
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER"}	10 	The specified block size is less than the maximum LPC order.
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE"}						11 	The encoder is bound to the Subset but other settings violate it.
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA"}						12 	The metadata input to the encoder is invalid, in one of the following ways:
 *																						      FLAC__stream_encoder_set_metadata() was called with a null pointer but a block count > 0
 *																						      One of the metadata blocks contains an undefined type
 *																						      It contains an illegal CUESHEET as checked by FLAC__format_cuesheet_is_legal()
 *																						      It contains an illegal SEEKTABLE as checked by FLAC__format_seektable_is_legal()
 *																						      It contains more than one SEEKTABLE block or more than one VORBIS_COMMENT block
 * @property {"FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED"}					13 	FLAC__stream_encoder_init_*() was called when the encoder was already initialized, usually because FLAC__stream_encoder_finish() was not called.
 */
var FLAC__STREAM_ENCODER_INIT_STATUS_OK = 0;
var FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR = 1;
var FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER = 2;
var FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS = 3;
var FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS = 4;
var FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE = 5;
var FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE = 6;
var FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE = 7;
var FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER = 8;
var FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION = 9;
var FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER = 10;
var FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE = 11;
var FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA = 12;
var FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED = 13;

//FLAC__STREAM_ENCODER_WRITE_STATUS_OK 				The write was OK and encoding can continue.
//FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR		An unrecoverable error occurred. The encoder will return from the process call
var FLAC__STREAM_ENCODER_WRITE_STATUS_OK = 0;
var FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR = 1;


/**
 * Map for encoder/decoder callback functions
 *
 * <pre>[ID] -> {function_type: FUNCTION}</pre>
 *
 * type: {[id: number]: {[callback_type: string]: function}}
 * @private
 */
var coders = {};

/**
 * Get a registered callback for the encoder / decoder instance
 *
 * @param {Number} p_coder
 * 			the encoder/decoder pointer (ID)
 * @param {String} func_type
 * 			the callback type, one of
 * 				"write" | "read" | "error" | "metadata"
 * @returns {Function} the callback (or VOID if there is no callback registered)
 * @private
 */
function getCallback(p_coder, func_type){
	if(coders[p_coder]){
		return coders[p_coder][func_type];
	}
}

/**
 * Register a callback for an encoder / decoder instance (will / should be deleted, when finish()/delete())
 *
 * @param {Number} p_coder
 * 			the encoder/decoder pointer (ID)
 * @param {String} func_type
 * 			the callback type, one of
 * 				"write" | "read" | "error" | "metadata"
 * @param {Function} callback
 * 			the callback function
 * @private
 */
function setCallback(p_coder, func_type, callback){
	if(!coders[p_coder]){
		coders[p_coder] = {};
	}
	coders[p_coder][func_type] = callback;
}

/**
 * Get coding options for the encoder / decoder instance:
 * returns FALSY when not set.
 *
 * @param {Number} p_coder
 * 			the encoder/decoder pointer (ID)
 * @returns {CodingOptions} the coding options
 * @private
 * @memberOf Flac
 */
function _getOptions(p_coder){
	if(coders[p_coder]){
		return coders[p_coder]["options"];
	}
}

/**
 * Set coding options for an encoder / decoder instance (will / should be deleted, when finish()/delete())
 *
 * @param {Number} p_coder
 * 			the encoder/decoder pointer (ID)
 * @param {CodingOptions} options
 * 			the coding options
 * @private
 * @memberOf Flac
 */
function _setOptions(p_coder, options){
	if(!coders[p_coder]){
		coders[p_coder] = {};
	}
	coders[p_coder]["options"] = options;
}

//(const FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame, void *client_data)
// -> FLAC__StreamEncoderWriteStatus
var enc_write_fn_ptr = addFunction(function(p_encoder, buffer, bytes, samples, current_frame, p_client_data){
	var retdata = new Uint8Array(bytes);
	retdata.set(HEAPU8.subarray(buffer, buffer + bytes));
	var write_callback_fn = getCallback(p_encoder, 'write');
	try{
		write_callback_fn(retdata, bytes, samples, current_frame, p_client_data);
	} catch(err) {
		console.error(err);
		return FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR;
	}
	return FLAC__STREAM_ENCODER_WRITE_STATUS_OK;
}, 'iiiiiii');

//(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
// -> FLAC__StreamDecoderReadStatus
var dec_read_fn_ptr = addFunction(function(p_decoder, buffer, bytes, p_client_data){
	//FLAC__StreamDecoderReadCallback, see https://xiph.org/flac/api/group__flac__stream__decoder.html#ga7a5f593b9bc2d163884348b48c4285fd

	var len = Module.getValue(bytes, 'i32');

	if(len === 0){
		return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
	}

	var read_callback_fn = getCallback(p_decoder, 'read');

	//callback must return object with: {buffer: TypedArray, readDataLength: number, error: boolean}
	var readResult = read_callback_fn(len, p_client_data);
	//in case of END_OF_STREAM or an error, readResult.readDataLength must be returned with 0

	var readLen = readResult.readDataLength;
	Module.setValue(bytes, readLen, 'i32');

	if(readResult.error){
		return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
	}

	if(readLen === 0){
		return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
	}

	var readBuf = readResult.buffer;

	var dataHeap = new Uint8Array(Module.HEAPU8.buffer, buffer, readLen);
	dataHeap.set(new Uint8Array(readBuf));

	return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
}, 'iiiii');

//(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 *const buffer[], void *client_data)
// -> FLAC__StreamDecoderWriteStatus
var dec_write_fn_ptr = addFunction(function(p_decoder, p_frame, p_buffer, p_client_data){

	// var dec = Module.getValue(p_decoder,'i32');
	// var clientData = Module.getValue(p_client_data,'i32');

	var dec_opts = _getOptions(p_decoder);
	var frameInfo = _readFrameHdr(p_frame, dec_opts);

//	console.log(frameInfo);//DEBUG

	var channels = frameInfo.channels;
	var block_size = frameInfo.blocksize * (frameInfo.bitsPerSample / 8);

	//whether or not to apply data fixing heuristics (e.g. not needed for 24-bit samples)
	var isFix = frameInfo.bitsPerSample !== 24;

	//take padding bits into account for calculating buffer size
	// -> seems to be done for uneven byte sizes, i.e. 1 (8 bits) and 3 (24 bits)
	var padding = (frameInfo.bitsPerSample / 8)%2;
	if(padding > 0){
		block_size += frameInfo.blocksize * padding;
	}

	var data = [];//<- array for the data of each channel
	var bufferOffset, _buffer;

	for(var i=0; i < channels; ++i){

		bufferOffset = Module.getValue(p_buffer + (i*4),'i32');

		_buffer = new Uint8Array(block_size);
		//FIXME HACK for "strange" data (see helper function __fix_write_buffer)
		__fix_write_buffer(bufferOffset, _buffer, isFix);

		data.push(_buffer.subarray(0, block_size));
	}

	var write_callback_fn = getCallback(p_decoder, 'write');
	var res = write_callback_fn(data, frameInfo);//, clientData);

	// FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE	The write was OK and decoding can continue.
	// FLAC__STREAM_DECODER_WRITE_STATUS_ABORT     	An unrecoverable error occurred. The decoder will return from the process call.

	return res !== false? FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE : FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
}, 'iiiii');

/**
 * Decoding error codes.
 *
 * <br>
 * If the error code is not known, value <code>FLAC__STREAM_DECODER_ERROR__UNKNOWN__</code> is used.
 *
 * @property {"FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC"}			0   An error in the stream caused the decoder to lose synchronization.
 * @property {"FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER"}  			1   The decoder encountered a corrupted frame header.
 * @property {"FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH"}	2   The frame's data did not match the CRC in the footer.
 * @property {"FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM"}	3   The decoder encountered reserved fields in use in the stream.
 *
 *
 * @interface FLAC__StreamDecoderErrorStatus
 * @memberOf Flac
 */
var DecoderErrorCode = {
	0: 'FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC',
	1: 'FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER',
	2: 'FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH',
	3: 'FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM'
}

//(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data)
// -> void
var dec_error_fn_ptr = addFunction(function(p_decoder, err, p_client_data){

	//err:
	var msg = DecoderErrorCode[err] || 'FLAC__STREAM_DECODER_ERROR__UNKNOWN__';//<- this should never happen;

	var error_callback_fn = getCallback(p_decoder, 'error');
	error_callback_fn(err, msg, p_client_data);
}, 'viii');

//(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data) -> void
//(const FLAC__StreamEncoder *encoder, const FLAC__StreamMetadata *metadata, void *client_data) -> void
var metadata_fn_ptr = addFunction(function(p_coder, p_metadata, p_client_data){
	/*
	 typedef struct {
		FLAC__MetadataType type;
		FLAC__bool is_last;
		unsigned length;
		union {
			FLAC__StreamMetadata_StreamInfo stream_info;
			FLAC__StreamMetadata_Padding padding;
			FLAC__StreamMetadata_Application application;
			FLAC__StreamMetadata_SeekTable seek_table;
			FLAC__StreamMetadata_VorbisComment vorbis_comment;
			FLAC__StreamMetadata_CueSheet cue_sheet;
			FLAC__StreamMetadata_Picture picture;
			FLAC__StreamMetadata_Unknown unknown;
		} data;
	} FLAC__StreamMetadata;
	 */

	/*
	FLAC__METADATA_TYPE_STREAMINFO 		STREAMINFO block
	FLAC__METADATA_TYPE_PADDING 		PADDING block
	FLAC__METADATA_TYPE_APPLICATION 	APPLICATION block
	FLAC__METADATA_TYPE_SEEKTABLE 		SEEKTABLE block
	FLAC__METADATA_TYPE_VORBIS_COMMENT 	VORBISCOMMENT block (a.k.a. FLAC tags)
	FLAC__METADATA_TYPE_CUESHEET 		CUESHEET block
	FLAC__METADATA_TYPE_PICTURE 		PICTURE block
	FLAC__METADATA_TYPE_UNDEFINED 		marker to denote beginning of undefined type range; this number will increase as new metadata types are added
	FLAC__MAX_METADATA_TYPE 			No type will ever be greater than this. There is not enough room in the protocol block.
	 */

	var type = Module.getValue(p_metadata,'i32');//4 bytes
	var is_last = Module.getValue(p_metadata+4,'i32');//4 bytes
	var length = Module.getValue(p_metadata+8,'i64');//8 bytes

	var meta_data = {
		type: type,
		isLast: is_last,
		length: length,
		data: void(0)
	};

	var metadata_callback_fn = getCallback(p_coder, 'metadata');
	if(type === 0){// === FLAC__METADATA_TYPE_STREAMINFO

		meta_data.data = _readStreamInfo(p_metadata+16);
		metadata_callback_fn(meta_data.data, meta_data);

	} else {

		var data;
		switch(type){
			case 1: //FLAC__METADATA_TYPE_PADDING
				data = _readPaddingMetadata(p_metadata+16);
				break;
			case 2: //FLAC__METADATA_TYPE_APPLICATION
				data =  readApplicationMetadata(p_metadata+16);
				break;
			case 3: //FLAC__METADATA_TYPE_SEEKTABLE
				data = _readSeekTableMetadata(p_metadata+16);
				break;

			case 4: //FLAC__METADATA_TYPE_VORBIS_COMMENT
				data = _readVorbisComment(p_metadata+16);
				break;

			case 5: //FLAC__METADATA_TYPE_CUESHEET
				data = _readCueSheetMetadata(p_metadata+16);
				break;

			case 6: //FLAC__METADATA_TYPE_PICTURE
				data = _readPictureMetadata(p_metadata+16);
				break;
			default: { //NOTE this should not happen, and the raw data is very likely not correct!
				var cod_opts = _getOptions(p_coder);
				if(cod_opts && cod_opts.enableRawMetadata){
					var buffer = Uint8Array.from(HEAPU8.subarray(p_metadata+16, p_metadata+16+length));
					meta_data.raw = buffer;
				}
			}

		}

		meta_data.data = data;
		metadata_callback_fn(void(0), meta_data);
	}

}, 'viii');


////////////// helper fields and functions for event handling
// see exported on()/off() functions
var listeners = {};
var persistedEvents = [];
var add_event_listener = function (eventName, listener){
	var list = listeners[eventName];
	if(!list){
		list = [listener];
		listeners[eventName] = list;
	} else {
		list.push(listener);
	}
	check_and_trigger_persisted_event(eventName, listener);
};
var check_and_trigger_persisted_event = function(eventName, listener){
	var activated;
	for(var i=persistedEvents.length-1; i >= 0; --i){
		activated = persistedEvents[i];
		if(activated && activated.event === eventName){
			listener.apply(null, activated.args);
			break;
		}
	}
};
var remove_event_listener = function (eventName, listener){
	var list = listeners[eventName];
	if(list){
		for(var i=list.length-1; i >= 0; --i){
			if(list[i] === listener){
				list.splice(i, 1);
			}
		}
	}
};
/**
 * HELPER: fire an event
 * @param  {string} eventName
 * 										the event name
 * @param  {any[]} [args] OPITIONAL
 * 										the arguments when triggering the listeners
 * @param  {boolean} [isPersist] OPTIONAL (positinal argument!)
 * 										if TRUE, handlers for this event that will be registered after this will get triggered immediately
 * 										(i.e. event is "persistent": once triggered it stays "active")
 *
 */
var do_fire_event = function (eventName, args, isPersist){
	if(_exported['on'+eventName]){
		_exported['on'+eventName].apply(null, args);
	}
	var list = listeners[eventName];
	if(list){
		for(var i=0, size=list.length; i < size; ++i){
			list[i].apply(null, args)
		}
	}
	if(isPersist){
		persistedEvents.push({event: eventName, args: args});
	}
}

/////////////////////////////////////    export / public: /////////////////////////////////////////////
/**
 * The <code>Flac</code> module that provides functionality
 * for encoding WAV/PCM audio to Flac and decoding Flac to PCM.
 *
 * <br/><br/>
 * <p>
 * NOTE most functions are named analogous to the original C library functions,
 *      so that its documentation may be used for further reading.
 * </p>
 *
 * @see https://xiph.org/flac/api/group__flac__stream__encoder.html
 * @see https://xiph.org/flac/api/group__flac__stream__decoder.html
 *
 * @class Flac
 * @namespace Flac
 */
var _exported = {
	_module: Module,//internal: reference to Flac module
	_clear_enc_cb: function(enc_ptr){//internal function: remove reference to encoder instance and its callbacks
		delete coders[enc_ptr];
	},
	_clear_dec_cb: function(dec_ptr){//internal function: remove reference to decoder instance and its callbacks
		delete coders[dec_ptr];
	},
	/**
	 * Additional options for encoding or decoding
	 * @interface CodingOptions
	 * @memberOf Flac
	 * @property {boolean}  [analyseSubframes] for decoding: include subframes metadata in write-callback metadata, DEFAULT: false
	 * @property {boolean}  [analyseResiduals] for decoding: include residual data in subframes metadata in write-callback metadata, NOTE {@link #analyseSubframes} muste also be enabled, DEFAULT: false
	 * @property {boolean}  [enableRawMetadata] DEBUG option for decoding: enable receiving raw metadata for unknown metadata types in second argument in the metadata-callback, DEFAULT: false
	 *
	 * @see Flac#setOptions
	 * @see Flac~metadata_callback_fn
	 * @see Flac#FLAC__stream_decoder_set_metadata_respond_all
	 */
	/**
	 * FLAC raw metadata
	 *
	 * @interface MetadataBlock
	 * @memberOf Flac
	 * @property {Flac.FLAC__MetadataType}  type the type of the metadata
	 * @property {boolean}  isLast if it is the last block of metadata
	 * @property {number}  length the length of the metadata block (bytes)
	 * @property {Flac.StreamMetadata | Flac.PaddingMetadata | Flac.ApplicationMetadata | Flac.SeekTableMetadata | Flac.CueSheetMetadata | Flac.PictureMetadata}  [data] the metadata (omitted for unknown metadata types)
	 * @property {Uint8Array}  [raw] raw metadata (for debugging: enable via {@link Flac#setOptions})
	 */
	/**
	 * FLAC padding metadata block
	 *
	 * @interface PaddingMetadata
	 * @memberOf Flac
	 * @property {number}  dummy Conceptually this is an empty struct since we don't store the padding bytes. Empty structs are not allowed by some C compilers, hence the dummy.
	 *
	 * @see Flac.FLAC__MetadataType#FLAC__METADATA_TYPE_PADDING
	 */
	/**
	 * FLAC application metadata block
	 *
	 * NOTE the application meta data type is not really supported, i.e. the
	 *      (binary) data is only a pointer to the memory heap.
	 *
	 * @interface ApplicationMetadata
	 * @memberOf Flac
	 * @property {number}  id the application ID
	 * @property {number}  data (pointer)
	 *
	 * @see Flac.FLAC__MetadataType#FLAC__METADATA_TYPE_APPLICATION
	 * @see <a href="https://xiph.org/flac/format.html#metadata_block_application">application block format specification</a>
	 */
	/**
	 * FLAC seek table metadata block
	 *
	 * <p>
	 * From the format specification:
	 *
	 * The seek points must be sorted by ascending sample number.
	 *
	 * Each seek point's sample number must be the first sample of the target frame.
	 *
	 * Each seek point's sample number must be unique within the table
	 *
	 * Existence of a SEEKTABLE block implies a correct setting of total_samples in the stream_info block.
	 *
	 * Behavior is undefined when more than one SEEKTABLE block is present in a stream.
	 *
	 * @interface SeekTableMetadata
	 * @memberOf Flac
	 * @property {number}  num_points the number of seek points
	 * @property {Flac.SeekPoint[]}  points the seek points
	 *
	 * @see Flac.FLAC__MetadataType#FLAC__METADATA_TYPE_SEEKTABLE
	 */
	/**
	 * FLAC seek point data
	 *
	 * @interface SeekPoint
	 * @memberOf Flac
	 * @property {number}  sample_number The sample number of the target frame. NOTE <code>-1</code> for a placeholder point.
	 * @property {number}  stream_offset The offset, in bytes, of the target frame with respect to beginning of the first frame.
	 * @property {number}  frame_samples The number of samples in the target frame.
	 *
	 * @see Flac.SeekTableMetadata
	 */
	/**
	 * FLAC vorbis comment metadata block
	 *
	 * @interface VorbisCommentMetadata
	 * @memberOf Flac
	 * @property {string}  vendor_string the vendor string
	 * @property {number}  num_comments the number of comments
	 * @property {string[]}  comments the comments
	 *
	 * @see Flac.FLAC__MetadataType#FLAC__METADATA_TYPE_VORBIS_COMMENT
	 */
	 /**
	 * FLAC cue sheet metadata block
	 *
	 * @interface CueSheetMetadata
	 * @memberOf Flac
	 * @property {string}  media_catalog_number Media catalog number, in ASCII printable characters 0x20-0x7e. In general, the media catalog number may be 0 to 128 bytes long.
	 * @property {number}  lead_in The number of lead-in samples.
	 * @property {boolean}  is_cd true if CUESHEET corresponds to a Compact Disc, else false.
	 * @property {number}  num_tracks The number of tracks.
	 * @property {Flac.CueSheetTrack[]}  tracks the tracks
	 *
	 * @see Flac.FLAC__MetadataType#FLAC__METADATA_TYPE_CUESHEET
	 */
	 /**
	 * FLAC cue sheet track data
	 *
	 * @interface CueSheetTrack
	 * @memberOf Flac
	 * @property {number}  offset Track offset in samples, relative to the beginning of the FLAC audio stream.
	 * @property {number}  number The track number.
	 * @property {string}  isrc Track ISRC. This is a 12-digit alphanumeric code.
	 * @property {"AUDIO" | "NON_AUDIO"}  type The track type: audio or non-audio.
	 * @property {boolean}  pre_emphasis The pre-emphasis flag
	 * @property {number}  num_indices The number of track index points.
	 * @property {Flac.CueSheetTracIndex}  indices The track index points.
	 *
	 * @see Flac.CueSheetMetadata
	 */
	/**
	 * FLAC track index data for cue sheet metadata
	 *
	 * @interface CueSheetTracIndex
	 * @memberOf Flac
	 * @property {number}  offset Offset in samples, relative to the track offset, of the index point.
	 * @property {number}  number The index point number.
	 *
	 * @see Flac.CueSheetTrack
	 */
	/**
	 * FLAC picture metadata block
	 *
	 * @interface PictureMetadata
	 * @memberOf Flac
	 * @property {Flac.FLAC__StreamMetadata_Picture_Type}  type The kind of picture stored.
	 * @property {string}  mime_type Picture data's MIME type, in ASCII printable characters 0x20-0x7e, NUL terminated. For best compatibility with players, use picture data of MIME type image/jpeg or image/png. A MIME type of '–>' is also allowed, in which case the picture data should be a complete URL.
	 * @property {string}  description Picture's description.
	 * @property {number}  width Picture's width in pixels.
	 * @property {number}  height Picture's height in pixels.
	 * @property {number}  depth Picture's color depth in bits-per-pixel.
	 * @property {number}  colors For indexed palettes (like GIF), picture's number of colors (the number of palette entries), or 0 for non-indexed (i.e. 2^depth).
	 * @property {number}  data_length Length of binary picture data in bytes.
	 * @property {Uint8Array}  data Binary picture data.
	 */
	/**
	 * An enumeration of the PICTURE types (see FLAC__StreamMetadataPicture and id3 v2.4 APIC tag).
	 *
	 * @interface FLAC__StreamMetadata_Picture_Type
	 * @memberOf Flac
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER"} 					0		Other
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD"} 		1		32x32 pixels 'file icon' (PNG only)
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON"} 				2		Other file icon
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER"} 			3		Cover (front)
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER"} 				4		Cover (back)
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE"} 			5		Leaflet page
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA"} 					6		Media (e.g. label side of CD)
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST"} 			7		Lead artist/lead performer/soloist
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST"} 					8		Artist/performer
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR"} 				9		Conductor
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_BAND"} 					10		Band/Orchestra
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER"} 				11		Composer
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST"} 				12		Lyricist/text writer
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION"} 		13		Recording Location
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING"} 		14		During recording
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE"} 		15		During performance
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE"} 	16		Movie/video screen capture
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_FISH"} 					17		A bright coloured fish
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION"} 			18		Illustration
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE"} 			19		Band/artist logotype
	 * @property {"FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE"} 		20		Publisher/Studio logotype
	 *
	 * @see Flac.PictureMetadata
	 */

	/**
	 * An enumeration of the available metadata block types.
	 *
	 * @interface FLAC__MetadataType
	 * @memberOf Flac
	 *
	 * @property {"FLAC__METADATA_TYPE_STREAMINFO"} 		0	STREAMINFO block
	 * @property {"FLAC__METADATA_TYPE_PADDING"} 			1	PADDING block
	 * @property {"FLAC__METADATA_TYPE_APPLICATION"} 		2	APPLICATION block
	 * @property {"FLAC__METADATA_TYPE_SEEKTABLE"} 			3	SEEKTABLE block
	 * @property {"FLAC__METADATA_TYPE_VORBIS_COMMENT"} 	4	VORBISCOMMENT block (a.k.a. FLAC tags)
	 * @property {"FLAC__METADATA_TYPE_CUESHEET"} 			5	CUESHEET block
	 * @property {"FLAC__METADATA_TYPE_PICTURE"} 			6	PICTURE block
	 * @property {"FLAC__METADATA_TYPE_UNDEFINED"} 			7	marker to denote beginning of undefined type range; this number will increase as new metadata types are added
	 * @property {"FLAC__MAX_METADATA_TYPE"} 				126	No type will ever be greater than this. There is not enough room in the protocol block.
	 *
	 * @see Flac.MetadataBlock
	 * @see <a href="https://xiph.org/flac/format.html">FLAC format documentation</a>
	 */
	/**
	 * @function
	 * @public
	 * @memberOf Flac#
	 * @copydoc Flac._setOptions
	 */
	setOptions: _setOptions,
	/**
	 * @function
	 * @public
	 * @memberOf Flac#
	 * @copydoc Flac._getOptions
	 */
	getOptions: _getOptions,
	/**
	 * Returns if Flac has been initialized / is ready to be used.
	 *
	 * @returns {boolean} <code>true</code>, if Flac is ready to be used
	 *
	 * @memberOf Flac#
	 * @function
	 * @see #onready
	 * @see #on
	 */
	isReady: function() { return _flac_ready; },
	/**
	 * Hook for handler function that gets called, when asynchronous initialization has finished.
	 *
	 * NOTE that if the execution environment does not support <code>Object#defineProperty</code>, then
	 *      this function is not called, after {@link #isReady} is <code>true</code>.
	 *      In this case, {@link #isReady} should be checked, before setting <code>onready</code>
	 *      and if it is <code>true</code>, handler should be executed immediately instead of setting <code>onready</code>.
	 *
	 * @memberOf Flac#
	 * @function
	 * @param {Flac.event:ReadyEvent} event the ready-event object
	 * @see #isReady
	 * @see #on
	 * @default undefined
	 * @example
	 *  // [1] if Object.defineProperty() IS supported:
	 *  Flac.onready = function(event){
	 *     //gets executed when library becomes ready, or immediately, if it already is ready...
	 *	   doSomethingWithFlac();
	 *  };
	 *
	 *  // [2] if Object.defineProperty() is NOT supported:
	 *	// do check Flac.isReady(), and only set handler, if not ready yet
	 *  // (otherwise immediately excute handler code)
	 *  if(!Flac.isReady()){
	 *    Flac.onready = function(event){
	 *       //gets executed when library becomes ready...
	 *		 doSomethingWithFlac();
	 *    };
	 *  } else {
	 * 		// Flac is already ready: immediately start processing
	 *		doSomethingWithFlac();
	 *	}
	 */
	onready: void(0),
	/**
	 * Ready event: is fired when the library has been initialized and is ready to be used
	 * (e.g. asynchronous loading of binary / WASM modules has been completed).
	 *
	 * Before this event is fired, use of functions related to encoding and decoding may
	 * cause errors.
	 *
	 * @event ReadyEvent
	 * @memberOf Flac
	 * @type {object}
	 * @property {"ready"} type 	the type of the event <code>"ready"</code>
	 * @property {Flac} target 	the initalized FLAC library instance
	 *
	 * @see #isReady
	 * @see #on
	 */
	/**
	 * Created event: is fired when an encoder or decoder was created.
	 *
	 * @event CreatedEvent
	 * @memberOf Flac
	 * @type {object}
	 * @property {"created"} type 	the type of the event <code>"created"</code>
	 * @property {Flac.CoderChangedEventData} target 	the information for the created encoder or decoder
	 *
	 * @see #on
	 */
	/**
	 * Destroyed event: is fired when an encoder or decoder was destroyed.
	 *
	 * @event DestroyedEvent
	 * @memberOf Flac
	 * @type {object}
	 * @property {"destroyed"} type 	the type of the event <code>"destroyed"</code>
	 * @property {Flac.CoderChangedEventData} target 	the information for the destroyed encoder or decoder
	 *
	 * @see #on
	 */
	/**
	 * Life cycle event data for signaling life cycle changes of encoder or decoder instances
	 * @interface CoderChangedEventData
	 * @memberOf Flac
	 * @property {number}  id  the ID for the encoder or decoder instance
	 * @property {"encoder" | "decoder"}  type  signifies whether the event is for an encoder or decoder instance
	 * @property {any}  [data]  specific data for the life cycle change
	 *
	 * @see Flac.event:CreatedEvent
	 * @see Flac.event:DestroyedEvent
	 */
	/**
	 * Add an event listener for module-events.
	 * Supported events:
	 * <ul>
	 *  <li> <code>"ready"</code> &rarr; {@link Flac.event:ReadyEvent}: emitted when module is ready for usage (i.e. {@link #isReady} is true)<br/>
	 *             <em>NOTE listener will get immediately triggered if module is already <code>"ready"</code></em>
	 *  </li>
	 *  <li> <code>"created"</code> &rarr; {@link Flac.event:CreatedEvent}: emitted when an encoder or decoder instance was created<br/>
	 *  </li>
	 *  <li> <code>"destroyed"</code> &rarr; {@link Flac.event:DestroyedEvent}: emitted when an encoder or decoder instance was destroyed<br/>
	 *  </li>
	 * </ul>
	 *
	 * @param {string} eventName
	 * @param {Function} listener
	 *
	 * @memberOf Flac#
	 * @function
	 * @see #off
	 * @see #onready
	 * @see Flac.event:ReadyEvent
	 * @see Flac.event:CreatedEvent
	 * @see Flac.event:DestroyedEvent
	 * @example
	 *  Flac.on('ready', function(event){
	 *     //gets executed when library is ready, or becomes ready...
	 *  });
	 */
	on: add_event_listener,
	/**
	 * Remove an event listener for module-events.
	 * @param {string} eventName
	 * @param {Function} listener
	 *
	 * @memberOf Flac#
	 * @function
	 * @see #on
	 */
	off: remove_event_listener,

	/**
	 * Set the "verify" flag. If true, the encoder will verify it's own encoded output by feeding it through an internal decoder and comparing the original signal against the decoded signal. If a mismatch occurs, the process call will return false. Note that this will slow the encoding process by the extra time required for decoding and comparison.
	 *
	 * <p>
	 * NOTE: only use on un-initilized encoder instances!
	 *
	 * @param {number} encoder
	 * 				the ID of the encoder instance
	 *
	 * @param {boolean} is_verify enable/disable checksum verification during encoding
	 *
	 * @returns {boolean} <code>false</code> if the encoder is already initialized, else <code>true</code>
	 *
	 * @see #create_libflac_encoder
	 * @see #FLAC__stream_encoder_get_verify
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_encoder_set_verify: function(encoder, is_verify){
		is_verify = is_verify? 1 : 0;
		Module.ccall('FLAC__stream_encoder_set_verify', 'number', ['number', 'number'], [ encoder, is_verify ]);
	},
	/**
	 * Set the compression level
	 *
	 * The compression level is roughly proportional to the amount of effort the encoder expends to compress the file. A higher level usually means more computation but higher compression. The default level is suitable for most applications.
	 *
	 * Currently the levels range from 0 (fastest, least compression) to 8 (slowest, most compression). A value larger than 8 will be treated as 8.
	 *
	 *
	 * <p>
	 * NOTE: only use on un-initilized encoder instances!
	 *
	 * @param {number} encoder
	 * 				the ID of the encoder instance
	 *
	 * @param {Flac.CompressionLevel} compression_level the desired Flac compression level: [0, 8]
	 *
	 * @returns {boolean} <code>false</code> if the encoder is already initialized, else <code>true</code>
	 *
	 * @see #create_libflac_encoder
	 * @see Flac.CompressionLevel
	 * @see <a href="https://xiph.org/flac/api/group__flac__stream__encoder.html#gae49cf32f5256cb47eecd33779493ac85">FLAC API for FLAC__stream_encoder_set_compression_level()</a>
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_encoder_set_compression_level: Module.cwrap('FLAC__stream_encoder_set_compression_level', 'number', [ 'number', 'number' ]),
	/**
	 * Set the blocksize to use while encoding.
	 * The number of samples to use per frame. Use 0 to let the encoder estimate a blocksize; this is usually best.
	 *
	 * <p>
	 * NOTE: only use on un-initilized encoder instances!
	 *
	 * @param {number} encoder
	 * 				the ID of the encoder instance
	 *
	 * @param {number} block_size  the number of samples to use per frame
	 *
	 * @returns {boolean} <code>false</code> if the encoder is already initialized, else <code>true</code>
	 *
	 * @see #create_libflac_encoder
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_encoder_set_blocksize: Module.cwrap('FLAC__stream_encoder_set_blocksize', 'number', [ 'number', 'number']),


	/**
	 * Get the state of the verify stream decoder. Useful when the stream encoder state is FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR.
	 *
	 * @param {number} encoder
	 * 				the ID of the encoder instance
	 *
	 * @returns {Flac.FLAC__StreamDecoderState} the verify stream decoder state
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_encoder_get_verify_decoder_state: Module.cwrap('FLAC__stream_encoder_get_verify_decoder_state', 'number', ['number']),

	/**
	 * Get the "verify" flag for the encoder.
	 *
	 * @param {number} encoder
	 * 				the ID of the encoder instance
	 *
	 * @returns {boolean} the verify flag for the encoder
	 *
	 *
	 * @memberOf Flac#
	 * @function
	 *
	 * @see #FLAC__stream_encoder_set_verify
	 */
	FLAC__stream_encoder_get_verify: Module.cwrap('FLAC__stream_encoder_get_verify', 'number', ['number']),
/*

TODO export other encoder API functions?:

FLAC__bool 	FLAC__stream_encoder_set_channels (FLAC__StreamEncoder *encoder, unsigned value)

FLAC__bool 	FLAC__stream_encoder_set_bits_per_sample (FLAC__StreamEncoder *encoder, unsigned value)

FLAC__bool 	FLAC__stream_encoder_set_sample_rate (FLAC__StreamEncoder *encoder, unsigned value)

FLAC__bool 	FLAC__stream_encoder_set_do_mid_side_stereo (FLAC__StreamEncoder *encoder, FLAC__bool value)

FLAC__bool 	FLAC__stream_encoder_set_loose_mid_side_stereo (FLAC__StreamEncoder *encoder, FLAC__bool value)

FLAC__bool 	FLAC__stream_encoder_set_apodization (FLAC__StreamEncoder *encoder, const char *specification)

FLAC__bool 	FLAC__stream_encoder_set_max_lpc_order (FLAC__StreamEncoder *encoder, unsigned value)

FLAC__bool 	FLAC__stream_encoder_set_qlp_coeff_precision (FLAC__StreamEncoder *encoder, unsigned value)

FLAC__bool 	FLAC__stream_encoder_set_do_qlp_coeff_prec_search (FLAC__StreamEncoder *encoder, FLAC__bool value)

FLAC__bool 	FLAC__stream_encoder_set_do_escape_coding (FLAC__StreamEncoder *encoder, FLAC__bool value)

FLAC__bool 	FLAC__stream_encoder_set_do_exhaustive_model_search (FLAC__StreamEncoder *encoder, FLAC__bool value)

FLAC__bool 	FLAC__stream_encoder_set_min_residual_partition_order (FLAC__StreamEncoder *encoder, unsigned value)

FLAC__bool 	FLAC__stream_encoder_set_max_residual_partition_order (FLAC__StreamEncoder *encoder, unsigned value)

FLAC__bool 	FLAC__stream_encoder_set_rice_parameter_search_dist (FLAC__StreamEncoder *encoder, unsigned value)

FLAC__bool 	FLAC__stream_encoder_get_streamable_subset (const FLAC__StreamEncoder *encoder)

unsigned 	FLAC__stream_encoder_get_channels (const FLAC__StreamEncoder *encoder)

unsigned 	FLAC__stream_encoder_get_bits_per_sample (const FLAC__StreamEncoder *encoder)

unsigned 	FLAC__stream_encoder_get_sample_rate (const FLAC__StreamEncoder *encoder)

unsigned 	FLAC__stream_encoder_get_blocksize (const FLAC__StreamEncoder *encoder)

FLAC__bool 	FLAC__stream_encoder_get_do_mid_side_stereo (const FLAC__StreamEncoder *encoder)

FLAC__bool 	FLAC__stream_encoder_get_loose_mid_side_stereo (const FLAC__StreamEncoder *encoder)

unsigned 	FLAC__stream_encoder_get_max_lpc_order (const FLAC__StreamEncoder *encoder)

unsigned 	FLAC__stream_encoder_get_qlp_coeff_precision (const FLAC__StreamEncoder *encoder)

FLAC__bool 	FLAC__stream_encoder_get_do_qlp_coeff_prec_search (const FLAC__StreamEncoder *encoder)

FLAC__bool 	FLAC__stream_encoder_get_do_escape_coding (const FLAC__StreamEncoder *encoder)

FLAC__bool 	FLAC__stream_encoder_get_do_exhaustive_model_search (const FLAC__StreamEncoder *encoder)

unsigned 	FLAC__stream_encoder_get_min_residual_partition_order (const FLAC__StreamEncoder *encoder)

unsigned 	FLAC__stream_encoder_get_max_residual_partition_order (const FLAC__StreamEncoder *encoder)

unsigned 	FLAC__stream_encoder_get_rice_parameter_search_dist (const FLAC__StreamEncoder *encoder)

FLAC__uint64 	FLAC__stream_encoder_get_total_samples_estimate (const FLAC__StreamEncoder *encoder)



TODO export other decoder API functions?:


const char * 	FLAC__stream_decoder_get_resolved_state_string (const FLAC__StreamDecoder *decoder)

FLAC__uint64 	FLAC__stream_decoder_get_total_samples (const FLAC__StreamDecoder *decoder)

unsigned 	FLAC__stream_decoder_get_channels (const FLAC__StreamDecoder *decoder)

unsigned 	FLAC__stream_decoder_get_bits_per_sample (const FLAC__StreamDecoder *decoder)

unsigned 	FLAC__stream_decoder_get_sample_rate (const FLAC__StreamDecoder *decoder)

unsigned 	FLAC__stream_decoder_get_blocksize (const FLAC__StreamDecoder *decoder)


FLAC__bool 	FLAC__stream_decoder_flush (FLAC__StreamDecoder *decoder)

FLAC__bool 	FLAC__stream_decoder_skip_single_frame (FLAC__StreamDecoder *decoder)

 */

	 /**
	 * Set the compression level
	 *
	 * The compression level is roughly proportional to the amount of effort the encoder expends to compress the file. A higher level usually means more computation but higher compression. The default level is suitable for most applications.
	 *
	 * Currently the levels range from 0 (fastest, least compression) to 8 (slowest, most compression). A value larger than 8 will be treated as 8.
	 *
	 * This function automatically calls the following other set functions with appropriate values, so the client does not need to unless it specifically wants to override them:
	 * <pre>
	 *     FLAC__stream_encoder_set_do_mid_side_stereo()
	 *     FLAC__stream_encoder_set_loose_mid_side_stereo()
	 *     FLAC__stream_encoder_set_apodization()
	 *     FLAC__stream_encoder_set_max_lpc_order()
	 *     FLAC__stream_encoder_set_qlp_coeff_precision()
	 *     FLAC__stream_encoder_set_do_qlp_coeff_prec_search()
	 *     FLAC__stream_encoder_set_do_escape_coding()
	 *     FLAC__stream_encoder_set_do_exhaustive_model_search()
	 *     FLAC__stream_encoder_set_min_residual_partition_order()
	 *     FLAC__stream_encoder_set_max_residual_partition_order()
	 *     FLAC__stream_encoder_set_rice_parameter_search_dist()
	 * </pre>
	 * The actual values set for each level are:
	 * | level  | do mid-side stereo  | loose mid-side stereo  | apodization                                    | max lpc order  | qlp coeff precision  | qlp coeff prec search  | escape coding  | exhaustive model search  | min residual partition order  | max residual partition order  | rice parameter search dist   |
	 * |--------|---------------------|------------------------|------------------------------------------------|----------------|----------------------|------------------------|----------------|--------------------------|-------------------------------|-------------------------------|------------------------------|
	 * | 0      | false               | false                  | tukey(0.5)                                     | 0              | 0                    | false                  | false          | false                    | 0                             | 3                             | 0                            |
	 * | 1      | true                | true                   | tukey(0.5)                                     | 0              | 0                    | false                  | false          | false                    | 0                             | 3                             | 0                            |
	 * | 2      | true                | false                  | tukey(0.5)                                     | 0              | 0                    | false                  | false          | false                    | 0                             | 3                             | 0                            |
	 * | 3      | false               | false                  | tukey(0.5)                                     | 6              | 0                    | false                  | false          | false                    | 0                             | 4                             | 0                            |
	 * | 4      | true                | true                   | tukey(0.5)                                     | 8              | 0                    | false                  | false          | false                    | 0                             | 4                             | 0                            |
	 * | 5      | true                | false                  | tukey(0.5)                                     | 8              | 0                    | false                  | false          | false                    | 0                             | 5                             | 0                            |
	 * | 6      | true                | false                  | tukey(0.5);partial_tukey(2)                    | 8              | 0                    | false                  | false          | false                    | 0                             | 6                             | 0                            |
	 * | 7      | true                | false                  | tukey(0.5);partial_tukey(2)                    | 12             | 0                    | false                  | false          | false                    | 0                             | 6                             | 0                            |
	 * | 8      | true                | false                  | tukey(0.5);partial_tukey(2);punchout_tukey(3)  | 12             | 0                    | false                  | false          | false                    | 0                             | 6                             | 0                            |
	 *
	 * @interface CompressionLevel
	 * @memberOf Flac
	 *
	 * @property {"FLAC__COMPRESSION_LEVEL_0"} 		0	compression level 0
	 * @property {"FLAC__COMPRESSION_LEVEL_1"} 		1	compression level 1
	 * @property {"FLAC__COMPRESSION_LEVEL_2"} 		2	compression level 2
	 * @property {"FLAC__COMPRESSION_LEVEL_3"} 		3	compression level 3
	 * @property {"FLAC__COMPRESSION_LEVEL_4"} 		4	compression level 4
	 * @property {"FLAC__COMPRESSION_LEVEL_5"} 		5	compression level 5
	 * @property {"FLAC__COMPRESSION_LEVEL_6"} 		6	compression level 6
	 * @property {"FLAC__COMPRESSION_LEVEL_7"} 		7	compression level 7
	 * @property {"FLAC__COMPRESSION_LEVEL_8"} 		8	compression level 8
	 */
	/**
	 * Create an encoder.
	 *
	 * @param {number} sample_rate
	 * 					the sample rate of the input PCM data
	 * @param {number} channels
	 * 					the number of channels of the input PCM data
	 * @param {number} bps
	 * 					bits per sample of the input PCM data
	 * @param {Flac.CompressionLevel} compression_level
	 * 					the desired Flac compression level: [0, 8]
	 * @param {number} [total_samples] OPTIONAL
	 * 					the number of total samples of the input PCM data:<br>
	 * 					 Sets an estimate of the total samples that will be encoded.
	 * 					 This is merely an estimate and may be set to 0 if unknown.
	 * 					 This value will be written to the STREAMINFO block before encoding,
	 * 					 and can remove the need for the caller to rewrite the value later if
	 * 					 the value is known before encoding.<br>
	 * 					If specified, the it will be written into metadata of the FLAC header.<br>
	 * 					DEFAULT: 0 (i.e. unknown number of samples)
	 * @param {boolean} [is_verify] OPTIONAL
	 * 					enable/disable checksum verification during encoding<br>
	 * 					DEFAULT: true<br>
	 * 					NOTE: this argument is positional (i.e. total_samples must also be given)
	 * @param {number} [block_size] OPTIONAL
	 * 					the number of samples to use per frame.<br>
	 * 					DEFAULT: 0 (i.e. encoder sets block size automatically)
	 * 					NOTE: this argument is positional (i.e. total_samples and is_verify must also be given)
	 *
	 *
	 * @returns {number} the ID of the created encoder instance (or 0, if there was an error)
	 *
	 * @memberOf Flac#
	 * @function
	 */
	create_libflac_encoder: function(sample_rate, channels, bps, compression_level, total_samples, is_verify, block_size){
		is_verify = typeof is_verify === 'undefined'? 1 : is_verify + 0;
		total_samples = typeof total_samples === 'number'? total_samples : 0;
		block_size = typeof block_size === 'number'? block_size : 0;
		var ok = true;
		var encoder = Module.ccall('FLAC__stream_encoder_new', 'number', [ ], [ ]);
		ok &= Module.ccall('FLAC__stream_encoder_set_verify', 'number', ['number', 'number'], [ encoder, is_verify ]);
		ok &= Module.ccall('FLAC__stream_encoder_set_compression_level', 'number', ['number', 'number'], [ encoder, compression_level ]);
		ok &= Module.ccall('FLAC__stream_encoder_set_channels', 'number', ['number', 'number'], [ encoder, channels ]);
		ok &= Module.ccall('FLAC__stream_encoder_set_bits_per_sample', 'number', ['number', 'number'], [ encoder, bps ]);
		ok &= Module.ccall('FLAC__stream_encoder_set_sample_rate', 'number', ['number', 'number'], [ encoder, sample_rate ]);
		ok &= Module.ccall('FLAC__stream_encoder_set_blocksize', 'number', [ 'number', 'number'], [ encoder, block_size ]);
		ok &= Module.ccall('FLAC__stream_encoder_set_total_samples_estimate', 'number', ['number', 'number'], [ encoder, total_samples ]);
		if (ok){
			do_fire_event('created', [{type: 'created', target: {id: encoder, type: 'encoder'}}], false);
			return encoder;
		}
		return 0;
	},
	/**
	 * @deprecated use {@link #create_libflac_encoder} instead
	 * @memberOf Flac#
	 * @function
	 */
	init_libflac_encoder: function(){
		console.warn('Flac.init_libflac_encoder() is deprecated, use Flac.create_libflac_encoder() instead!');
		return this.create_libflac_encoder.apply(this, arguments);
	},

	/**
	 * Create a decoder.
	 *
	 * @param {boolean} [is_verify]
	 * 				enable/disable checksum verification during decoding<br>
	 * 				DEFAULT: true
	 *
	 * @returns {number} the ID of the created decoder instance (or 0, if there was an error)
	 *
	 * @memberOf Flac#
	 * @function
	 */
	create_libflac_decoder: function(is_verify){
		is_verify = typeof is_verify === 'undefined'? 1 : is_verify + 0;
		var ok = true;
		var decoder = Module.ccall('FLAC__stream_decoder_new', 'number', [ ], [ ]);
		ok &= Module.ccall('FLAC__stream_decoder_set_md5_checking', 'number', ['number', 'number'], [ decoder, is_verify ]);
		if (ok){
			do_fire_event('created', [{type: 'created', target: {id: decoder, type: 'decoder'}}], false);
			return decoder;
		}
		return 0;
	},
	/**
	 * @deprecated use {@link #create_libflac_decoder} instead
	 * @memberOf Flac#
	 * @function
	 */
	init_libflac_decoder: function(){
		console.warn('Flac.init_libflac_decoder() is deprecated, use Flac.create_libflac_decoder() instead!');
		return this.create_libflac_decoder.apply(this, arguments);
	},
	/**
	 * The callback for writing the encoded FLAC data.
	 *
	 * @callback Flac~encoder_write_callback_fn
	 * @param {Uint8Array} data the encoded FLAC data
	 * @param {number} numberOfBytes the number of bytes in data
	 * @param {number} samples the number of samples encoded in data
	 * @param {number} currentFrame the number of the (current) encoded frame in data
	 * @returns {void | false} returning <code>false</code> indicates that an
	 * 								unrecoverable error occurred and decoding should be aborted
	 */
	/**
	 * The callback for the metadata of the encoded/decoded Flac data.
	 *
	 * By default, only the STREAMINFO metadata is enabled.
	 *
	 * For other metadata types {@link Flac.FLAC__MetadataType} they need to be enabled,
	 * see e.g. {@link Flac#FLAC__stream_decoder_set_metadata_respond}
	 *
	 * @callback Flac~metadata_callback_fn
	 * @param {Flac.StreamMetadata | undefined} metadata the FLAC meta data, NOTE only STREAMINFO is returned in first argument, for other types use 2nd argument's <code>metadataBlock.data<code>
	 * @param {Flac.MetadataBlock} metadataBlock the detailed meta data block
	 *
	 * @see Flac#init_decoder_stream
	 * @see Flac#init_encoder_stream
	 * @see Flac.CodingOptions
	 * @see Flac#FLAC__stream_decoder_set_metadata_respond_all
	 */
	/**
	 * FLAC meta data
	 * @interface Metadata
	 * @memberOf Flac
	 * @property {number}  sampleRate the sample rate (Hz)
	 * @property {number}  channels the number of channels
	 * @property {number}  bitsPerSample bits per sample
	 */
	/**
	 * FLAC stream meta data
	 * @interface StreamMetadata
	 * @memberOf Flac
	 * @augments Flac.Metadata
	 * @property {number}  min_blocksize the minimal block size (bytes)
	 * @property {number}  max_blocksize the maximal block size (bytes)
	 * @property {number}  min_framesize the minimal frame size (bytes)
	 * @property {number}  max_framesize the maximal frame size (bytes)
	 * @property {number}  total_samples the total number of (encoded/decoded) samples
	 * @property {string}  md5sum  the MD5 checksum for the decoded data (if validation is active)
	 */
	/**
	 * Initialize the encoder.
	 *
	 * @param {number} encoder
	 * 				the ID of the encoder instance that has not been initialized (or has been reset)
	 *
	 * @param {Flac~encoder_write_callback_fn} write_callback_fn
	 * 				the callback for writing the encoded Flac data:
	 * 				<pre>write_callback_fn(data: Uint8Array, numberOfBytes: Number, samples: Number, currentFrame: Number)</pre>
	 *
	 * @param {Flac~metadata_callback_fn} [metadata_callback_fn] OPTIONAL
	 * 				the callback for the metadata of the encoded Flac data:
	 * 				<pre>metadata_callback_fn(metadata: StreamMetadata)</pre>
	 *
	 * @param {number|boolean} [ogg_serial_number] OPTIONAL
	 * 				if number or <code>true</code> is specified, the encoder will be initialized to
	 * 				write to an OGG container, see {@link Flac.init_encoder_ogg_stream}:
	 * 				<code>true</code> will set a default serial number (<code>1</code>),
	 * 				if specified as number, it will be used as the stream's serial number within the ogg container.
	 *
	 * @returns {Flac.FLAC__StreamEncoderInitStatus} the encoder status (<code>0</code> for <code>FLAC__STREAM_ENCODER_INIT_STATUS_OK</code>)
	 *
	 * @memberOf Flac#
	 * @function
	 */
	init_encoder_stream: function(encoder, write_callback_fn, metadata_callback_fn, ogg_serial_number, client_data){

		var is_ogg = (ogg_serial_number === true);
		client_data = client_data|0;

		if(typeof write_callback_fn !== 'function'){
			return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS;
		}
		setCallback(encoder, 'write', write_callback_fn);

		var __metadata_callback_fn_ptr = 0;
		if(typeof metadata_callback_fn === 'function'){
			setCallback(encoder, 'metadata', metadata_callback_fn);
			__metadata_callback_fn_ptr = metadata_fn_ptr;
		}

		//NOTE the following comments are used for auto-detecting exported functions (only change if ccall function name(s) change!):
		//	Module.ccall('FLAC__stream_encoder_init_stream'
		var func_name = 'FLAC__stream_encoder_init_stream';
		var args_types = ['number', 'number', 'number', 'number', 'number', 'number'];
		var args = [
			encoder,
			enc_write_fn_ptr,
			0,//	FLAC__StreamEncoderSeekCallback
			0,//	FLAC__StreamEncoderTellCallback
			__metadata_callback_fn_ptr,
			client_data
		];

		if(typeof ogg_serial_number === 'number'){

			is_ogg = true;

		} else if(is_ogg){//else: set default serial number for stream in OGG container

			//NOTE from FLAC docs: "It is recommended to set a serial number explicitly as the default of '0' may collide with other streams."
			ogg_serial_number = 1;
		}

		if(is_ogg){
			//NOTE the following comments are used for auto-detecting exported functions (only change if ccall function name(s) change!):
			//	Module.ccall('FLAC__stream_encoder_init_ogg_stream'
			func_name = 'FLAC__stream_encoder_init_ogg_stream';

			//2nd arg: FLAC__StreamEncoderReadCallback ptr -> duplicate first entry & insert at [1]
			args.unshift(args[0]);
			args[1] = 0;//	FLAC__StreamEncoderReadCallback

			args_types.unshift(args_types[0]);
			args_types[1] = 'number';


			//NOTE ignore BOOL return value when setting serial number, since init-call's returned
			//     status will also indicate, if encoder already has been initialized
			Module.ccall(
				'FLAC__stream_encoder_set_ogg_serial_number', 'number',
				['number', 'number'],
				[ encoder, ogg_serial_number ]
			);
		}

		var init_status = Module.ccall(func_name, 'number', args_types, args);

		return init_status;
	},
	/**
	 * Initialize the encoder for writing to an OGG container.
	 *
	 * @param {number} [ogg_serial_number] OPTIONAL
	 * 				the serial number for the stream in the OGG container
	 * 				DEFAULT: <code>1</code>
	 *
	 * @memberOf Flac#
	 * @function
	 * @copydoc #init_encoder_stream
	 */
	init_encoder_ogg_stream: function(encoder, write_callback_fn, metadata_callback_fn, ogg_serial_number, client_data){

		if(typeof ogg_serial_number !== 'number'){
			ogg_serial_number = true;
		}
		return this.init_encoder_stream(encoder, write_callback_fn, metadata_callback_fn, ogg_serial_number, client_data);
	},
	/**
	 * Result / return value for {@link Flac~decoder_read_callback_fn} callback function
	 *
	 * @interface ReadResult
	 * @memberOf Flac
	 * @property {TypedArray}  buffer  a TypedArray (e.g. Uint8Array) with the read data
	 * @property {number}  readDataLength the number of read data bytes. A number of <code>0</code> (zero) indicates that the end-of-stream is reached.
	 * @property {boolean}  [error] OPTIONAL value of <code>true</code> indicates that an error occured (decoding will be aborted)
	 */
	/**
	 * Result / return value for {@link Flac~decoder_read_callback_fn} callback function for signifying that there is no more data to read
	 *
	 * @interface CompletedReadResult
	 * @memberOf Flac
	 * @augments Flac.ReadResult
	 * @property {TypedArray | undefined}  buffer  a TypedArray (e.g. Uint8Array) with the read data (will be ignored in case readDataLength is <code>0</code>)
	 * @property {0}  readDataLength the number of read data bytes: The number of <code>0</code> (zero) indicates that the end-of-stream is reached.
	 */
	/**
	 * The callback for reading the FLAC data that will be decoded.
	 *
	 * @callback Flac~decoder_read_callback_fn
	 * @param {number} numberOfBytes the maximal number of bytes that the read callback can return
	 * @returns {Flac.ReadResult | Flac.CompletedReadResult} the result of the reading action/request
	 */
	/**
	 * The callback for writing the decoded FLAC data.
	 *
	 * @callback Flac~decoder_write_callback_fn
	 * @param {Uint8Array[]} data array of the channels with the decoded PCM data as <code>Uint8Array</code>s
	 * @param {Flac.BlockMetadata} frameInfo the metadata information for the decoded data
	 */
	/**
	 * The callback for reporting decoding errors.
	 *
	 * @callback Flac~decoder_error_callback_fn
	 * @param {number} errorCode the error code
	 * @param {Flac.FLAC__StreamDecoderErrorStatus} errorDescription the string representation / description of the error
	 */
	/**
	 * FLAC block meta data
	 * @interface BlockMetadata
	 * @augments Flac.Metadata
	 * @memberOf Flac
	 *
	 * @property {number}  blocksize the block size (bytes)
	 * @property {number}  number the number of the decoded samples or frames
	 * @property {string}  numberType the type to which <code>number</code> refers to: either <code>"frames"</code> or <code>"samples"</code>
	 * @property {Flac.FLAC__ChannelAssignment} channelAssignment the channel assignment
	 * @property {string}  crc the MD5 checksum for the decoded data, if validation is enabled
	 * @property {Flac.SubFrameMetadata[]}  [subframes] the metadata of the subframes. The array length corresponds to the number of channels. NOTE will only be included if {@link Flac.CodingOptions CodingOptions.analyseSubframes} is enabled for the decoder.
	 *
	 * @see Flac.CodingOptions
	 * @see Flac#setOptions
	 */
	/**
	 * FLAC subframe metadata
	 * @interface SubFrameMetadata
	 * @memberOf Flac
	 *
	 * @property {Flac.FLAC__SubframeType}  type the type of the subframe
	 * @property {number|Flac.FixedSubFrameData|Flac.LPCSubFrameData}  data the type specific metadata for subframe
	 * @property {number}  wastedBits the wasted bits-per-sample
	 */
	/**
	 * metadata for FIXED subframe type
	 * @interface FixedSubFrameData
	 * @memberOf Flac
	 *
	 * @property {number}  order  The polynomial order.
	 * @property {number[]}  warmup  Warmup samples to prime the predictor, length == order.
	 * @property {Flac.SubFramePartition}  partition  The residual coding method.
	 * @property {number[]}  [residual]  The residual signal, length == (blocksize minus order) samples.
	 * 									NOTE will only be included if {@link Flac.CodingOptions CodingOptions.analyseSubframes} is enabled for the decoder.
	 */
	/**
	 * metadata for LPC subframe type
	 * @interface LPCSubFrameData
	 * @augments Flac.FixedSubFrameData
	 * @memberOf Flac
	 *
	 * @property {number}  order  The FIR order.
	 * @property {number[]}  qlp_coeff  FIR filter coefficients.
	 * @property {number}  qlp_coeff_precision  Quantized FIR filter coefficient precision in bits.
	 * @property {number}  quantization_level The qlp coeff shift needed.
	 */
	/**
	 * metadata for FIXED or LPC subframe partitions
	 * @interface SubFramePartition
	 * @memberOf Flac
	 *
	 * @property {Flac.FLAC__EntropyCodingMethodType}  type  the entropy coding method
	 * @property {Flac.SubFramePartitionData}  data  metadata for a Rice partitioned residual
	 */
	/**
	 * metadata for FIXED or LPC subframe partition data
	 * @interface SubFramePartitionData
	 * @memberOf Flac
	 *
	 * @property {number}  order  The partition order, i.e. # of contexts = 2 ^ order.
	 * @property {Flac.SubFramePartitionContent}  contents  The context's Rice parameters and/or raw bits.
	 */
	/**
	 * metadata for FIXED or LPC subframe partition data content
	 * @interface SubFramePartitionContent
	 * @memberOf Flac
	 *
	 * @property {number[]}  parameters  The Rice parameters for each context.
	 * @property {number[]}  rawBits  Widths for escape-coded partitions. Will be non-zero for escaped partitions and zero for unescaped partitions.
	 * @property {number}  capacityByOrder  The capacity of the parameters and raw_bits arrays specified as an order, i.e. the number of array elements allocated is 2 ^ capacity_by_order.
	 */
	/**
	 * The types for FLAC subframes
	 *
	 * @interface FLAC__SubframeType
	 * @memberOf Flac
	 *
	 * @property {"FLAC__SUBFRAME_TYPE_CONSTANT"} 	0	constant signal
	 * @property {"FLAC__SUBFRAME_TYPE_VERBATIM"} 	1	uncompressed signal
	 * @property {"FLAC__SUBFRAME_TYPE_FIXED"} 		2	fixed polynomial prediction
	 * @property {"FLAC__SUBFRAME_TYPE_LPC"} 		3	linear prediction
	 */
	/**
	 * The channel assignment for the (decoded) frame.
	 *
	 * @interface FLAC__ChannelAssignment
	 * @memberOf Flac
	 *
	 * @property {"FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT"} 		0	independent channels
	 * @property {"FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE"}  		1	left+side stereo
	 * @property {"FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE"} 		2	right+side stereo
	 * @property {"FLAC__CHANNEL_ASSIGNMENT_MID_SIDE"}			3	mid+side stereo
	 */
	/**
	 * entropy coding methods
	 *
	 * @interface FLAC__EntropyCodingMethodType
	 * @memberOf Flac
	 *
	 * @property {"FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE"} 	0	Residual is coded by partitioning into contexts, each with it's own 4-bit Rice parameter.
	 * @property {"FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2"} 	1	Residual is coded by partitioning into contexts, each with it's own 5-bit Rice parameter.
	 */
	/**
	 * Initialize the decoder.
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance that has not been initialized (or has been reset)
	 *
	 * @param {Flac~decoder_read_callback_fn} read_callback_fn
	 * 				the callback for reading the Flac data that should get decoded:
	 * 				<pre>read_callback_fn(numberOfBytes: Number) : {buffer: ArrayBuffer, readDataLength: number, error: boolean}</pre>
	 *
	 * @param {Flac~decoder_write_callback_fn} write_callback_fn
	 * 				the callback for writing the decoded data:
	 * 				<pre>write_callback_fn(data: Uint8Array[], frameInfo: Metadata)</pre>
	 *
	 * @param {Flac~decoder_error_callback_fn} error_callback_fn
	 * 				the error callback:
	 * 				<pre>error_callback_fn(errorCode: Number, errorDescription: String)</pre>
	 *
	 * @param {Flac~metadata_callback_fn} [metadata_callback_fn] OPTIONAL
	 * 				callback for receiving the metadata of FLAC data that will be decoded:
	 * 				<pre>metadata_callback_fn(metadata: StreamMetadata)</pre>
	 *
	 * @param {number|boolean} [ogg_serial_number] OPTIONAL
	 * 				if number or <code>true</code> is specified, the decoder will be initilized to
	 * 				read from an OGG container, see {@link Flac.init_decoder_ogg_stream}:<br/>
	 * 				<code>true</code> will use the default serial number, if specified as number the
	 * 				corresponding stream with the serial number from the ogg container will be used.
	 *
	 * @returns {Flac.FLAC__StreamDecoderInitStatus} the decoder status(<code>0</code> for <code>FLAC__STREAM_DECODER_INIT_STATUS_OK</code>)
	 *
	 * @memberOf Flac#
	 * @function
	 */
	init_decoder_stream: function(decoder, read_callback_fn, write_callback_fn, error_callback_fn, metadata_callback_fn, ogg_serial_number, client_data){

		client_data = client_data|0;

		if(typeof read_callback_fn !== 'function'){
			return FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS;
		}
		setCallback(decoder, 'read', read_callback_fn);

		if(typeof write_callback_fn !== 'function'){
			return FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS;
		}
		setCallback(decoder, 'write', write_callback_fn);

		var __error_callback_fn_ptr = 0;
		if(typeof error_callback_fn === 'function'){
			setCallback(decoder, 'error', error_callback_fn);
			__error_callback_fn_ptr = dec_error_fn_ptr;
		}

		var __metadata_callback_fn_ptr = 0;
		if(typeof metadata_callback_fn === 'function'){
			setCallback(decoder, 'metadata', metadata_callback_fn);
			__metadata_callback_fn_ptr = metadata_fn_ptr;
		}

		var is_ogg = (ogg_serial_number === true);
		if(typeof ogg_serial_number === 'number'){

			is_ogg = true;

			//NOTE ignore BOOL return value when setting serial number, since init-call's returned
			//     status will also indicate, if decoder already has been initialized
			Module.ccall(
				'FLAC__stream_decoder_set_ogg_serial_number', 'number',
				['number', 'number'],
				[ decoder, ogg_serial_number ]
			);
		}

		//NOTE the following comments are used for auto-detecting exported functions (only change if ccall function name(s) change!):
		//	Module.ccall('FLAC__stream_decoder_init_stream'
		//	Module.ccall('FLAC__stream_decoder_init_ogg_stream'
		var init_func_name = !is_ogg? 'FLAC__stream_decoder_init_stream' : 'FLAC__stream_decoder_init_ogg_stream';

		var init_status = Module.ccall(
				init_func_name, 'number',
				[ 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number', 'number'],
				[
					 decoder,
					 dec_read_fn_ptr,
					 0,// 	FLAC__StreamDecoderSeekCallback
					 0,// 	FLAC__StreamDecoderTellCallback
					 0,//	FLAC__StreamDecoderLengthCallback
					 0,//	FLAC__StreamDecoderEofCallback
					 dec_write_fn_ptr,
					 __metadata_callback_fn_ptr,
					 __error_callback_fn_ptr,
					 client_data
				]
		);

		return init_status;
	},
	/**
	 * Initialize the decoder for writing to an OGG container.
	 *
	 * @param {number} [ogg_serial_number] OPTIONAL
	 * 				the serial number for the stream in the OGG container that should be decoded.<br/>
	 * 				The default behavior is to use the serial number of the first Ogg page. Setting a serial number here will explicitly specify which stream is to be decoded.
	 *
	 * @memberOf Flac#
	 * @function
	 * @copydoc #init_decoder_stream
	 */
	init_decoder_ogg_stream: function(decoder, read_callback_fn, write_callback_fn, error_callback_fn, metadata_callback_fn, ogg_serial_number, client_data){

		if(typeof ogg_serial_number !== 'number'){
			ogg_serial_number = true;
		}
		return this.init_decoder_stream(decoder, read_callback_fn, write_callback_fn, error_callback_fn, metadata_callback_fn, ogg_serial_number, client_data);
	},
	/**
	 * Encode / submit data for encoding.
	 *
	 * This version allows you to supply the input data where the channels are interleaved into a
	 * single array (i.e. channel0_sample0, channel1_sample0, ... , channelN_sample0, channel0_sample1, ...).
	 *
	 * The samples need not be block-aligned but they must be sample-aligned, i.e. the first value should be
	 * channel0_sample0 and the last value channelN_sampleM.
	 *
	 * Each sample should be a signed integer, right-justified to the resolution set by bits-per-sample.
	 *
	 * For example, if the resolution is 16 bits per sample, the samples should all be in the range [-32768,32767].
	 *
	 *
	 * For applications where channel order is important, channels must follow the order as described in the frame header.
	 *
	 * @param {number} encoder
	 * 				the ID of the encoder instance
	 *
	 * @param {TypedArray} buffer
	 * 				the audio data in a typed array with signed integers (and size according to the set bits-per-sample setting)
	 *
	 * @param {number} num_of_samples
	 * 				the number of samples in buffer
	 *
	 * @returns {boolean} true if successful, else false; in this case, check the encoder state with FLAC__stream_encoder_get_state() to see what went wrong.
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_encoder_process_interleaved: function(encoder, buffer, num_of_samples){
		// get the length of the data in bytes
		var numBytes = buffer.length * buffer.BYTES_PER_ELEMENT;
		// malloc enough space for the data
		var ptr = Module._malloc(numBytes);
		// get a bytes-wise view on the newly allocated buffer
		var heapBytes= new Uint8Array(Module.HEAPU8.buffer, ptr, numBytes);
		// copy data into heapBytes
		heapBytes.set(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength));// issue #11 (2): do use byteOffset and byteLength for copying the data in case the underlying buffer/ArrayBuffer of the TypedArray view is larger than the TypedArray
		var status = Module.ccall('FLAC__stream_encoder_process_interleaved', 'number',
				['number', 'number', 'number'],
				[encoder, heapBytes.byteOffset, num_of_samples]
		);
		Module._free(ptr);
		return status;
	},

	/**
	 * Encode / submit data for encoding.
	 *
	 * Submit data for encoding. This version allows you to supply the input data via an array of pointers,
	 * each pointer pointing to an array of samples samples representing one channel.
	 * The samples need not be block-aligned, but each channel should have the same number of samples.
	 *
	 * Each sample should be a signed integer, right-justified to the resolution set by FLAC__stream_encoder_set_bits_per_sample().
	 * For example, if the resolution is 16 bits per sample, the samples should all be in the range [-32768,32767].
	 *
	 *
	 * For applications where channel order is important, channels must follow the order as described in the frame header.
	 *
	 * @param {number} encoder
	 * 				the ID of the encoder instance
	 *
	 * @param {TypedArray[]} channelBuffers
	 * 				an array for the audio data channels as typed arrays with signed integers (and size according to the set bits-per-sample setting)
	 *
	 * @param {number} num_of_samples
	 * 				the number of samples in one channel (i.e. one of the buffers)
	 *
	 * @returns {boolean} true if successful, else false; in this case, check the encoder state with FLAC__stream_encoder_get_state() to see what went wrong.
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_encoder_process: function(encoder, channelBuffers, num_of_samples){

		var ptrInfo = this._create_pointer_array(channelBuffers);
		var pointerPtr = ptrInfo.pointerPointer;

		var status = Module.ccall('FLAC__stream_encoder_process', 'number',
				['number', 'number', 'number'],
				[encoder, pointerPtr, num_of_samples]
		);

		this._destroy_pointer_array(ptrInfo);
		return status;
	},
	/**
	 * Decodes a single frame.
	 *
	 * To check decoding progress, use {@link #FLAC__stream_decoder_get_state}.
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @returns {boolean} FALSE if an error occurred
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_decoder_process_single: Module.cwrap('FLAC__stream_decoder_process_single', 'number', ['number']),

	/**
	 * Decodes data until end of stream.
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @returns {boolean} FALSE if an error occurred
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_decoder_process_until_end_of_stream: Module.cwrap('FLAC__stream_decoder_process_until_end_of_stream', 'number', ['number']),

	/**
	 * Decodes data until end of metadata.
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @returns {boolean} false if any fatal read, write, or memory allocation error occurred (meaning decoding must stop), else true.
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_decoder_process_until_end_of_metadata: Module.cwrap('FLAC__stream_decoder_process_until_end_of_metadata', 'number', ['number']),

	/**
	 * Decoder state code.
	 *
	 * @interface FLAC__StreamDecoderState
	 * @memberOf Flac
	 *
	 * @property {"FLAC__STREAM_DECODER_SEARCH_FOR_METADATA"} 		0	The decoder is ready to search for metadata
	 * @property {"FLAC__STREAM_DECODER_READ_METADATA"}  			1	The decoder is ready to or is in the process of reading metadata
	 * @property {"FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC"} 	2	The decoder is ready to or is in the process of searching for the frame sync code
	 * @property {"FLAC__STREAM_DECODER_READ_FRAME"}				3	The decoder is ready to or is in the process of reading a frame
	 * @property {"FLAC__STREAM_DECODER_END_OF_STREAM"}				4	The decoder has reached the end of the stream
	 * @property {"FLAC__STREAM_DECODER_OGG_ERROR"}					5	An error occurred in the underlying Ogg layer
	 * @property {"FLAC__STREAM_DECODER_SEEK_ERROR"}				6	An error occurred while seeking. The decoder must be flushed with FLAC__stream_decoder_flush() or reset with FLAC__stream_decoder_reset() before decoding can continue
	 * @property {"FLAC__STREAM_DECODER_ABORTED"}					7	The decoder was aborted by the read callback
	 * @property {"FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR"}	8	An error occurred allocating memory. The decoder is in an invalid state and can no longer be used
	 * @property {"FLAC__STREAM_DECODER_UNINITIALIZED"}				9	The decoder is in the uninitialized state; one of the FLAC__stream_decoder_init_*() functions must be called before samples can be processed.
	 *
	 */
	/**
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @returns {Flac.FLAC__StreamDecoderState} the decoder state
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_decoder_get_state: Module.cwrap('FLAC__stream_decoder_get_state', 'number', ['number']),

	/**
	 * Encoder state code.
	 *
	 * @interface FLAC__StreamEncoderState
	 * @memberOf Flac
	 *
	 * @property {"FLAC__STREAM_ENCODER_OK"}								0 	The encoder is in the normal OK state and samples can be processed.
	 * @property {"FLAC__STREAM_ENCODER_UNINITIALIZED"}						1 	The encoder is in the uninitialized state; one of the FLAC__stream_encoder_init_*() functions must be called before samples can be processed.
	 * @property {"FLAC__STREAM_ENCODER_OGG_ERROR"}							2 	An error occurred in the underlying Ogg layer.
	 * @property {"FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR"}				3 	An error occurred in the underlying verify stream decoder; check FLAC__stream_encoder_get_verify_decoder_state().
	 * @property {"FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA"}		4 	The verify decoder detected a mismatch between the original audio signal and the decoded audio signal.
	 * @property {"FLAC__STREAM_ENCODER_CLIENT_ERROR"}						5 	One of the callbacks returned a fatal error.
	 * @property {"FLAC__STREAM_ENCODER_IO_ERROR"}							6 	An I/O error occurred while opening/reading/writing a file. Check errno.
	 * @property {"FLAC__STREAM_ENCODER_FRAMING_ERROR"}						7 	An error occurred while writing the stream; usually, the write_callback returned an error.
	 * @property {"FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR"}			8 	Memory allocation failed.
	 *
	 */
	/**
	 *
	 * @param {number} encoder
	 * 				the ID of the encoder instance
	 *
	 * @returns {Flac.FLAC__StreamEncoderState} the encoder state
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_encoder_get_state:  Module.cwrap('FLAC__stream_encoder_get_state', 'number', ['number']),
	/**
	 * Direct the decoder to pass on all metadata blocks of type type.
	 *
	 * By default, only the STREAMINFO block is returned via the metadata callback.
	 *
	 * <p>
	 * NOTE: only use on un-initilized decoder instances!
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @param {Flac.FLAC__MetadataType} type  the metadata type to be enabled
	 *
	 * @returns {boolean} <code>false</code> if the decoder is already initialized, else <code>true</code>
	 *
	 * @memberOf Flac#
	 * @function
	 *
	 * @see Flac#FLAC__stream_decoder_set_metadata_respond_all
	 */
	FLAC__stream_decoder_set_metadata_respond: Module.cwrap('FLAC__stream_decoder_set_metadata_respond', 'number', ['number', 'number']),
	/**
	 * Direct the decoder to pass on all APPLICATION metadata blocks of the given id.
	 *
	 * By default, only the STREAMINFO block is returned via the metadata callback.
	 *
	 * <p>
	 * NOTE: only use on un-initilized decoder instances!
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @param {number} id  the ID of application metadata
	 *
	 * @returns {boolean} <code>false</code> if the decoder is already initialized, else <code>true</code>
	 *
	 * @memberOf Flac#
	 * @function
	 *
	 * @see Flac#FLAC__stream_decoder_set_metadata_respond_all
	 */
	FLAC__stream_decoder_set_metadata_respond_application: Module.cwrap('FLAC__stream_decoder_set_metadata_respond_application', 'number', ['number', 'number']),// (FLAC__StreamDecoder *decoder, const FLAC__byte id[4])
	/**
	 * Direct the decoder to pass on all metadata blocks of any type.
	 *
	 * By default, only the STREAMINFO block is returned via the metadata callback.
	 *
	 * <p>
	 * NOTE: only use on un-initilized decoder instances!
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @returns {boolean} <code>false</code> if the decoder is already initialized, else <code>true</code>
	 *
	 * @memberOf Flac#
	 * @function
	 *
	 * @see Flac#FLAC__stream_decoder_set_metadata_ignore_all
	 * @see Flac#FLAC__stream_decoder_set_metadata_respond_application
	 * @see Flac#FLAC__stream_decoder_set_metadata_respond
	 */
	FLAC__stream_decoder_set_metadata_respond_all: Module.cwrap('FLAC__stream_decoder_set_metadata_respond_all', 'number', ['number']),// (FLAC__StreamDecoder *decoder)
	/**
	 * Direct the decoder to filter out all metadata blocks of type type.
	 *
	 * By default, only the STREAMINFO block is returned via the metadata callback.
	 *
	 * <p>
	 * NOTE: only use on un-initilized decoder instances!
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @param {Flac.FLAC__MetadataType} type  the metadata type to be ignored
	 *
	 * @returns {boolean} <code>false</code> if the decoder is already initialized, else <code>true</code>
	 *
	 * @memberOf Flac#
	 * @function
	 *
	 * @see Flac#FLAC__stream_decoder_set_metadata_ignore_all
	 */
	FLAC__stream_decoder_set_metadata_ignore: Module.cwrap('FLAC__stream_decoder_set_metadata_ignore', 'number', ['number', 'number']),// (FLAC__StreamDecoder *decoder, FLAC__MetadataType type)
	/**
	 * Direct the decoder to filter out all APPLICATION metadata blocks of the given id.
	 *
	 * By default, only the STREAMINFO block is returned via the metadata callback.
	 *
	 * <p>
	 * NOTE: only use on un-initilized decoder instances!
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @param {number} id  the ID of application metadata
	 *
	 * @returns {boolean} <code>false</code> if the decoder is already initialized, else <code>true</code>
	 *
	 * @memberOf Flac#
	 * @function
	 *
	 * @see Flac#FLAC__stream_decoder_set_metadata_ignore_all
	 */
	FLAC__stream_decoder_set_metadata_ignore_application: Module.cwrap('FLAC__stream_decoder_set_metadata_ignore_application', 'number', ['number', 'number']),// (FLAC__StreamDecoder *decoder, const FLAC__byte id[4])
	/**
	 * Direct the decoder to filter out all metadata blocks of any type.
	 *
	 * By default, only the STREAMINFO block is returned via the metadata callback.
	 *
	 * <p>
	 * NOTE: only use on un-initilized decoder instances!
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @returns {boolean} <code>false</code> if the decoder is already initialized, else <code>true</code>
	 *
	 * @memberOf Flac#
	 * @function
	 *
	 * @see Flac#FLAC__stream_decoder_set_metadata_respond_all
	 * @see Flac#FLAC__stream_decoder_set_metadata_ignore
	 * @see Flac#FLAC__stream_decoder_set_metadata_ignore_application
	 */
	FLAC__stream_decoder_set_metadata_ignore_all: Module.cwrap('FLAC__stream_decoder_set_metadata_ignore_all', 'number', ['number']),// (FLAC__StreamDecoder *decoder)
	/**
	 * Set the metadata blocks to be emitted to the stream before encoding. A value of NULL, 0 implies no metadata; otherwise, supply an array of pointers to metadata blocks.
	 * The array is non-const since the encoder may need to change the is_last flag inside them, and in some cases update seek point offsets. Otherwise, the encoder
	 * will not modify or free the blocks. It is up to the caller to free the metadata blocks after encoding finishes.
	 *
	 * <p>
	 *     The encoder stores only copies of the pointers in the metadata array; the metadata blocks themselves must survive at least until after FLAC__stream_encoder_finish() returns.
	 *     Do not free the blocks until then.
	 *
	 *     The STREAMINFO block is always written and no STREAMINFO block may occur in the supplied array.
	 *
	 *     By default the encoder does not create a SEEKTABLE. If one is supplied in the metadata array, but the client has specified that it does not support seeking,
	 *     then the SEEKTABLE will be written verbatim. However by itself this is not very useful as the client will not know the stream offsets for the seekpoints ahead of time.
	 *     In order to get a proper seektable the client must support seeking. See next note.
	 *
	 *     SEEKTABLE blocks are handled specially. Since you will not know the values for the seek point stream offsets, you should pass in a SEEKTABLE 'template', that is,
	 *     a SEEKTABLE object with the required sample numbers (or placeholder points), with 0 for the frame_samples and stream_offset fields for each point.
	 *     If the client has specified that it supports seeking by providing a seek callback to FLAC__stream_encoder_init_stream() or both seek AND read callback to
	 *      FLAC__stream_encoder_init_ogg_stream() (or by using FLAC__stream_encoder_init*_file() or FLAC__stream_encoder_init*_FILE()), then while it is encoding the encoder will
	 *      fill the stream offsets in for you and when encoding is finished, it will seek back and write the real values into the SEEKTABLE block in the stream. There are helper
	 *      routines for manipulating seektable template blocks; see metadata.h: FLAC__metadata_object_seektable_template_*(). If the client does not support seeking,
	 *      the SEEKTABLE will have inaccurate offsets which will slow down or remove the ability to seek in the FLAC stream.
	 *
	 *     The encoder instance will modify the first SEEKTABLE block as it transforms the template to a valid seektable while encoding, but it is still up to the caller to free
	 *     all metadata blocks after encoding.
	 *
	 *     A VORBIS_COMMENT block may be supplied. The vendor string in it will be ignored. libFLAC will use it's own vendor string. libFLAC will not modify the passed-in
	 *     VORBIS_COMMENT's vendor string, it will simply write it's own into the stream. If no VORBIS_COMMENT block is present in the metadata array, libFLAC will write an
	 *     empty one, containing only the vendor string.
	 *
	 *     The Ogg FLAC mapping requires that the VORBIS_COMMENT block be the second metadata block of the stream. The encoder already supplies the STREAMINFO block automatically.
	 *
	 *     If metadata does not contain a VORBIS_COMMENT block, the encoder will supply that too. Otherwise, if metadata does contain a VORBIS_COMMENT block and it is not the first,
	 *     the init function will reorder metadata by moving the VORBIS_COMMENT block to the front; the relative ordering of the other blocks will remain as they were.
	 *
	 *     The Ogg FLAC mapping limits the number of metadata blocks per stream to 65535. If num_blocks exceeds this the function will return false.
	 *
	 * @param {number} encoder
	 * 				the ID of the encoder instance
	 *
	 * @param {Flac.PointerInfo} metadataBuffersPointer
	 *
	 * @param {number} num_blocks
	 *
	 * @returns {boolean} <code>false</code> if the encoder is already initialized, else <code>true</code>. <code>false</code> if the encoder is already initialized, or if num_blocks > 65535 if encoding to Ogg FLAC, else true.
	 *
	 * @memberOf Flac#
	 * @function
	 *
	 * @see Flac.FLAC__MetadataType
	 * @see Flac#_create_pointer_array
	 * @see Flac#_destroy_pointer_array
	 */
	FLAC__stream_encoder_set_metadata: function(encoder, metadataBuffersPointer, num_blocks){// ( FLAC__StreamEncoder *  encoder, FLAC__StreamMetadata **  metadata, unsigned  num_blocks)
		var status = Module.ccall('FLAC__stream_encoder_set_metadata', 'number',
				['number', 'number', 'number'],
				[encoder, metadataBuffersPointer.pointerPointer, num_blocks]
		);
		return status;
	},
	/**
	 * Helper object for allocating an array of buffers on the (memory) heap.
	 *
	 * @interface PointerInfo
	 * @memberOf Flac
	 * @property {number}  pointerPointer pointer to the array of (pointer) buffers
	 * @property {number[]}  dataPointer array of pointers to the allocated data arrays (i.e. buffers)
	 *
	 * @see Flac#_create_pointer_array
	 * @see Flac#_destroy_pointer_array
	 */
	/**
	 * Helper function for creating pointer (and allocating the data) to an array of buffers on the (memory) heap.
	 *
	 * Use the returned <code>PointerInfo.dataPointer</code> as argument, where the array-pointer is required.
	 *
	 * NOTE: afer use, the allocated buffers on the heap need be freed, see {@link #_destroy_pointer_array}.
	 *
	 * @param {Uint8Array[]} bufferArray
	 * 						the buffer for which to create
	 *
	 * @returns {Flac.PointerInfo} <code>false</code> if the decoder is already initialized, else <code>true</code>
	 *
	 * @memberOf Flac#
	 * @function
	 *
	 * @see Flac#_destroy_pointer_array
	 */
	_create_pointer_array: function(bufferArray){
		var size=bufferArray.length;
		var ptrs = [], ptrData = new Uint32Array(size);
		var ptrOffsets = new DataView(ptrData.buffer);
		var buffer, numBytes, heapBytes, ptr;
		for(var i=0, size; i < size; ++i){
			buffer = bufferArray[i];
			// get the length of the data in bytes
			numBytes = buffer.length * buffer.BYTES_PER_ELEMENT;
			// malloc enough space for the data
			ptr = Module._malloc(numBytes);
			ptrs.push(ptr);
			// get a bytes-wise view on the newly allocated buffer
			heapBytes = new Uint8Array(Module.HEAPU8.buffer, ptr, numBytes);
			// copy data into heapBytes
			heapBytes.set(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength));// use FIX for issue #11 (2)
			ptrOffsets.setUint32(i*4, ptr, true);
		}
		var nPointerBytes = ptrData.length * ptrData.BYTES_PER_ELEMENT
		var pointerPtr = Module._malloc(nPointerBytes);
		var pointerHeap = new Uint8Array(Module.HEAPU8.buffer, pointerPtr, nPointerBytes);
		pointerHeap.set( new Uint8Array(ptrData.buffer) );

		return {
			dataPointer: ptrs,
			pointerPointer: pointerPtr
		};
	},
	/**
	 * Helper function for destroying/freeing a previously created pointer (and allocating the data) of an array of buffers on the (memory) heap.
	 *
	 * @param {Flac.PointerInfo} pointerInfo
	 * 						the pointer / allocation information that should be destroyed/freed
	 *
	 *
	 * @memberOf Flac#
	 * @function
	 *
	 * @see Flac#_create_pointer_array
	 */
	_destroy_pointer_array: function(pointerInfo){
		var pointerArray = pointerInfo.dataPointer;
		for(var i=0, size=pointerArray.length; i < size; ++i){
			Module._free(pointerArray[i]);
		}
		Module._free(pointerInfo.pointerPointer);
	},
	/**
	 * Get if MD5 verification is enabled for the decoder
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @returns {boolean} <code>true</code> if MD5 verification is enabled
	 *
	 * @memberOf Flac#
	 * @function
	 *
	 * @see #FLAC__stream_decoder_set_md5_checking
	 */
	FLAC__stream_decoder_get_md5_checking: Module.cwrap('FLAC__stream_decoder_get_md5_checking', 'number', ['number']),

	/**
	 * Set the "MD5 signature checking" flag. If true, the decoder will compute the MD5 signature of the unencoded audio data while decoding and compare it to the signature from the STREAMINFO block,
	 * if it exists, during {@link Flac.FLAC__stream_decoder_finish FLAC__stream_decoder_finish()}.
	 *
	 * MD5 signature checking will be turned off (until the next {@link Flac.FLAC__stream_decoder_reset FLAC__stream_decoder_reset()}) if there is no signature in the STREAMINFO block or when a seek is attempted.
	 *
	 * Clients that do not use the MD5 check should leave this off to speed up decoding.
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 * @param {boolean} is_verify
	 * 				enable/disable checksum verification during decoding
	 * @returns {boolean} FALSE if the decoder is already initialized, else TRUE.
	 *
	 * @memberOf Flac#
	 * @function
	 *
	 * @see #FLAC__stream_decoder_get_md5_checking
	 */
	FLAC__stream_decoder_set_md5_checking: function(decoder, is_verify){
		is_verify = is_verify? 1 : 0;
		return Module.ccall('FLAC__stream_decoder_set_md5_checking', 'number', ['number', 'number'], [ decoder, is_verify ]);
	},

	/**
	 * Finish the encoding process.
	 *
	 * @param {number} encoder
	 * 				the ID of the encoder instance
	 *
	 * @returns {boolean} <code>false</code> if an error occurred processing the last frame;
	 * 					 or if verify mode is set, there was a verify mismatch; else <code>true</code>.
	 * 					 If <code>false</code>, caller should check the state with {@link Flac#FLAC__stream_encoder_get_state}
	 * 					 for more information about the error.
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_encoder_finish: Module.cwrap('FLAC__stream_encoder_finish', 'number', [ 'number' ]),
	/**
	 * Finish the decoding process.
	 *
	 * The decoder can be reused, after initializing it again.
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @returns {boolean} <code>false</code> if MD5 checking is on AND a STREAMINFO block was available AND the MD5 signature in
	 * 						 the STREAMINFO block was non-zero AND the signature does not match the one computed by the decoder;
	 * 						 else <code>true</code>.
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_decoder_finish: Module.cwrap('FLAC__stream_decoder_finish', 'number', [ 'number' ]),
	/**
	 * Reset the decoder for reuse.
	 *
	 * <p>
	 * NOTE: Needs to be re-initialized, before it can be used again
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @returns {boolean} true if successful
	 *
	 * @see #init_decoder_stream
	 * @see #init_decoder_ogg_stream
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_decoder_reset: Module.cwrap('FLAC__stream_decoder_reset', 'number', [ 'number' ]),
	/**
	 * Delete the encoder instance, and free up its resources.
	 *
	 * @param {number} encoder
	 * 				the ID of the encoder instance
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_encoder_delete: function(encoder){
		this._clear_enc_cb(encoder);//<- remove callback references
		Module.ccall('FLAC__stream_encoder_delete', 'number', [ 'number' ], [encoder]);
		do_fire_event('destroyed', [{type: 'destroyed', target: {id: encoder, type: 'encoder'}}], false);
	},
	/**
	 * Delete the decoder instance, and free up its resources.
	 *
	 * @param {number} decoder
	 * 				the ID of the decoder instance
	 *
	 * @memberOf Flac#
	 * @function
	 */
	FLAC__stream_decoder_delete: function(decoder){
		this._clear_dec_cb(decoder);//<- remove callback references
		Module.ccall('FLAC__stream_decoder_delete', 'number', [ 'number' ], [decoder]);
		do_fire_event('destroyed', [{type: 'destroyed', target: {id: decoder, type: 'decoder'}}], false);
	}

};//END: var _exported = {

//if Properties are supported by JS execution environment:
// support "immediate triggering" onready function, if library is already initialized when setting onready callback
if(typeof Object.defineProperty === 'function'){
	//add internal field for storing onready callback:
	_exported._onready = void(0);
	//define getter & define setter with "immediate trigger" functionality:
	Object.defineProperty(_exported, 'onready', {
		get() { return this._onready; },
		set(newValue) {
			this._onready = newValue;
			if(newValue && this.isReady()){
				check_and_trigger_persisted_event('ready', newValue);
			}
		}
	});
} else {
	//if Properties are NOTE supported by JS execution environment:
	// pring usage warning for onready hook instead
	console.warn('WARN: note that setting Flac.onready handler after Flac.isReady() is already true, will have no effect, that is, the handler function will not be triggered!');
}

if(expLib && expLib.exports){
	expLib.exports = _exported;
}
return _exported;

}));//END: UMD wrapper
// end include: /home/tema/libflac.js/libflac_post.js

